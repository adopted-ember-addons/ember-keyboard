"use strict"
define("docs/app",["exports","@ember/application","ember-resolver","ember-load-initializers","docs/config/environment","docs/custom-elements/input-in-open-shadow"],(function(e,t,n,o,r,i){function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}Object.defineProperty(e,"__esModule",{value:!0}),e.default=void 0
class s extends t.default{constructor(){super(...arguments),a(this,"modulePrefix",r.default.modulePrefix),a(this,"podModulePrefix",r.default.podModulePrefix),a(this,"Resolver",n.default)}}e.default=s,(0,o.default)(s,r.default.modulePrefix)})),define("docs/component-managers/glimmer",["exports","@glimmer/component/-private/ember-component-manager"],(function(e,t){Object.defineProperty(e,"__esModule",{value:!0}),Object.defineProperty(e,"default",{enumerable:!0,get:function(){return t.default}})})),define("docs/components/key-down-counter",["exports","@glimmer/component","ember-keyboard","@glimmer/tracking"],(function(e,t,n,o){var r,i,a,s,d,l,c,u,p,m,y,b,h,f,g,v,k,w,x,P,A,E,T
function I(e,t,n,o){n&&Object.defineProperty(e,t,{enumerable:n.enumerable,configurable:n.configurable,writable:n.writable,value:n.initializer?n.initializer.call(o):void 0})}function K(e,t,n,o,r){var i={}
return Object.keys(o).forEach((function(e){i[e]=o[e]})),i.enumerable=!!i.enumerable,i.configurable=!!i.configurable,("value"in i||i.initializer)&&(i.writable=!0),i=n.slice().reverse().reduce((function(n,o){return o(e,t,n)||n}),i),r&&void 0!==i.initializer&&(i.value=i.initializer?i.initializer.call(r):void 0,i.initializer=void 0),void 0===i.initializer&&(Object.defineProperty(e,t,i),i=null),i}function j(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1
return function(t,n){this.stopImmediatePropagation&&n.stopImmediatePropagation(),this.stopPropagation&&n.stopPropagation(),this.counter=this.counter+e}}Object.defineProperty(e,"__esModule",{value:!0}),e.default=void 0
let _=(r=(0,n.onKey)("ArrowLeft"),i=(0,n.onKey)("ArrowRight"),a=(0,n.onKey)("shift+ArrowLeft"),s=(0,n.onKey)("shift+ArrowRight"),d=(0,n.onKey)("ctrl+shift+ArrowLeft"),l=(0,n.onKey)("ctrl+shift+ArrowRight"),c=(0,n.onKey)("KeyR",{event:"keyup"}),u=(0,n.onKey)("Digit5",{event:"keypress"}),(0,n.keyResponder)((m=class extends t.default{constructor(){super(...arguments),I(this,"toggleActivated",y,this),I(this,"counter",b,this),I(this,"keyboardPriority",h,this),I(this,"stopPropagation",f,this),I(this,"stopImmediatePropagation",g,this),I(this,"keyboardLaxPriority",v,this),I(this,"keyboardFirstResponder",k,this),I(this,"dec1",w,this),I(this,"inc1",x,this),I(this,"dec10",P,this),I(this,"inc10",A,this),I(this,"dec100",E,this),I(this,"inc100",T,this)}get keyboardActivated(){return(!this.args.activatedToggle||this.toggleActivated)&&this.args.parentActivated}resetCounter(){this.counter=0}resetCounterTo5(){this.counter=5}},y=K(m.prototype,"toggleActivated",[o.tracked],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return!0}}),b=K(m.prototype,"counter",[o.tracked],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return 0}}),h=K(m.prototype,"keyboardPriority",[o.tracked],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return 0}}),f=K(m.prototype,"stopPropagation",[o.tracked],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return!1}}),g=K(m.prototype,"stopImmediatePropagation",[o.tracked],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return!1}}),v=K(m.prototype,"keyboardLaxPriority",[o.tracked],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return!1}}),k=K(m.prototype,"keyboardFirstResponder",[o.tracked],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return!1}}),w=K(m.prototype,"dec1",[r],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return j(-1)}}),x=K(m.prototype,"inc1",[i],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return j(1)}}),P=K(m.prototype,"dec10",[a],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return j(-10)}}),A=K(m.prototype,"inc10",[s],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return j(10)}}),E=K(m.prototype,"dec100",[d],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return j(-100)}}),T=K(m.prototype,"inc100",[l],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return j(100)}}),K(m.prototype,"resetCounter",[c],Object.getOwnPropertyDescriptor(m.prototype,"resetCounter"),m.prototype),K(m.prototype,"resetCounterTo5",[u],Object.getOwnPropertyDescriptor(m.prototype,"resetCounterTo5"),m.prototype),p=m))||p)
e.default=_})),define("docs/components/keyboard-activated-widget",["exports","@ember/component","docs/mixins/enterable"],(function(e,t,n){Object.defineProperty(e,"__esModule",{value:!0}),e.default=void 0
var o=t.default.extend(n.default)
e.default=o})),define("docs/components/keyboard-first-responder-widget",["exports","@ember/component","docs/mixins/enterable"],(function(e,t,n){Object.defineProperty(e,"__esModule",{value:!0}),e.default=void 0
var o=t.default.extend(n.default)
e.default=o})),define("docs/components/keyboard-lax-priority-widget",["exports","@ember/component","docs/mixins/enterable"],(function(e,t,n){Object.defineProperty(e,"__esModule",{value:!0}),e.default=void 0
var o=t.default.extend(n.default)
e.default=o})),define("docs/components/keyboard-priority-widget",["exports","@ember/component","docs/mixins/enterable"],(function(e,t,n){Object.defineProperty(e,"__esModule",{value:!0}),e.default=void 0
var o=t.default.extend(n.default)
e.default=o})),define("docs/components/keyboard-propagation-widget",["exports","@ember/component","@ember/service","@ember/object","docs/mixins/enterable"],(function(e,t,n,o,r){Object.defineProperty(e,"__esModule",{value:!0}),e.default=void 0
var i=t.default.extend(r.default,{keyboard:(0,n.inject)(),_activate(){this._super(...arguments),(0,o.set)(this,"keyboard.isPropagationEnabled",!0)},deactivate(){this._super(...arguments),(0,o.set)(this,"keyboard.isPropagationEnabled",!1)}})
e.default=i})),define("docs/components/mouse-down-counter",["exports","@glimmer/component","ember-keyboard","@glimmer/tracking"],(function(e,t,n,o){var r,i,a,s,d,l,c,u,p,m
function y(e,t,n,o){n&&Object.defineProperty(e,t,{enumerable:n.enumerable,configurable:n.configurable,writable:n.writable,value:n.initializer?n.initializer.call(o):void 0})}function b(e,t,n,o,r){var i={}
return Object.keys(o).forEach((function(e){i[e]=o[e]})),i.enumerable=!!i.enumerable,i.configurable=!!i.configurable,("value"in i||i.initializer)&&(i.writable=!0),i=n.slice().reverse().reduce((function(n,o){return o(e,t,n)||n}),i),r&&void 0!==i.initializer&&(i.value=i.initializer?i.initializer.call(r):void 0,i.initializer=void 0),void 0===i.initializer&&(Object.defineProperty(e,t,i),i=null),i}function h(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1
return function(t,n){this.stopImmediatePropagation&&n.stopImmediatePropagation(),this.stopPropagation&&n.stopPropagation(),this.counter=this.counter+e}}Object.defineProperty(e,"__esModule",{value:!0}),e.default=void 0
let f=(r=(0,n.onKey)("left",{event:"mousedown"}),i=(0,n.onKey)("right",{event:"mousedown"}),a=(0,n.onKey)("middle",{event:"mousedown"}),(0,n.keyResponder)((d=class extends t.default{constructor(){super(...arguments),y(this,"toggleActivated",l,this),y(this,"counter",c,this),y(this,"inc1",u,this),y(this,"inc10",p,this),y(this,"dec10",m,this)}get keyboardActivated(){return(!this.args.activatedToggle||this.toggleActivated)&&this.args.parentActivated}},l=b(d.prototype,"toggleActivated",[o.tracked],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return!0}}),c=b(d.prototype,"counter",[o.tracked],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return 0}}),u=b(d.prototype,"inc1",[r],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return h(1)}}),p=b(d.prototype,"inc10",[i],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return h(10)}}),m=b(d.prototype,"dec10",[a],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return h(-10)}}),s=d))||s)
e.default=f})),define("docs/components/touch-start-counter",["exports","@glimmer/component","ember-keyboard","@glimmer/tracking"],(function(e,t,n,o){var r,i,a,s,d,l
function c(e,t,n,o){n&&Object.defineProperty(e,t,{enumerable:n.enumerable,configurable:n.configurable,writable:n.writable,value:n.initializer?n.initializer.call(o):void 0})}function u(e,t,n,o,r){var i={}
return Object.keys(o).forEach((function(e){i[e]=o[e]})),i.enumerable=!!i.enumerable,i.configurable=!!i.configurable,("value"in i||i.initializer)&&(i.writable=!0),i=n.slice().reverse().reduce((function(n,o){return o(e,t,n)||n}),i),r&&void 0!==i.initializer&&(i.value=i.initializer?i.initializer.call(r):void 0,i.initializer=void 0),void 0===i.initializer&&(Object.defineProperty(e,t,i),i=null),i}Object.defineProperty(e,"__esModule",{value:!0}),e.default=void 0
let p=(r=(0,n.onKey)("",{event:"touchstart"}),(0,n.keyResponder)((a=class extends t.default{constructor(){super(...arguments),c(this,"toggleActivated",s,this),c(this,"counter",d,this),c(this,"inc1",l,this)}get keyboardActivated(){return(!this.args.activatedToggle||this.toggleActivated)&&this.args.parentActivated}},s=u(a.prototype,"toggleActivated",[o.tracked],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return!0}}),d=u(a.prototype,"counter",[o.tracked],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return 0}}),l=u(a.prototype,"inc1",[r],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1
return function(t,n){this.stopImmediatePropagation&&n.stopImmediatePropagation(),this.stopPropagation&&n.stopPropagation(),this.counter=this.counter+e}}(1)}}),i=a))||i)
e.default=p})),define("docs/custom-elements/input-in-open-shadow",[],(function(){if("undefined"==typeof FastBoot){class e extends HTMLElement{async connectedCallback(){const e=this.attachShadow({mode:"open"}),t=document.createElement("input")
e.appendChild(t)}}customElements.define("input-in-open-shadow",e)}})),define("docs/helpers/format-markdown",["exports","marked","highlight.js","@ember/component/helper","@ember/string"],(function(e,t,n,o,r){function i(e){let[o]=e
if(!o)return
t.marked.setOptions({highlight:function(e,t){const o=n.default.getLanguage(t)?t:"plaintext"
return n.default.highlight(e,{language:o}).value},langPrefix:"hljs language-"})
let i=t.marked.parse(o)
return(0,r.htmlSafe)(i)}Object.defineProperty(e,"__esModule",{value:!0}),e.default=void 0,e.formatMarkdown=i
var a=(0,o.helper)(i)
e.default=a})),define("docs/helpers/if-key",["exports","ember-keyboard/helpers/if-key.js"],(function(e,t){Object.defineProperty(e,"__esModule",{value:!0}),Object.defineProperty(e,"default",{enumerable:!0,get:function(){return t.default}})})),define("docs/helpers/on-document",["exports","ember-on-helper/helpers/on-document"],(function(e,t){Object.defineProperty(e,"__esModule",{value:!0}),Object.defineProperty(e,"default",{enumerable:!0,get:function(){return t.default}})})),define("docs/helpers/on-key",["exports","ember-keyboard/helpers/on-key.js"],(function(e,t){Object.defineProperty(e,"__esModule",{value:!0}),Object.defineProperty(e,"default",{enumerable:!0,get:function(){return t.default}})})),define("docs/helpers/on-window",["exports","ember-on-helper/helpers/on-window"],(function(e,t){Object.defineProperty(e,"__esModule",{value:!0}),Object.defineProperty(e,"default",{enumerable:!0,get:function(){return t.default}})})),define("docs/helpers/on",["exports","ember-on-helper/helpers/on"],(function(e,t){Object.defineProperty(e,"__esModule",{value:!0}),Object.defineProperty(e,"default",{enumerable:!0,get:function(){return t.default}})})),define("docs/helpers/pick",["exports","@ember/component/helper","@ember/object"],(function(e,t,n){Object.defineProperty(e,"__esModule",{value:!0}),e.default=void 0
var o=(0,t.helper)((function(e){let[t,o]=e
return function(e){let r=(0,n.get)(e,t)
if(!o)return r
o(r)}}))
e.default=o})),define("docs/helpers/set",["exports","ember-set-helper/helpers/set"],(function(e,t){Object.defineProperty(e,"__esModule",{value:!0}),Object.defineProperty(e,"default",{enumerable:!0,get:function(){return t.default}})})),define("docs/initializers/container-debug-adapter",["exports","ember-resolver/resolvers/classic/container-debug-adapter"],(function(e,t){Object.defineProperty(e,"__esModule",{value:!0}),e.default=void 0
var n={name:"container-debug-adapter",initialize(){(arguments[1]||arguments[0]).register("container-debug-adapter:main",t.default)}}
e.default=n})),define("docs/initializers/export-application-global",["exports","ember","docs/config/environment"],(function(e,t,n){function o(){var e=arguments[1]||arguments[0]
if(!1!==n.default.exportApplicationGlobal){var o
if("undefined"!=typeof window)o=window
else if("undefined"!=typeof global)o=global
else{if("undefined"==typeof self)return
o=self}var r,i=n.default.exportApplicationGlobal
r="string"==typeof i?i:t.default.String.classify(n.default.modulePrefix),o[r]||(o[r]=e,e.reopen({willDestroy:function(){this._super.apply(this,arguments),delete o[r]}}))}}Object.defineProperty(e,"__esModule",{value:!0}),e.default=void 0,e.initialize=o
var r={name:"export-application-global",initialize:o}
e.default=r})),define("docs/instance-initializers/clear-double-boot",["exports","ember-cli-fastboot/instance-initializers/clear-double-boot"],(function(e,t){Object.defineProperty(e,"__esModule",{value:!0}),Object.defineProperty(e,"default",{enumerable:!0,get:function(){return t.default}})})),define("docs/locations/none",["exports","ember-cli-fastboot/locations/none"],(function(e,t){Object.defineProperty(e,"__esModule",{value:!0}),Object.defineProperty(e,"default",{enumerable:!0,get:function(){return t.default}})})),define("docs/mixins/enterable",["exports","@ember/service","@ember/object/mixin"],(function(e,t,n){Object.defineProperty(e,"__esModule",{value:!0}),e.default=void 0
var o=n.default.create({classNames:["keyboard-widget"],classNameBindings:["keyboardActivated:active"],keyboard:(0,t.inject)(),widgetManager:(0,t.inject)(),click(){this._activate()},deactivate(){this.set("keyboardActivated",!1),this.oldPropagationModel&&(this.keyboard.isPropagationEnabled=!0)},_activate(){this.widgetManager.activate(this),this.set("keyboardActivated",!0),this.oldPropagationModel&&(this.keyboard.isPropagationEnabled=!1)}})
e.default=o})),define("docs/mixins/reset-scroll-position",["exports","@ember/object/mixin"],(function(e,t){Object.defineProperty(e,"__esModule",{value:!0}),e.default=void 0
var n=t.default.create({activate(){this._super(...arguments),"undefined"==typeof FastBoot&&window.scrollTo(0,0)}})
e.default=n})),define("docs/modifiers/on-key",["exports","ember-keyboard/modifiers/on-key.js"],(function(e,t){Object.defineProperty(e,"__esModule",{value:!0}),Object.defineProperty(e,"default",{enumerable:!0,get:function(){return t.default}})})),define("docs/router",["exports","@ember/routing/router","docs/config/environment"],(function(e,t,n){function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}Object.defineProperty(e,"__esModule",{value:!0}),e.default=void 0
class r extends t.default{constructor(){super(...arguments),o(this,"location",n.default.locationType),o(this,"rootURL",n.default.rootURL)}}e.default=r,r.map((function(){this.route("deprecations"),this.route("event-propagation"),this.route("priority"),this.route("testing"),this.route("upgrading"),this.route("usage")}))})),define("docs/routes/deprecations",["exports","@ember/routing/route","docs/mixins/reset-scroll-position"],(function(e,t,n){Object.defineProperty(e,"__esModule",{value:!0}),e.default=void 0
var o=t.default.extend(n.default)
e.default=o})),define("docs/routes/event-propagation",["exports","@ember/routing/route","docs/mixins/reset-scroll-position"],(function(e,t,n){Object.defineProperty(e,"__esModule",{value:!0}),e.default=void 0
var o=t.default.extend(n.default)
e.default=o})),define("docs/routes/index",["exports","@ember/routing/route","docs/mixins/reset-scroll-position"],(function(e,t,n){Object.defineProperty(e,"__esModule",{value:!0}),e.default=void 0
var o=t.default.extend(n.default)
e.default=o}))
define("docs/routes/priority",["exports","@ember/routing/route","docs/mixins/reset-scroll-position"],(function(e,t,n){Object.defineProperty(e,"__esModule",{value:!0}),e.default=void 0
var o=t.default.extend(n.default)
e.default=o})),define("docs/routes/testing",["exports","@ember/routing/route","docs/mixins/reset-scroll-position"],(function(e,t,n){Object.defineProperty(e,"__esModule",{value:!0}),e.default=void 0
var o=t.default.extend(n.default)
e.default=o})),define("docs/routes/usage",["exports","@ember/routing/route","docs/mixins/reset-scroll-position"],(function(e,t,n){Object.defineProperty(e,"__esModule",{value:!0}),e.default=void 0
var o=t.default.extend(n.default)
e.default=o})),define("docs/services/fastboot",["exports","ember-cli-fastboot/services/fastboot"],(function(e,t){Object.defineProperty(e,"__esModule",{value:!0}),Object.defineProperty(e,"default",{enumerable:!0,get:function(){return t.default}})})),define("docs/services/keyboard",["exports","@ember/object","@ember/runloop","ember-keyboard/services/keyboard","ember-keyboard/utils/is-key","ember-keyboard/utils/sort"],(function(e,t,n,o,r,i){var a
function s(e,t){let n,o=!0,i=!0
t.every((t=>{const a=t.keyboardFirstResponder,s=t.keyboardPriority
return!!(a||o&&s>=n||i)&&(t.keyboardLaxPriority||(i=!1),a?i||(o=!1):n=s,function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null
if(e.handleKeyboardEvent){if(e.canHandleKeyboardEvent&&!e.canHandleKeyboardEvent(t))return
return void e.handleKeyboardEvent(t,n)}if(e.keyboardHandlers)return void Object.keys(e.keyboardHandlers).forEach((o=>{(0,r.default)(o,t)&&(n?e.keyboardHandlers[o](t,n):e.keyboardHandlers[o](t))}))
throw new Error("A responder registered with the ember-keyboard service must implement either `keyboardHandlers` (property returning a dictionary of listenerNames to handler functions), or `handleKeyboardEvent(event)`)")}(t,e),!0)}))}Object.defineProperty(e,"__esModule",{value:!0}),e.default=void 0
let d=(a=class extends o.default{constructor(){var e,t,n
super(...arguments),n=!0,(t="isPropagationEnabled")in(e=this)?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n}_respond(e){this.isPropagationEnabled?super._respond(e):(0,n.run)((()=>{const t=this.activeResponders.sort(((e,t)=>{let n=(0,i.reverseCompareProp)(e,t,"keyboardFirstResponder",Boolean)
return 0===n?(0,i.reverseCompareProp)(e,t,"keyboardPriority"):n}))
s(e,t)}))}},l=a.prototype,c="_respond",u=[t.action],p=Object.getOwnPropertyDescriptor(a.prototype,"_respond"),m=a.prototype,y={},Object.keys(p).forEach((function(e){y[e]=p[e]})),y.enumerable=!!y.enumerable,y.configurable=!!y.configurable,("value"in y||y.initializer)&&(y.writable=!0),y=u.slice().reverse().reduce((function(e,t){return t(l,c,e)||e}),y),m&&void 0!==y.initializer&&(y.value=y.initializer?y.initializer.call(m):void 0,y.initializer=void 0),void 0===y.initializer&&(Object.defineProperty(l,c,y),y=null),a)
var l,c,u,p,m,y
e.default=d})),define("docs/services/widget-manager",["exports","@ember/service","@ember/utils"],(function(e,t,n){Object.defineProperty(e,"__esModule",{value:!0}),e.default=void 0
var o=t.default.extend({activate(e){let t=this.activeWidget
t&&!(0,n.isEqual)(e,t)&&t.deactivate(),this.set("activeWidget",e)}})
e.default=o})),define("docs/templates/application",["exports","@ember/template-factory"],(function(e,t){Object.defineProperty(e,"__esModule",{value:!0}),e.default=void 0
var n=(0,t.createTemplateFactory)({id:"nCG73qu9",block:'[[[10,0],[14,0,"container"],[12],[1,"\\n  "],[10,"nav"],[14,0,"menu"],[12],[1,"\\n    "],[8,[39,0],null,[["@route"],["index"]],[["default"],[[[[1,"Overview"]],[]]]]],[1,"\\n    "],[8,[39,0],null,[["@route"],["usage"]],[["default"],[[[[1,"Usage"]],[]]]]],[1,"\\n    "],[8,[39,0],null,[["@route"],["event-propagation"]],[["default"],[[[[1,"Event propagation"]],[]]]]],[1,"\\n    "],[8,[39,0],null,[["@route"],["priority"]],[["default"],[[[[1,"Priority (<= 6.x)"]],[]]]]],[1,"\\n    "],[8,[39,0],null,[["@route"],["deprecations"]],[["default"],[[[[1,"Deprecations"]],[]]]]],[1,"\\n    "],[8,[39,0],null,[["@route"],["testing"]],[["default"],[[[[1,"Testing"]],[]]]]],[1,"\\n    "],[8,[39,0],null,[["@route"],["upgrading"]],[["default"],[[[[1,"Upgrading"]],[]]]]],[1,"\\n  "],[13],[1,"\\n  "],[10,0],[14,0,"main"],[12],[1,"\\n    "],[10,0],[14,0,"header"],[12],[1,"\\n      "],[10,"img"],[14,"src","./ember-keyboard.svg"],[14,"alt",""],[14,"role","presentation"],[14,0,"logo"],[12],[13],[1,"\\n      "],[10,"h1"],[14,0,"header-text"],[12],[1,"\\n        "],[10,"code"],[12],[1,"ember-keyboard"],[13],[1,"\\n      "],[13],[1,"\\n      "],[10,3],[14,6,"https://github.com/adopted-ember-addons/ember-keyboard"],[14,"target","_blank"],[14,0,"github"],[14,"rel","noopener noreferrer"],[12],[1,"\\n        "],[10,"img"],[14,"src","./octocat-438c17272c5f0e9f4a6da34d3e4bc5bd.png"],[14,"alt","Octocat"],[14,0,"octocat"],[12],[13],[1,"\\n      "],[13],[1,"\\n    "],[13],[1,"\\n    "],[46,[28,[37,2],null,null],null,null,null],[1,"\\n  "],[13],[1,"\\n"],[13],[1,"\\n"]],[],false,["link-to","component","-outlet"]]',moduleName:"docs/templates/application.hbs",isStrictMode:!1})
e.default=n})),define("docs/templates/components/key-down-counter",["exports","@ember/template-factory"],(function(e,t){Object.defineProperty(e,"__esModule",{value:!0}),e.default=void 0
var n=(0,t.createTemplateFactory)({id:"Vn03e9sr",block:'[[[11,1],[24,0,"counter-container"],[17,1],[12],[1,"\\n"],[41,[30,2],[[[1,"    "],[10,"label"],[12],[10,"code"],[12],[1,"keyboardPriority"],[13],[1,":\\n      "],[10,"input"],[14,0,"input-field"],[14,"data-test-counter-priority-input",""],[15,2,[30,0,["keyboardPriority"]]],[15,"oninput",[28,[37,1],[[28,[37,2],["target.value",[28,[37,3],[[30,0],"keyboardPriority"],null]],null]],null]],[12],[13],[1,"\\n    "],[13],[1,"\\n"]],[]],null],[1,"\\n"],[41,[30,3],[[[1,"    "],[10,"label"],[12],[10,"code"],[12],[1,"keyboardActivated"],[13],[1,":\\n    "],[10,"input"],[14,"data-test-counter-activated-toggle",""],[15,"checked",[30,0,["toggleActivated"]]],[15,"onclick",[28,[37,1],[[28,[37,2],["target.checked",[28,[37,3],[[30,0],"toggleActivated"],null]],null]],null]],[14,4,"checkbox"],[12],[13],[1,"\\n    "],[13],[1,"\\n"]],[]],null],[1,"\\n"],[41,[30,4],[[[1,"    "],[10,"label"],[12],[10,"code"],[12],[1,"keyboardFirstResponder"],[13],[1,":\\n    "],[10,"input"],[14,"data-test-counter-first-responder-toggle",""],[15,"checked",[30,0,["keyboardFirstResponder"]]],[15,"onclick",[28,[37,1],[[28,[37,2],["target.checked",[28,[37,3],[[30,0],"keyboardFirstResponder"],null]],null]],null]],[14,4,"checkbox"],[12],[13],[1,"\\n    "],[13],[1,"\\n"]],[]],null],[1,"\\n"],[41,[30,5],[[[1,"    "],[10,"label"],[12],[10,"code"],[12],[1,"keyboardLaxPriority"],[13],[1,":\\n    "],[10,"input"],[14,"data-test-counter-lax-priority-toggle",""],[15,"checked",[30,0,["keyboardLaxPriority"]]],[15,"onclick",[28,[37,1],[[28,[37,2],["target.checked",[28,[37,3],[[30,0],"keyboardLaxPriority"],null]],null]],null]],[14,4,"checkbox"],[12],[13],[1,"\\n    "],[13],[1,"\\n"]],[]],null],[1,"\\n"],[41,[30,6],[[[1,"    "],[10,"label"],[12],[10,"code"],[12],[1,"stopImmediatePropagation()"],[13],[1,":\\n    "],[10,"input"],[14,"data-test-counter-stop-immediate-propagation-toggle",""],[15,"checked",[30,0,["stopImmediatePropagation"]]],[15,"onclick",[28,[37,1],[[28,[37,2],["target.checked",[28,[37,3],[[30,0],"stopImmediatePropagation"],null]],null]],null]],[14,4,"checkbox"],[12],[13],[1,"\\n    "],[13],[1,"\\n"]],[]],null],[1,"\\n"],[41,[30,7],[[[1,"    "],[10,"label"],[12],[10,"code"],[12],[1,"stopPropagation()"],[13],[1,":\\n    "],[10,"input"],[14,"data-test-counter-stop-propagation-toggle",""],[15,"checked",[30,0,["stopPropagation"]]],[15,"onclick",[28,[37,1],[[28,[37,2],["target.checked",[28,[37,3],[[30,0],"stopPropagation"],null]],null]],null]],[14,4,"checkbox"],[12],[13],[1,"\\n    "],[13],[1,"\\n\\n"]],[]],null],[1,"\\n  "],[10,0],[14,"data-test-counter-counter",""],[12],[1,[30,0,["counter"]]],[13],[1,"\\n\\n"],[13],[1,"\\n"]],["&attrs","@priorityInput","@activatedToggle","@firstResponderToggle","@laxPriorityToggle","@stopImmediatePropagationToggle","@stopPropagationToggle"],false,["if","fn","pick","set"]]',moduleName:"docs/templates/components/key-down-counter.hbs",isStrictMode:!1})
e.default=n})),define("docs/templates/components/keyboard-activated-widget",["exports","@ember/template-factory"],(function(e,t){Object.defineProperty(e,"__esModule",{value:!0}),e.default=void 0
var n=(0,t.createTemplateFactory)({id:"lMBLd7ak",block:'[[[1,[28,[35,0],["\\n## `keyboardActivated`\\n\\nOnce you\'ve included the `EKMixin`, you can activate and deactivate a component\'s keyboard responders by toggling the `keyboardActivated` property. In the examples below, you can toggle each counter\'s `keyboardActivated`:\\n"],null]],[1,"\\n\\n"],[8,[39,1],[[24,"data-test-counter",""]],[["@parentActivated","@activatedToggle"],[[30,0,["keyboardActivated"]],true]],null],[1,"\\n"],[8,[39,1],[[24,"data-test-counter",""]],[["@parentActivated","@activatedToggle"],[[30,0,["keyboardActivated"]],true]],null],[1,"\\n"],[8,[39,1],[[24,"data-test-counter",""]],[["@parentActivated","@activatedToggle"],[[30,0,["keyboardActivated"]],true]],null],[1,"\\n"]],[],false,["format-markdown","key-down-counter"]]',moduleName:"docs/templates/components/keyboard-activated-widget.hbs",isStrictMode:!1})
e.default=n})),define("docs/templates/components/keyboard-first-responder-widget",["exports","@ember/template-factory"],(function(e,t){Object.defineProperty(e,"__esModule",{value:!0}),e.default=void 0
var n=(0,t.createTemplateFactory)({id:"5tqAYMHW",block:'[[[1,[28,[35,0],["\\n### `keyboardFirstResponder`\\n\\nSometimes you\'ll need a component to be the first responder, regardless of its `keyboardPriority` relative to other components. This can be useful if you want a low-priority component to temporarily gain precedence over everything else. To achieve this, use `keyboardFirstResponder`.\\n\\n```hbs\\n{{my-component keyboardPriority=0 keyboardFirstResponder=true}} \x3c!-- has precedence --\x3e\\n{{my-component keyboardPriority=1}}\\n```\\n\\nWhen a component resigns `keyboardFirstResponder`, it will fall back to using its `keyboardPriority`.\\n"],null]],[1,"\\n\\n"],[8,[39,1],[[24,"data-test-counter",""]],[["@parentActivated","@priorityInput","@activatedToggle","@firstResponderToggle","@keyboardPriority"],[[30,0,["keyboardActivated"]],true,true,true,1]],null],[1,"\\n\\n"],[8,[39,1],[[24,"data-test-counter",""]],[["@parentActivated","@priorityInput","@activatedToggle","@firstResponderToggle","@keyboardFirstResponder"],[[30,0,["keyboardActivated"]],true,true,true,true]],null],[1,"\\n\\n"],[8,[39,1],[[24,"data-test-counter",""]],[["@parentActivated","@priorityInput","@activatedToggle","@firstResponderToggle"],[[30,0,["keyboardActivated"]],true,true,true]],null],[1,"\\n"]],[],false,["format-markdown","key-down-counter"]]',moduleName:"docs/templates/components/keyboard-first-responder-widget.hbs",isStrictMode:!1})
e.default=n})),define("docs/templates/components/keyboard-lax-priority-widget",["exports","@ember/template-factory"],(function(e,t){Object.defineProperty(e,"__esModule",{value:!0}),e.default=void 0
var n=(0,t.createTemplateFactory)({id:"R3CL3t9c",block:'[[[1,[28,[35,0],["\\n### `keyboardLaxPriority`\\n\\nBy setting `keyboardLaxPriority` to `true`, you\'re saying that it will not block lower priority responders. This can help if you want a group of high level responders to always get a chance to handle key events without blocking the rest of your app. Note that all components within a given priority must have `keyboardLaxPriority` set to `true` or else the priority level will still block, as per usual.\\n"],null]],[1,"\\n\\n"],[8,[39,1],[[24,"data-test-lax-priority-counter",""]],[["@parentActivated","@priorityInput","@activatedToggle","@firstResponderToggle","@laxPriorityToggle","@keyboardPriority"],[[30,0,["keyboardActivated"]],true,true,true,true,1]],null],[1,"\\n\\n"],[8,[39,1],[[24,"data-test-lax-priority-counter",""]],[["@parentActivated","@priorityInput","@activatedToggle","@firstResponderToggle","@laxPriorityToggle","@keyboardFirstResponder","@keyboardLaxPriority"],[[30,0,["keyboardActivated"]],true,true,true,true,true,true]],null],[1,"\\n\\n"],[8,[39,1],[[24,"data-test-lax-priority-counter",""]],[["@parentActivated","@priorityInput","@activatedToggle","@firstResponderToggle","@laxPriorityToggle"],[[30,0,["keyboardActivated"]],true,true,true,true]],null],[1,"\\n"]],[],false,["format-markdown","key-down-counter"]]',moduleName:"docs/templates/components/keyboard-lax-priority-widget.hbs",isStrictMode:!1})
e.default=n})),define("docs/templates/components/keyboard-priority-widget",["exports","@ember/template-factory"],(function(e,t){Object.defineProperty(e,"__esModule",{value:!0}),e.default=void 0
var n=(0,t.createTemplateFactory)({id:"fK/m7OIe",block:'[[[1,[28,[35,0],["\\n### `keyboardPriority`\\n\\nBy default, all activated components are treated as equal. If you have two components that respond to `ctrl+KeyA`, then both will respond when there\'s a `ctrl+KeyA` event. However, this behavior is undesirable in some scenarios. What if you have a modal open, and you only want it and its child components to respond to key events. You can get this behavior by assigning a higher priority to the modal and its children:\\n\\n```hbs\\nnoPriorityComponent; // priority defaults to 0\\nlowPriorityComponent.set(\'keyboardPriority\', 0);\\n\\nmodal.set(\'keyboardPriority\', 1);\\nmodalChild.set(\'keyboardPriority\', 1);\\n```\\n\\nIn this scenario, when a key is pressed both `modal` and `modalChild` will have a chance to respond to it, while the remaining components will not. Once `modal` and `modalChild` are deactivated or their priority is lowered, then `lowPriorityComponent` and `noPriorityComponent` will be able to respond to key events.\\n\\nPerhaps more conveniently, this property can be passed in through your template:\\n\\n```hbs\\n{{my-component keyboardPriority=1}}\\n{{my-dynamic-component keyboardPriority=dynamicPriority}}\\n```\\n"],null]],[1,"\\n\\n"],[8,[39,1],[[24,"data-test-counter",""]],[["@parentActivated","@priorityInput","@activatedToggle","@keyboardPriority"],[[30,0,["keyboardActivated"]],true,true,1]],null],[1,"\\n"],[8,[39,1],[[24,"data-test-counter",""]],[["@parentActivated","@priorityInput","@activatedToggle"],[[30,0,["keyboardActivated"]],true,true]],null],[1,"\\n"],[8,[39,1],[[24,"data-test-counter",""]],[["@parentActivated","@priorityInput","@activatedToggle"],[[30,0,["keyboardActivated"]],true,true]],null],[1,"\\n"]],[],false,["format-markdown","key-down-counter"]]',moduleName:"docs/templates/components/keyboard-priority-widget.hbs",isStrictMode:!1})
e.default=n})),define("docs/templates/components/keyboard-propagation-widget",["exports","@ember/template-factory"],(function(e,t){Object.defineProperty(e,"__esModule",{value:!0}),e.default=void 0
var n=(0,t.createTemplateFactory)({id:"zvgFV8tG",block:'[[[41,[30,1],[[[1,"  "],[1,[28,[35,1],["\\n  ### Event propagation\\n  "],null]],[1,"\\n"]],[]],null],[1,"\\n"],[1,[28,[35,1],["\\nBy setting `emberKeyboard.propagation` in the `config/environment.js` to `true` (only for 6.x),\\nyou\'re opting into the new event propagation semantics that were introduced in\\n[issue #63](https://github.com/patience-tema-baron/ember-keyboard/issues/63).\\n\\nThe event propagation is designed to mirror how standard DOM events bubble up\\nthe parent node chain and supports calling a\\n[`stopPropagation()` method](https://developer.mozilla.org/en-US/docs/Web/API/Event/stopPropagation)\\nand\\n[`stopImmediatePropagation()` method](https://developer.mozilla.org/en-US/docs/Web/API/Event/stopImmediatePropagation)\\non a second event object pased to your handlers.\\n\\n```js\\nincrementCounter: on(keyDown(\'RightArrow\'), function(event, ekEvent) {\\n  const key = event.code; // => \'RightArrow\'\\n  // ekEvent.stopPropagation();\\n  // ekEvent.stopImmediatePropagation();\\n})\\n```\\n\\nInstead of traversing up the parent node chain, `ember-keyboard` walks down the\\npriority list. This means that all responders with `keyboardFirstResponder` set\\nto `true` will be called first in descending order of their `keyboardPriority`,\\nfollowed by all normal responders in descending order of their `keyboardPriority`.\\n\\nCalling `stopPropagation()` during the first responder phase will allow all\\nfirst responders to get triggered, but will prevent all normal responder to get\\ntriggered.\\n\\nIf you call `stopImmediatePropagation()` during that phase, all following first\\nresponders that have not been triggered yet will be skipped. Event propagation\\nthen continues with the normal responders.\\n\\nYou may call both methods.\\n\\nCalling `stopPropagation()` during the normal responder phase will allow all\\nresponders of the same priority level to get triggered. Lower priority\\nresponders will not get triggered.\\n\\nCalling `stopImmediatePropagation()` during that phase will prevent all\\nresponders of the same priority level that have not been triggered yet from\\ngetting triggered. Event propagation then continues with the next lower priority\\nlevel responders.\\n\\nAgain, you may call both methods.\\n\\nSetting `keyboardLaxPriority` will have no effect, since the semantics are\\nfundamentally incompatible. The major advantage of the new event propagation is,\\nthat higher priority responders get to decide on a per-event basis which events\\nto \'catch\' and which not as opposed to setting or not setting\\n`keyboardLaxPriority` which either \'catches\' no or all events.\\n"],null]],[1,"\\n\\n"],[8,[39,2],[[24,"data-test-propagation-counter",""]],[["@parentActivated","@priorityInput","@activatedToggle","@firstResponderToggle","@stopImmediatePropagationToggle","@stopPropagationToggle","@keyboardPriority","@keyboardFirstResponder","@stopImmediatePropagation"],[[30,0,["keyboardActivated"]],true,true,true,true,true,2,true,true]],null],[1,"\\n"],[8,[39,2],[[24,"data-test-propagation-counter",""]],[["@parentActivated","@priorityInput","@activatedToggle","@firstResponderToggle","@stopImmediatePropagationToggle","@stopPropagationToggle","@keyboardPriority","@keyboardFirstResponder","@stopPropagation"],[[30,0,["keyboardActivated"]],true,true,true,true,true,1,true,true]],null],[1,"\\n"],[8,[39,2],[[24,"data-test-propagation-counter",""]],[["@parentActivated","@priorityInput","@activatedToggle","@firstResponderToggle","@stopImmediatePropagationToggle","@stopPropagationToggle"],[[30,0,["keyboardActivated"]],true,true,true,true,true]],null],[1,"\\n"]],["@v6Intro"],false,["if","format-markdown","key-down-counter"]]',moduleName:"docs/templates/components/keyboard-propagation-widget.hbs",isStrictMode:!1})
e.default=n})),define("docs/templates/components/mouse-down-counter",["exports","@ember/template-factory"],(function(e,t){Object.defineProperty(e,"__esModule",{value:!0}),e.default=void 0
var n=(0,t.createTemplateFactory)({id:"/eSv9KZA",block:'[[[11,1],[24,0,"counter-container"],[17,1],[12],[1,"\\n  "],[10,0],[14,"data-test-mouse-counter-counter",""],[12],[1,[30,0,["counter"]]],[13],[1,"\\n"],[13],[1,"\\n"]],["&attrs"],false,[]]',moduleName:"docs/templates/components/mouse-down-counter.hbs",isStrictMode:!1})
e.default=n})),define("docs/templates/components/touch-start-counter",["exports","@ember/template-factory"],(function(e,t){Object.defineProperty(e,"__esModule",{value:!0}),e.default=void 0
var n=(0,t.createTemplateFactory)({id:"jl8KtPf6",block:'[[[11,1],[24,0,"counter-container"],[17,1],[12],[1,"\\n  "],[10,0],[14,"data-test-touch-counter-counter",""],[12],[1,[30,0,["counter"]]],[13],[1,"\\n"],[13]],["&attrs"],false,[]]',moduleName:"docs/templates/components/touch-start-counter.hbs",isStrictMode:!1})
e.default=n})),define("docs/templates/deprecations",["exports","@ember/template-factory"],(function(e,t){Object.defineProperty(e,"__esModule",{value:!0}),e.default=void 0
var n=(0,t.createTemplateFactory)({id:"3zsEJgBK",block:"[[[1,[28,[35,0],[\"\\n## Deprecated APIs\\n\\nember-keyboard 6 sports a brand new API that is friendlier to template usage and ES6 classes.\\nThe old API is deprecated and will emit warnings when used. This page lists each deprecation\\nwith suggested approaches to migrating to the new APIs.\\n\\n### <a name='ember-keyboard-mixin'></a> ember-keyboard mixin\\n\\nThe mixin API of ember-keyboard is now deprecated and will be removed in ember-keyboard 7.0.0. The\\nmost direct translation to the new API is to use the `@keyResponder` decorator, but our recommendation\\nis to adopt the `on-key` helper and `on-key` element modifier to accomplish in templates what you\\npreviously did in your Javascript files.\\n\\nDecorators require Ember 3.10 or higher. If you are using an Ember version earlier than that, you will\\nneed to stick with template helpers/modifiers and, if needed, the deprecated mixins API.\\n\\nDeprecated:\\n\\n```js\\nimport Component from '@ember/component';\\nimport { EKMixin, keyDown } from 'ember-keyboard';\\n\\nexport default Component.extend(EKMixin, {\\n  triggerSubmit: Ember.on(keyDown('cmd+Enter'), function() {\\n    this.submit();\\n  })\\n});\\n```\\n\\nRecommended:\\n\\n```js\\nimport Component from '@ember/component';\\nimport { keyResponder, onKey } from 'ember-keyboard';\\n\\nexport default keyResponder(Component.extend({\\n  triggerSubmit: onKey('cmd+Enter', { event: 'keydown' }, function() {\\n    this.submit();\\n  })\\n});\\n```\\n\\nNote that by default, the EKMixin would not set `keyboardActivated` to true, while\\n`keyResponder` does.\\n\\nBe aware that ember-keyboard versions before 6.0 had an ambiguous API when it came\\nto specifying key combos. Read the docs regarding `key` vs. `code` properties and\\nbe sure you are specifying the key combo to `on-key` consistent with your\\nintended behavior.\\n\\n### <a name='activate-keyboard-on-init-mixin'></a> activate-keyboard-on-init mixin\\n\\nThe mixin API of ember-keyboard is now deprecated and will be removed in ember-keyboard 7.0.0.\\nThis particular mixin set keyboardActivated to true during initialization of the class.\\n\\nThis behavior is now the default when using the `keyResponder` decorator.\\n\\nDeprecated:\\n\\n```js\\nimport Component from '@ember/component';\\nimport { EKMixin, EKOnInitMixin, keyDown } from 'ember-keyboard';\\n\\nexport default Component.extend(EKMixin, EKOnInitMixin, {\\n  triggerSubmit: Ember.on(keyDown('cmd+Enter'), function() {\\n    this.submit();\\n  })\\n});\\n```\\n\\nReplacement:\\n\\n```js\\nimport Component from '@ember/component';\\nimport { keyResponder, onKey } from 'ember-keyboard';\\n\\nexport default keyResponder(Component.extend({\\n  triggerSubmit: onKey('cmd+Enter', { event: 'keydown' }, function() {\\n    this.submit();\\n  })\\n});\\n```\\n\\n### <a name='activate-keyboard-on-insert-mixin'></a> activate-keyboard-on-insert mixin\\n\\nThe mixin API of ember-keyboard is now deprecated and will be removed in ember-keyboard 7.0.0.\\nThis particular mixin set keyboardActivated to true on didInsertElement of a component.\\n\\nBy default `keyboardActivated` now starts off set to true when using `keyResponder` decorator.\\n\\nUsage including this mixin can usually be refactored nicely to use the `on-key` helper in the\\ncomponent's template.\\n\\nDeprecated:\\n\\n```js\\nimport Component from '@ember/component';\\nimport { EKMixin, EKOnInsertMixin, keyDown } from 'ember-keyboard';\\n\\nexport default Component.extend(EKMixin, EKOnInsertMixin, {\\n  triggerSubmit: Ember.on(keyDown('cmd+Enter'), function() {\\n    this.submit();\\n  })\\n});\\n```\\n\\nReplacement:\\n\\n```js\\nimport Component from '@ember/component';\\nimport { keyResponder, onKey } from 'ember-keyboard';\\n\\nexport default keyResponder(Component.extend({\\n  keyboardActivated: false,\\n  triggerSubmit: onKey('cmd+Enter', { event: 'keydown' }, function() {\\n    this.submit();\\n  }),\\n  didInsertElement() {\\n    this._super(...arguments);\\n    this.set('keyboardActivated', true);\\n  }\\n});\\n```\\n\\n### <a name='activate-keyboard-on-focus-mixin'></a> activate-keyboard-on-focus mixin\\n\\nThe mixin API of ember-keyboard is now deprecated and will be removed in ember-keyboard 7.0.0.\\nThis particular mixin set keyboardActivated to true whenever it receives focus and to false\\nwhen it loses focus.\\n\\nThis was primarily useful for input components. This behavior is now automatic when using the\\n`on-key` modifier with a text field. For other use cases, you implement manually.\\n\\nDeprecated:\\n\\n```js\\nimport Component from '@ember/component';\\nimport { EKMixin, EKOnFocusMixin, keyDown } from 'ember-keyboard';\\n\\nexport default Component.extend(EKMixin, EKOnFocusMixin, {\\n  triggerSubmit: Ember.on(keyDown('cmd+Enter'), function() {\\n    this.submit();\\n  })\\n});\\n```\\n\\nReplacement:\\n\\n```js\\nimport Component from '@ember/component';\\nimport { keyResponder, onKey } from 'ember-keyboard';\\nimport action from '@ember/object';\\n\\nexport default keyResponder(Component.extend({\\n  keyboardActivated: false,\\n  triggerSubmit: onKey('cmd+Enter', { event: 'keydown' }, function() {\\n    this.submit();\\n  }),\\n\\n  didInsertElement() {\\n    this._super(...arguments);\\n    this.element.addEventListener('click', this.activateKeyboardWhenFocused);\\n    this.element.addEventListener('focusin', this.activateKeyboardWhenFocused);\\n    this.element.addEventListener('focusout', this.deactivateKeyboardWhenFocusOut);\\n  },\\n\\n  willDestroyElement() {\\n    this._super(...arguments);\\n    this.element.removeEventListener('click', this.activateKeyboardWhenFocused);\\n    this.element.removeEventListener('focusin', this.activateKeyboardWhenFocused);\\n    this.element.removeEventListener('focusout', this.deactivateKeyboardWhenFocusOut);\\n  },\\n\\n  @action\\n  activateKeyboardWhenFocused() {\\n    set(this, 'keyboardActivated', true);\\n  }),\\n\\n  @action\\n  deactivateKeyboardWhenFocusOut() {\\n    set(this, 'keyboardActivated', false);\\n  })\\n});\\n```\\n\\n\\n### <a name='keyboard-first-responder-on-focus-mixin'></a> keyboard-first-responder-on-focus mixin\\n\\nThe mixin API of ember-keyboard is now deprecated and will be removed in ember-keyboard 7.0.0.\\nThis particular mixin set keyboardActivated and keyboardFirstResponder to true whenever it\\nreceives focus and to false when it loses focus.\\n\\nThis was primarily useful for input components. This behavior is now automatic when using the\\n`on-key` modifier with a text field. For other use cases, you implement manually.\\n\\nDeprecated:\\n\\n```js\\nimport Component from '@ember/component';\\nimport { EKMixin, EKFirstResponderOnFocusMixin, keyDown } from 'ember-keyboard';\\n\\nexport default Component.extend(EKMixin, EKFirstResponderOnFocusMixin, {\\n  triggerSubmit: Ember.on(keyDown('cmd+Enter'), function() {\\n    this.submit();\\n  })\\n});\\n```\\n\\nReplacement:\\n\\n```js\\nimport Component from '@ember/component';\\nimport { keyResponder, onKey } from 'ember-keyboard';\\nimport action from '@ember/object';\\n\\nexport default keyResponder(Component.extend({\\n  keyboardActivated: false,\\n  keyboardFirstResponder: false,\\n  triggerSubmit: onKey('cmd+Enter', { event: 'keydown' }, function() {\\n    this.submit();\\n  }),\\n\\n  didInsertElement() {\\n    this._super(...arguments);\\n    this.element.addEventListener('click', this.activateKeyboardWhenFocused);\\n    this.element.addEventListener('focusin', this.activateKeyboardWhenFocused);\\n    this.element.addEventListener('focusout', this.deactivateKeyboardWhenFocusOut);\\n  },\\n\\n  willDestroyElement() {\\n    this._super(...arguments);\\n    this.element.removeEventListener('click', this.activateKeyboardWhenFocused);\\n    this.element.removeEventListener('focusin', this.activateKeyboardWhenFocused);\\n    this.element.removeEventListener('focusout', this.deactivateKeyboardWhenFocusOut);\\n  },\\n\\n  @action\\n  activateKeyboardWhenFocused() {\\n    set(this, 'keyboardActivated', true);\\n    set(this, 'keyboardFirstResponder', true);\\n  }),\\n\\n  @action\\n  deactivateKeyboardWhenFocusOut() {\\n    set(this, 'keyboardActivated', false);\\n    set(this, 'keyboardFirstResponder', false);\\n  })\\n});\\n```\\n### <a name='keyboard-press'></a> keyboard-press\\n\\nember-keyboard 6.0.0-beta.0 included the `keyboard-press` component as public API.\\nIt has been deprecated and will be removed in ember-keyboard 7.0.0. You should use\\nthe `on-key` helper instead:\\n\\nDeprecated:\\n\\n```hbs\\n{{keyboard-press key='alt+Slash' onPress=(action 'onSlash')}}\\n```\\n\\nRecommended:\\n\\n```hbs\\n{{on-key 'alt+Slash' (action 'onSlash')}}\\n```\\n\\nBe aware that ember-keyboard versions before 6.0 had an ambiguous API when it came\\nto specifying key combos. Read the docs regarding `key` vs. `code` properties and\\nbe sure you are specifying the key combo to `on-key` consistent with your\\nintended behavior.\\n\\n### <a name='keyboard-shortcut'></a> keyboard-shortcut\\n\\nember-keyboard 6.0.0-beta.0 included the `keyboard-shortcut` modifier as public API.\\nIt has been deprecated and will be removed in ember-keyboard 7.0.0. You should use\\nthe `on-key` modifier instead, with no action:\\n\\nDeprecated:\\n\\n```hbs\\n\x3c!-- Keydown with the B key triggers a click of the button --\x3e\\n<button {{keyboard-shortcut 'KeyB'}}>Press me or 'B'</button>\\n```\\n\\nRecommended:\\n\\n```hbs\\n\x3c!-- Keydown with the B key triggers a click of the button --\x3e\\n<button {{on-key 'KeyB'}}>Press me or 'B'</button>\\n```\\n\\nBe aware that ember-keyboard versions before 6.0 had an ambiguous API when it came\\nto specifying key combos. Read the docs regarding `key` vs. `code` properties and\\nbe sure you are specifying the key combo to `on-key` consistent with your\\nintended behavior.\\n\\n### <a name='on-keyboard'></a> on-keyboard\\n\\nember-keyboard 6.0.0-beta.0 included the `on-keyboard` modifier as public API.\\nIt has been deprecated and will be removed in ember-keyboard 7.0.0. You should use\\nthe `on-key` modifier instead:\\n\\nDeprecated:\\n\\n```hbs\\n\x3c!-- Keydown of Enter key triggers @onEnterPressedInInput when the input field is focused --\x3e\\n<input type='text'\\n  oninput={{action (mut this.textFieldValue) value='target.value'}}\\n  {{on-keyboard 'Enter' @onEnterPressedInInput}}\\n>\\n```\\n\\nRecommended:\\n\\n```hbs\\n<input type='text'\\n  oninput={{action (mut this.textFieldValue) value='target.value'}}\\n  {{on-key 'Enter' @onEnterPressedInInput}}\\n>\\n```\\n\\nBe aware that ember-keyboard versions before 6.0 had an ambiguous API when it came\\nto specifying key combos. Read the docs regarding `key` vs. `code` properties and\\nbe sure you are specifying the key combo to `on-key` consistent with your\\nintended behavior.\\n\\n### <a name='responder-trigger'></a> responders handling keyboard events via trigger\\n\\nember-keyboard versions before 6.0 used the Ember.Evented API as the mechanism for\\ntriggering handlers on a responder. In particular the methods are `has(listenerName)`\\nand `trigger(listenerName, event)`. This approach has been deprecated for two reasons.\\nFirst, like all mixins in Ember, the `Evented` mixin is discouraged at this point. Second,\\nwe're providing a new API that allows the service to more flexibly determine whether a\\nresponder is a match for an event.\\n\\nIn most cases using ember-keyboard, you don't need to be familiar with this part of the\\nember-keyboard responder API. If you're seeing this message, it may be due to a custom responder\\nimplementation or to a deprecated mixin.\\n\\nThe recommended way to resolve this warning is to adopt one of the two following APIs in the\\nresponder in question:\\n\\nThe first is a declarative API, in which the responder implements a\\nproperty named `keyboardHandlers` returning a dictionary mapping listenerNames to handler\\nfunctions. In this case, the ember-keyboard service will determine if you the dictionary\\nincludes a match for a specific KeryboardEvent and invoke the respective handler if so.\\nSee the implementation of the `on-key` helper for an example.\\n\\nThe second is an imperative API, where your responder will have control over whether it\\nshould be considered capable of handling a given KeyboardEvent, and exactly how to handle\\nit. This is accomplished by implementing the `handleKeyboardEvent(event, ekEvent)` method\\nand optionally the `canHandleKeyboardEvent(event)` method. See the `on-key` modifer for\\nan example.\\n\\n### <a name='first-responder-inputs'></a> `ember-keyboard-first-responder-inputs` initializer\\n\\nember-keyboard includes an initialize that reopens ember's TextArea and TextField components and mixes in\\nEKMixin and EKFirstResponderOnFocusMixin. The `on-key` modifier added in 6.0 accomplishes a similar goal\\nin a less intrusive and less hidden way. This initializer will be removed in 7.0. To opt out of it now\\nand remove the deprecation warning, disable the initializer by setting `emberKeyboard.disableInputsInitializer`\\nin the `config/environment.js` to `true`.\\n\\nRelated to this, if you were importing `{ initializer } from 'ember-keyboard'` in any integration tests, this should no\\nlonger be necessary as Ember integration tests now run initializers themselves. This export will be removed in 7.0 as well.\\n\\n### <a name='old-propagation-model'></a> Old propagation model\\n\\nBy setting `emberKeyboard.propagation` in the `config/environment.js` to `true`,\\nyou're opting into the new event propagation semantics that were introduced in\\n[issue #63](https://github.com/patience-tema-baron/ember-keyboard/issues/63).\\n\\nThe event propagation is designed to mirror how standard DOM events bubble up\\nthe parent node chain and supports calling a\\n[`stopPropagation()` method](https://developer.mozilla.org/en-US/docs/Web/API/Event/stopPropagation)\\nand\\n[`stopImmediatePropagation()` method](https://developer.mozilla.org/en-US/docs/Web/API/Event/stopImmediatePropagation)\\non a second event object pased to your handlers.\\n\\nThe old propagation model will be removed in 7.0. To opt out of it now\\nand remove the deprecation warning, opt in for the propagation model by setting `emberKeyboard.propagation`\\nin the `config/environment.js` to `true`.\\n\"],null]],[1,\"\\n\"]],[],false,[\"format-markdown\"]]",moduleName:"docs/templates/deprecations.hbs",isStrictMode:!1})
e.default=n})),define("docs/templates/event-propagation",["exports","@ember/template-factory"],(function(e,t){Object.defineProperty(e,"__esModule",{value:!0}),e.default=void 0
var n=(0,t.createTemplateFactory)({id:"ChWSMHXw",block:'[[[1,[28,[35,0],["\\n## Event propagation (6.x and up)\\n\\nBelow is an interactive demo of `ember-keyboard`\'s event propagation system.\\nIt allows you to see how devent propagation semantics work.\\nSimply click the containing box and try using the below key commands.\\n\\nControls:\\n\\n* `LeftArrow`: decrement counter by 1\\n* `RightArrow`: increment counter by 1\\n* `shift`+ArrowKey: increment/decrement x10\\n* `ctrl+shift`+ArrowKey: increment/decrement x100\\n* `r`: resets counter to 0\\n"],null]],[1,"\\n\\n"],[8,[39,1],null,null,null],[1,"\\n"]],[],false,["format-markdown","keyboard-propagation-widget"]]',moduleName:"docs/templates/event-propagation.hbs",isStrictMode:!1})
e.default=n})),define("docs/templates/index",["exports","@ember/template-factory"],(function(e,t){Object.defineProperty(e,"__esModule",{value:!0}),e.default=void 0
var n=(0,t.createTemplateFactory)({id:"8P9gBWAW",block:'[[[1,[28,[35,0],["\\n## Installation\\n\\n```sh\\nember install ember-keyboard\\n```\\n\\n## Overview\\n\\n`ember-keyboard` is a KeyboardEvent manager for Ember.js. It provides a simple API for responding to key events based on the keyboard combos such as `shift+ctrl+s` and `ctrl+Slash` and allows you to declare these behaviors wherever it is most convenient, including via a handy `on-key` template helper and modifier.\\n\\nFor more complex scenarios, `ember-keyboard` also offers an API for managing which components and routes respond to key events, allowing you to control for application states such as modals and loading screens.\\n\\nRead on to learn [how to use this addon](http://adopted-ember-addons.github.io/ember-keyboard/usage).\\n"],null]],[1,"\\n"]],[],false,["format-markdown"]]',moduleName:"docs/templates/index.hbs",isStrictMode:!1})
e.default=n})),define("docs/templates/priority",["exports","@ember/template-factory"],(function(e,t){Object.defineProperty(e,"__esModule",{value:!0}),e.default=void 0
var n=(0,t.createTemplateFactory)({id:"kwaL4S0g",block:'[[[1,[28,[35,0],["\\n## Priority (6.x and below)\\n\\nBelow are several interactive demos of `ember-keyboard` properties. They allow you to see how different properties interact with each other. Simply click the containing box and try using the below key commands.\\n\\nControls:\\n\\n* `LeftArrow`: decrement counter by 1\\n* `RightArrow`: increment counter by 1\\n* `shift`+ArrowKey: increment/decrement x10\\n* `ctrl+shift`+ArrowKey: increment/decrement x100\\n* `r`: resets counter to 0\\n"],null]],[1,"\\n\\n"],[8,[39,1],null,[["@oldPropagationModel"],[true]],null],[1,"\\n\\n"],[8,[39,2],null,[["@oldPropagationModel"],[true]],null],[1,"\\n\\n"],[8,[39,3],null,[["@oldPropagationModel"],[true]],null],[1,"\\n\\n"],[8,[39,4],null,[["@oldPropagationModel"],[true]],null],[1,"\\n\\n"],[8,[39,5],null,[["@v6Intro"],[true]],null],[1,"\\n"]],[],false,["format-markdown","keyboard-activated-widget","keyboard-priority-widget","keyboard-first-responder-widget","keyboard-lax-priority-widget","keyboard-propagation-widget"]]',moduleName:"docs/templates/priority.hbs",isStrictMode:!1})
e.default=n})),define("docs/templates/testing",["exports","@ember/template-factory"],(function(e,t){Object.defineProperty(e,"__esModule",{value:!0}),e.default=void 0
var n=(0,t.createTemplateFactory)({id:"oHkT21Lp",block:"[[[1,[28,[35,0],[\"\\n## Testing\\n\\n### Trigger Key Events\\n\\nIf you need to manually trigger a key event (such as in a component integration test), you can use `triggerKeyDown`, `triggerKeyPress`, and `triggerKeyUp`. By default, the event triggers on the `document`, but you can optionally provide a DOM element as the second argument:\\n\\n```js\\nimport { triggerKeyDown, triggerKeyPress, triggerKeyUp } from 'ember-keyboard';\\n\\n. . . .\\n\\ntest('test my key bindings', function(assert) {\\n  triggerKeyDown('KeyA'); // triggers on `document`\\n  triggerKeyUp('KeyA+shift+cmd', document.getElementById('foo')); // triggers on `#foo`\\n});\\n```\\n\\n### Async Acceptance Test Helpers\\n\\n`ember-keyboard` comes with some test helpers to help out with your acceptance tests.\\n\\n```js\\nimport { keyDown, keyUp, keyPress } from 'ember-keyboard/test-support/test-helpers';\\n. . . .\\n\\ntest('test my key bindings', function(assert) {\\n  . . . .\\n  await keyUp('ArrowRight'); // triggers on document\\n  await keyDown('ArrowRight+ctrl+shift', document.getElementById('foo')); // triggers on `#foo`\\n  . . . .\\n});\\n```\\n\"],null]],[1,\"\\n\"]],[],false,[\"format-markdown\"]]",moduleName:"docs/templates/testing.hbs",isStrictMode:!1})
e.default=n})),define("docs/templates/upgrading",["exports","@ember/template-factory"],(function(e,t){Object.defineProperty(e,"__esModule",{value:!0}),e.default=void 0
var n=(0,t.createTemplateFactory)({id:"ILNUYVjC",block:'[[[1,[28,[35,0],["\\n## Upgrading\\n\\n### Upgrading from ember-keyboard 5.x to 6.x\\n\\nember-keyboard 6.0 introduces new APIs to bring ember-keyboard into the Ember Octane era.\\nThe old mixins-based API still works but is deprecated in 6.0 and slated for removal in version 7.\\n\\nVersion 6 requires Ember 3.8 or higher, so if you are on a version of Ember before that, you should\\nstick with 5.0.0 until you are able to upgrade your app\'s Ember version.\\n\\nIf your app is on a recent version of Ember, you are good to go. The path is to upgrade to\\nember-keyboard 6.x and you can iteratively update to the new APIs until you have no more\\ndeprecation warnings left.\\n\\nThe [deprecations](deprecations) page discusses migration paths for each warning you may encounter,\\nbut our broader advice is to consider moving as much of your keyboard handling logic to templates\\nas possible. We think that you\'ll find the `on-key` helper and modifier to be very convenient to\\nwork with. The decorator API (which required ember 3.10 or higher) is closest equivalent to the\\nmixins API, but it should be used sparingly in situations where the template approach isn\'t a\\ngood fit.\\n\\nThere is one other potential *breaking* change to be aware of when upgrading from v5 to v6:\\nember-keyboard versions before 6.0 had an ambiguous API when it came to specifying key combos\\nand required the use of `code` identifiers, like `KeyT`, `Digit1`, etc. Be sure to read the\\n[docs regarding `key` vs. `code` properties](usage) and be sure you are specifying the key\\ncombo consistent with your intended behavior. You will likely find that you want to update some key\\ncombos to the `key` equivalent. e.g. replace `ctrl+KeyT` with `ctrl+t`.\\n\\n### Upgrading from ember-keyboard 6.x to 7.x\\n\\nember-keyboard 7.0 removes the old mixins-based APIs deprecated in 6.x cycle.\\n\\nIf you use ember-keyboard 5.x, it\'s highly advised to upgrade to ember-keyboard 6.x first\\nand iteratively update to the new APIs until you have no more\\ndeprecation warnings left.\\nThen, upgrade to ember-keyboard 7.x should pretty simple and straightforward.\\n\\n#### keyboard-press component, keyboard-shortcut and on-keyboard modifiers\\n\\nYou should use the `on-key` helper or `on-key` modifier instead.\\n\\nFor more examples see [deprecations page](/deprecations#keyboard-press).\\n\\nBe aware that ember-keyboard versions before 6.0 had an ambiguous API when it came\\nto specifying key combos. Read the docs regarding `key` vs. `code` properties and\\nbe sure you are specifying the key combo to `on-key` consistent with your\\nintended behavior.\\n\\n#### Event propagation\\n\\nThe new event propagation semantics (introduced in [#63](https://github.com/patience-tema-baron/ember-keyboard/issues/63))\\nremoved automatic blocking of lower priority responders.\\n\\nYou should use `ekEvent.stopPropagation()` or `ekEvent.stopPropagation()` instead (baed on use case).\\n\\nFor more details see [Event Propagation](/event-propagation) page.\\n\\n#### The mixin APIs\\n\\nThe most direct translation to the new API is to use the `@keyResponder` decorator,\\nbut our recommendation is to adopt the `on-key` helper and `on-key` element modifier\\nto accomplish in templates what you previously did in your Javascript files.\\n\\nFor more examples with suggested approaches to migrating to the new APIs see [deprecations page](/deprecations).\\n\\n#### responders handling keyboard events via trigger\\n\\nThe Ember.Evented API mechanism for triggering handlers on a responder\\n(using `has(listenerName)` and `trigger(listenerName, event)` methods) should be replaced\\nwith `handleKeyboardEvent(event, ekEvent)` and optionally the `canHandleKeyboardEvent(event)` methods.\\n\\nFor more examples see [deprecations page](/deprecations#responder-trigger).\\n"],null]],[1,"\\n"]],[],false,["format-markdown"]]',moduleName:"docs/templates/upgrading.hbs",isStrictMode:!1})
e.default=n})),define("docs/templates/usage",["exports","@ember/template-factory"],(function(e,t){Object.defineProperty(e,"__esModule",{value:!0}),e.default=void 0
var n=(0,t.createTemplateFactory)({id:"f6peH0Yk",block:"[[[1,[28,[35,0],[\"\\n## Usage\\n\\n### Using ember-keyboard in templates (recommended!)\\n\\nTo declaratively attach an action to a keyboard event while a particular template\\nis rendered, use the `on-key` helper. In this example, when a user presses the '/'\\nkey, the onSlash action is triggered.\\n\\n```htmlbars\\n{{on-key '/' this.onSlash}}\\n```\\n\\nNote that the listener is active for the lifecycle of the helper. When the helper is unrendered, the listener is removed.\\n\\nModifiers like alt, shift, and ctrl are supported, too:\\n\\n```hbs\\n{{on-key 'alt+c' this.doThing}}\\n```\\n\\nBy default, actions will be triggered on the `keydown` event. To fire it on\\n`keyup` or (the deprecated) `keypress`, specify the `event`:\\n\\n```hbs\\n{{on-key 'alt+c' this.doThing event='keyup'}}\\n```\\n\\nTo bind multiple key combos, including to the same action, include the helper multiple times:\\n\\n```hbs\\n{{on-key 'alt+c' this.doThing}}\\n{{on-key 'ctrl+shift+t' this.doThing}}\\n```\\n\\nIn the examples above, 'c', 't', and '/' are interpreted to mean “the key that\\nwas pressed produces the specified character under normal circumstances.” In\\nthe W3C's specifications for DOM keyboard events, this is known as the `key`\\nproperty. There is another property, called `code`, which is based on the\\n”standard position“ of a key regardless of what remapping may be in place.\\nValues for `code` look like `KeyC`, `Digit1`, `Backspace`, etc. [You can find a\\nfull list here.](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code/code_values)\\nValues for `code` and `key` don't overlap, so if `ember-keyboard` will\\nautomatically infer which property you care about based on how you specify your\\nkey combo. For example,\\n\\n```hbs\\n\x3c!-- Fires DoThing on keydown of the key at the standard position of the C key\\n     while Alt is pressed. This is inferred from the use of `KeyC` rather than `c` --\x3e\\n{{on-key 'alt+KeyC' this.doThing}}\\n```\\n\\nThere is a 'magic' key combo to match any key: `_all`.\\n\\n```hbs\\n\x3c!-- Fires DoThing on keydown of alt plus any key --\x3e\\n{{on-key 'alt+_all' this.doThing}}\\n\\n\x3c!-- Fires DoThing on keyup of any key, irrespective of modifier keys --\x3e\\n{{on-key '_all' this.doThing event='keyup'}}\\n```\\n\\nAnother option (supported in Ember 3.8+) for templates is the `on-key` element modifier. This allows a keydown event to trigger an action. In the following example, we trigger an action when the input field is focused and the user presses enter:\\n\\n```htmlbars\\n<input type='text'\\n  oninput={{action (mut this.textFieldValue) value='target.value'}}\\n  {{on-key 'Enter' (action 'onEnterPressedInInput')}}\\n>\\n```\\n\\nIf you want a shortcut for triggering a click on an element when a key is pressed,\\nyou can use the same modifier without an action (also Ember 3.8+). This allows a\\nkeyboard event to simulate clicking the element the modifier is attached to.\\nIn the following example, we trigger a click on the button when the B key is\\npressed together with the Alt key:\\n\\n```htmlbars\\n<button {{on 'click' @onButtonClick}} {{on-key 'alt+b'}}>\\n  Press me or press 'Alt-B'\\n</button>\\n```\\n\\n### Using ember-keyboard with your Javascript classes\\n\\nember-keyboard also offers an API for making your own object a “responder”, in\\nthe library's parlance. This means the object gets registered with the `keyboard`\\nservice, and can handle one or more key combos.\\n\\nFor ES6 classes, this accomplished by using the class decorator `@keyResponder`\\nand the method decorator `@onKey`. For example:\\n\\n```js\\nimport Component from '@glimmer/component';\\nimport { keyResponder, onKey } from 'ember-keyboard';\\n\\n@keyResponder\\nexport default class extends Component {\\n  //...\\n\\n  @onKey('alt+c')\\n  doSomethingA() { ... }\\n\\n  @onKey('alt+c', { event: 'keyup' })\\n  doSomethingB() { ... }\\n\\n  @onKey('ctrl+2') // Binding multiple combos to one method\\n  @onKey('ctrl+shift+KeyT')\\n  doSomethingC() { ... }\\n\\n  //...\\n}\\n```\\n\\nAs shown in the example code above, the `@onKey` decorator accepts a key combo as\\nthe first argument, and a optional `options` argument, allowing you to specify an\\nalternate event (default is `keydown`).\\n\\nThe `@keyResponder` decorator accepts an optional `options` argument to allow\\na shortcut for setting the `keyboardPriority` of this responder.\\n\\n```js\\n@keyResponder({ priority: 2 })\\nexport default class extends Component {\\n  //...\\n}\\n```\\n\\nIn addition to Glimmer Component classes, you can use these decorators on services,\\nroutes, controllers, etc, provided that they are ES6 classes.\\n\\nDecorators require Ember 3.10 or higher. If you are using an Ember version earlier than that, you will\\nneed to stick with template helpers/modifiers.\\n\\nFor “classic” Ember classes, the usage of the decorator imports is a little different:\\n\\n```js\\nimport Component from '@ember/component';\\nimport { keyResponder, onKey } from 'ember-keyboard';\\n\\nexport default keyResponder(Component.extend({\\n  //...\\n  doSomethingA: onKey('alt+c', function() { ... }),\\n\\n  doSomethingB: onKey('alt+c', { event: 'keyup' }, function() { ... })\\n\\n  // Binding multiple combos.\\n  doSomethingC: onKey('alt+c', onKey('ctrl+shift+KeyT'), function() {\\n    ...\\n  }),\\n\\n//...\\n}));\\n```\\n\\n### Low-level key-matching API\\n\\nA low-level API for the matching engine that determines whether a particular keyboard event is\\nconsidered to match a specified key-combo will also be exposed.\\n\\nIt will be available (and used internally) as an `isKey` JS function:\\n\\n```js\\nimport { isKey } from 'ember-keyboard';\\n\\nfunction onEvent(ev) {\\n  if (isKey('keydown:alt+x', ev)) {\\n    this.handleKeydownWithAltX();\\n  }\\n}\\n```\\n\\nA variation will also be available as an `if-key` helper that can be used\\nany place a function that received a KeyboardEvent would be used:\\n\\n```hbs\\n{{!-- attach your own event handler using the {{on}} modifier --}}\\n\\n<div {{on 'keydown' (if-key 'alt+c' this.doThing)}}></div>\\n\\n{{!-- combining with the ember-on-helper addon --}}\\n\\n{{on-document 'keydown' (if-key 'alt+KeyX' this.doThing)}}\\n\\n{{!-- use some third-party component API --}}\\n\\n<SomeComponent @onKey={{if-key 'alt+x' this.doThing}}/>\\n```\\n\\nNote that low-level usage like this will not participate in the wider ember-keyboard functionality\\n(responders, priority, etc), but can be useful if you just want to leverage the key combo\\nmatching code of ember-keyboard.\\n\\n### Modifier Keys\\n\\nAs you have seen from the example code above, you can augment your key bindings with modifier keys,\\nincluding `ctrl`, `shift`, `alt`, and `meta`. In addition, `ember-keyboard` supports a special key\\ndefinition called `cmd`. It is very common for MacOS users to expect to use key combinations such\\nas Command(⌘)+Key, where a PC or Linux user would use Ctrl+Key. `cmd` handles this behavior.\\nFor instance this defintion:\\n\\n```js\\n@onKey('cmd+Enter')\\ntriggerSubmit() {\\n  ...\\n});\\n```\\n\\nwill trigger on Command(⌘)+Enter on macOS or Ctrl+Enter on all other platforms.\\n\\nNote that `ctrl` should be used with caution, as MacOS will swallow some `ctrl` events before `ember-keyboard` can observe them.\\n\\n### `keyUp`, `keyDown`, `keyPress`, `mouseDown`, `mouseUp`, `click`, `touchStart`, and `touchEnd`\\n\\nBy default, `ember-keyboard` listens to `keydown`, `keyup`, and `keypress`. It can optionally listen\\nto `mousedown`, `mouseup`, `click`, `touchstart`, and `touchend` as well.\\n\\nIf you want `ember-keyboard` to listen to fewer events or to add any of the mouse/touch event, then you can specify them in your `config/environment.js` file like so:\\n\\n```js\\nENV.emberKeyboard = {\\n  listeners: ['keyUp', 'keyDown', 'click'] // use only `keyUp`, `keyDown`, and `click`\\n}\\n```\\n\\nNote that `keydown` events fire repeatedly while the key is pressed, while `keyup` events fire only once,\\nafter the key has been released.\\n\\n### Mouse Events\\n\\nMouse events can listen for the `left`, `right`, and `middle` buttons like so:\\n\\n```js\\n@onKey('left', { event='mouseup'})\\ntriggerSubmit() {\\n  ...\\n});\\n```\\n\\nYou can also combine it with the standard modifier keys:\\n\\n```js\\n@onKey('cmd+left', { event='mouseup'})\\ntriggerSubmit() {\\n  ...\\n});\\n```\\n\\n### `event`\\n\\nWhen `ember-keyboard` triggers an event, it passes in the `event` object as its first argument:\\n\\n```js\\n@onKey('ctrl+s')\\nsaveDocument(event) {\\n  this.performSave();\\n  event.preventDefault();\\n}\\n```\\n\\nNote that if you want `preventDefault` to prevent `window` level events, you'll need to use `keydown`,\\nas the default event will fire before `keyup`.\\n\\n### Key Indifference\\n\\nIf you want an event to fire for every keypress, you can use the magic specified `_all`. This can be a\\nhandy way to trigger events for large ranges of keys, such as on any alphanumeric keypress. For instance:\\n\\n```js\\n@onKey('_all')\\ntriggerOnAlphaNumeric(event) {\\n  if (/^\\\\w/.test(event.key)) {\\n    this.startEditing();\\n  }\\n}\\n```\\n\\n### `Ember.TextField` && `Ember.TextArea`\\n\\nTo prevent `ember-keyboard` from responding to keystrokes while an input/textarea/contenteditable is focused,\\nyou can set disableOnInputFields in config/environment.json.\\n\\n```javascript\\nemberKeyboard: {\\n  disableOnInputFields: true\\n},\\n\\n```\\nAlernatively you may use the `on-key` modifier with regular `<input>` and `<textarea>` elements and invoke\\n`ekEvent.stopPropagation()` and/or `ekEvent.stopImmediatePropagation()`.\\nThis ensures that whenever an input is focused, other key responders will not fire.\\n\\n```htmlbars\\n<input {{on-key '/' this.onSlash}} />\\n{{textarea}}\\n```\\n\\n```javascript\\n@action\\nthis.onSlash (event, ekEvent) {\\n  ekEvent.stopPropagation();\\n  ekEvent.stopImmediatePropagation();\\n}\\n```\\n\\n### Unpropagated Key Events\\n\\nSome key events get swallowed by the browser well before they reach `ember-keyboard`. Here is a growing (aka incomplete) list of such events:\\n\\n* Enter: keyUp (keyDown works)\\n* On MacOS\\n  * alt+e\\n  * alt+i\\n  * alt+n\\n  * alt+u\\n  * alt+`\\n  * shift+alt+c\\n  * shift+alt+e\\n  * shift+alt+p\\n\"],null]],[1,\"\\n\"]],[],false,[\"format-markdown\"]]",moduleName:"docs/templates/usage.hbs",isStrictMode:!1})
e.default=n})),define("docs/config/environment",[],(function(){if("undefined"!=typeof FastBoot)return FastBoot.config("docs")
try{var e="docs/config/environment",t=document.querySelector('meta[name="'+e+'"]').getAttribute("content"),n={default:JSON.parse(decodeURIComponent(t))}
return Object.defineProperty(n,"__esModule",{value:!0}),n}catch(o){throw new Error('Could not read config from meta tag with name "'+e+'".')}})),"undefined"==typeof FastBoot&&(runningTests||require("docs/app").default.create({}))
