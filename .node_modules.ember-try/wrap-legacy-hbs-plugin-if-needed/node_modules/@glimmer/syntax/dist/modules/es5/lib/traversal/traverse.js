import visitorKeys from '../types/visitor-keys';
import { cannotRemoveNode, cannotReplaceNode, cannotReplaceOrRemoveInKeyHandlerYet } from './errors';
import { deprecate } from '@glimmer/util';

function getEnterFunction(handler) {
    if (typeof handler === 'function') {
        return handler;
    } else {
        return handler.enter;
    }
}
function getExitFunction(handler) {
    if (typeof handler === 'function') {
        return undefined;
    } else {
        return handler.exit;
    }
}
function getKeyHandler(handler, key) {
    var keyVisitor = typeof handler !== 'function' ? handler.keys : undefined;
    if (keyVisitor === undefined) return;
    var keyHandler = keyVisitor[key];
    if (keyHandler !== undefined) {
        return keyHandler;
    }
    return keyVisitor.All;
}
function getNodeHandler(visitor, nodeType) {
    if (nodeType === 'Template' || nodeType === 'Block') {
        if (visitor.Program) {
            if (false) {
                false && !false && deprecate('TODO');
            }
            return visitor.Program;
        }
    }
    var handler = visitor[nodeType];
    if (handler !== undefined) {
        return handler;
    }
    return visitor.All;
}
function visitNode(visitor, node) {
    var handler = getNodeHandler(visitor, node.type);
    var enter = void 0;
    var exit = void 0;
    if (handler !== undefined) {
        enter = getEnterFunction(handler);
        exit = getExitFunction(handler);
    }
    var result = void 0;
    if (enter !== undefined) {
        result = enter(node);
    }
    if (result !== undefined && result !== null) {
        if (JSON.stringify(node) === JSON.stringify(result)) {
            result = undefined;
        } else if (Array.isArray(result)) {
            visitArray(visitor, result);
            return result;
        } else {
            return visitNode(visitor, result) || result;
        }
    }
    if (result === undefined) {
        var keys = visitorKeys[node.type];
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            // we know if it has child keys we can widen to a ParentNode
            visitKey(visitor, handler, node, key);
        }
        if (exit !== undefined) {
            result = exit(node);
        }
    }
    return result;
}
function get(node, key) {
    return node[key];
}
function set(node, key, value) {
    node[key] = value;
}
function visitKey(visitor, handler, node, key) {
    var value = get(node, key);
    if (!value) {
        return;
    }
    var keyEnter = void 0;
    var keyExit = void 0;
    if (handler !== undefined) {
        var keyHandler = getKeyHandler(handler, key);
        if (keyHandler !== undefined) {
            keyEnter = getEnterFunction(keyHandler);
            keyExit = getExitFunction(keyHandler);
        }
    }
    if (keyEnter !== undefined) {
        if (keyEnter(node, key) !== undefined) {
            throw cannotReplaceOrRemoveInKeyHandlerYet(node, key);
        }
    }
    if (Array.isArray(value)) {
        visitArray(visitor, value);
    } else {
        var result = visitNode(visitor, value);
        if (result !== undefined) {
            // TODO: dynamically check the results by having a table of
            // expected node types in value space, not just type space
            assignKey(node, key, value, result);
        }
    }
    if (keyExit !== undefined) {
        if (keyExit(node, key) !== undefined) {
            throw cannotReplaceOrRemoveInKeyHandlerYet(node, key);
        }
    }
}
function visitArray(visitor, array) {
    for (var i = 0; i < array.length; i++) {
        var result = visitNode(visitor, array[i]);
        if (result !== undefined) {
            i += spliceArray(array, i, result) - 1;
        }
    }
}
function assignKey(node, key, value, result) {
    if (result === null) {
        throw cannotRemoveNode(value, node, key);
    } else if (Array.isArray(result)) {
        if (result.length === 1) {
            set(node, key, result[0]);
        } else {
            if (result.length === 0) {
                throw cannotRemoveNode(value, node, key);
            } else {
                throw cannotReplaceNode(value, node, key);
            }
        }
    } else {
        set(node, key, result);
    }
}
function spliceArray(array, index, result) {
    if (result === null) {
        array.splice(index, 1);
        return 0;
    } else if (Array.isArray(result)) {
        array.splice.apply(array, [index, 1].concat(result));
        return result.length;
    } else {
        array.splice(index, 1, result);
        return 1;
    }
}
export default function traverse(node, visitor) {
    visitNode(visitor, node);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3N5bnRheC9saWIvdHJhdmVyc2FsL3RyYXZlcnNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQUEsV0FBQSxNQUFBLHVCQUFBO0FBQ0EsU0FBQSxnQkFBQSxFQUFBLGlCQUFBLEVBQUEsb0NBQUEsUUFBQSxVQUFBO0FBTUEsU0FBQSxTQUFBLFFBQUEsZUFBQTs7QUFVQSxTQUFBLGdCQUFBLENBQUEsT0FBQSxFQUNnRDtBQUU5QyxRQUFJLE9BQUEsT0FBQSxLQUFKLFVBQUEsRUFBbUM7QUFDakMsZUFBQSxPQUFBO0FBREYsS0FBQSxNQUVPO0FBQ0wsZUFBTyxRQUFQLEtBQUE7QUFDRDtBQUNGO0FBTUQsU0FBQSxlQUFBLENBQUEsT0FBQSxFQUNnRDtBQUU5QyxRQUFJLE9BQUEsT0FBQSxLQUFKLFVBQUEsRUFBbUM7QUFDakMsZUFBQSxTQUFBO0FBREYsS0FBQSxNQUVPO0FBQ0wsZUFBTyxRQUFQLElBQUE7QUFDRDtBQUNGO0FBRUQsU0FBQSxhQUFBLENBQUEsT0FBQSxFQUFBLEdBQUEsRUFFUTtBQUVOLFFBQUksYUFBYSxPQUFBLE9BQUEsS0FBQSxVQUFBLEdBQWdDLFFBQWhDLElBQUEsR0FBakIsU0FBQTtBQUNBLFFBQUksZUFBSixTQUFBLEVBQThCO0FBRTlCLFFBQUksYUFBYSxXQUFqQixHQUFpQixDQUFqQjtBQUNBLFFBQUksZUFBSixTQUFBLEVBQThCO0FBQzVCLGVBQUEsVUFBQTtBQUNEO0FBQ0QsV0FBTyxXQUFQLEdBQUE7QUFDRDtBQU9ELFNBQUEsY0FBQSxDQUFBLE9BQUEsRUFBQSxRQUFBLEVBRXFCO0FBRW5CLFFBQUksYUFBQSxVQUFBLElBQTJCLGFBQS9CLE9BQUEsRUFBcUQ7QUFDbkQsWUFBSSxRQUFKLE9BQUEsRUFBcUI7QUFDbkIsZ0JBQUEsS0FBQSxFQUFhO0FBQUEseUJBQUEsQ0FBQSxLQUFBLElBQUEsaUJBQUE7QUFFWjtBQUVELG1CQUFPLFFBQVAsT0FB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QSxLQUFBLEVBQUEsS0FBQSxFQUFBLE1BQUEsRUFBMkY7QUFDekYsUUFBSSxXQUFKLElBQUEsRUFBcUI7QUFDbkIsY0FBQSxNQUFBLENBQUEsS0FBQSxFQUFBLENBQUE7QUFDQSxlQUFBLENBQUE7QUFGRixLQUFBLE1BR08sSUFBSSxNQUFBLE9BQUEsQ0FBSixNQUFJLENBQUosRUFBMkI7QUFDaEMsY0FBQSxNQUFBLGVBQUEsS0FBQSxFQUFBLENBQUEsU0FBQSxNQUFBO0FBQ0EsZUFBTyxPQUFQLE1BQUE7QUFGSyxLQUFBLE1BR0E7QUFDTCxjQUFBLE1BQUEsQ0FBQSxLQUFBLEVBQUEsQ0FBQSxFQUFBLE1BQUE7QUFDQSxlQUFBLENBQUE7QUFDRDtBQUNGO0FBRUQsZUFBYyxTQUFBLFFBQUEsQ0FBQSxJQUFBLEVBQUEsT0FBQSxFQUF1RDtBQUNuRSxjQUFBLE9BQUEsRUFBQSxJQUFBO0FBQ0QiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdmlzaXRvcktleXMsIHsgVmlzaXRvcktleXMsIFZpc2l0b3JLZXkgfSBmcm9tICcuLi90eXBlcy92aXNpdG9yLWtleXMnO1xuaW1wb3J0IHtcbiAgY2Fubm90UmVtb3ZlTm9kZSxcbiAgY2Fubm90UmVwbGFjZU5vZGUsXG4gIGNhbm5vdFJlcGxhY2VPclJlbW92ZUluS2V5SGFuZGxlcllldCxcbn0gZnJvbSAnLi9lcnJvcnMnO1xuaW1wb3J0ICogYXMgQVNUIGZyb20gJy4uL3R5cGVzL25vZGVzJztcbmltcG9ydCB7IGRlcHJlY2F0ZSB9IGZyb20gJ0BnbGltbWVyL3V0aWwnO1xuaW1wb3J0IHsgREVWTU9ERSB9IGZyb20gJ0BnbGltbWVyL2xvY2FsLWRlYnVnLWZsYWdzJztcbmltcG9ydCB7IE5vZGVIYW5kbGVyLCBOb2RlVmlzaXRvciwgS2V5SGFuZGxlciwgTm9kZVRyYXZlcnNhbCwgS2V5VHJhdmVyc2FsIH0gZnJvbSAnLi92aXNpdG9yJztcblxuZnVuY3Rpb24gZ2V0RW50ZXJGdW5jdGlvbjxOIGV4dGVuZHMgQVNULk5vZGU+KFxuICBoYW5kbGVyOiBOb2RlVHJhdmVyc2FsPE4+XG4pOiBOb2RlSGFuZGxlcjxOPiB8IHVuZGVmaW5lZDtcbmZ1bmN0aW9uIGdldEVudGVyRnVuY3Rpb248TiBleHRlbmRzIEFTVC5Ob2RlLCBLIGV4dGVuZHMgVmlzaXRvcktleTxOPj4oXG4gIGhhbmRsZXI6IEtleVRyYXZlcnNhbDxOLCBLPlxuKTogS2V5SGFuZGxlcjxOLCBLPiB8IHVuZGVmaW5lZDtcbmZ1bmN0aW9uIGdldEVudGVyRnVuY3Rpb248TiBleHRlbmRzIEFTVC5Ob2RlLCBLIGV4dGVuZHMgVmlzaXRvcktleTxOPj4oXG4gIGhhbmRsZXI6IE5vZGVUcmF2ZXJzYWw8Tj4gfCBLZXlUcmF2ZXJzYWw8TiwgSz5cbik6IE5vZGVIYW5kbGVyPE4+IHwgS2V5SGFuZGxlcjxOLCBLPiB8IHVuZGVmaW5lZCB7XG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBoYW5kbGVyO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBoYW5kbGVyLmVudGVyIGFzIE5vZGVIYW5kbGVyPE4+IHwgS2V5SGFuZGxlcjxOLCBLPjtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRFeGl0RnVuY3Rpb248TiBleHRlbmRzIEFTVC5Ob2RlPihoYW5kbGVyOiBOb2RlVHJhdmVyc2FsPE4+KTogTm9kZUhhbmRsZXI8Tj4gfCB1bmRlZmluZWQ7XG5mdW5jdGlvbiBnZXRFeGl0RnVuY3Rpb248TiBleHRlbmRzIEFTVC5Ob2RlLCBLIGV4dGVuZHMgVmlzaXRvcktleTxOPj4oXG4gIGhhbmRsZXI6IEtleVRyYXZlcnNhbDxOLCBLPlxuKTogS2V5SGFuZGxlcjxOLCBLPiB8IHVuZGVmaW5lZDtcbmZ1bmN0aW9uIGdldEV4aXRGdW5jdGlvbjxOIGV4dGVuZHMgQVNULk5vZGUsIEsgZXh0ZW5kcyBWaXNpdG9yS2V5PE4+PihcbiAgaGFuZGxlcjogTm9kZVRyYXZlcnNhbDxOPiB8IEtleVRyYXZlcnNhbDxOLCBLPlxuKTogTm9kZUhhbmRsZXI8Tj4gfCBLZXlIYW5kbGVyPE4sIEs+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gaGFuZGxlci5leGl0IGFzIE5vZGVIYW5kbGVyPE4+IHwgS2V5SGFuZGxlcjxOLCBLPjtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRLZXlIYW5kbGVyPE4gZXh0ZW5kcyBBU1QuTm9kZSwgSyBleHRlbmRzIFZpc2l0b3JLZXk8Tj4+KFxuICBoYW5kbGVyOiBOb2RlVHJhdmVyc2FsPE4+LFxuICBrZXk6IEtcbik6IEtleVRyYXZlcnNhbDxOLCBLPiB8IEtleVRyYXZlcnNhbDxOLCBWaXNpdG9yS2V5PE4+PiB8IHVuZGVmaW5lZCB7XG4gIGxldCBrZXlWaXNpdG9yID0gdHlwZW9mIGhhbmRsZXIgIT09ICdmdW5jdGlvbicgPyBoYW5kbGVyLmtleXMgOiB1bmRlZmluZWQ7XG4gIGlmIChrZXlWaXNpdG9yID09PSB1bmRlZmluZWQpIHJldHVybjtcblxuICBsZXQga2V5SGFuZGxlciA9IGtleVZpc2l0b3Jba2V5XTtcbiAgaWYgKGtleUhhbmRsZXIgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBrZXlIYW5kbGVyIGFzIEtleVRyYXZlcnNhbDxOLCBLPjtcbiAgfVxuICByZXR1cm4ga2V5VmlzaXRvci5BbGw7XG59XG5cbmZ1bmN0aW9uIGdldE5vZGVIYW5kbGVyPE4gZXh0ZW5kcyBBU1QuTm9kZT4oXG4gIHZpc2l0b3I6IE5vZGVWaXNpdG9yLFxuICBub2RlVHlwZTogTlsndHlwZSddXG4pOiBOb2RlVHJhdmVyc2FsPE4+O1xuZnVuY3Rpb24gZ2V0Tm9kZUhhbmRsZXIodmlzaXRvcjogTm9kZVZpc2l0b3IsIG5vZGVUeXBlOiAnQWxsJyk6IE5vZGVUcmF2ZXJzYWw8QVNULk5vZGU+O1xuZnVuY3Rpb24gZ2V0Tm9kZUhhbmRsZXI8TiBleHRlbmRzIEFTVC5Ob2RlPihcbiAgdmlzaXRvcjogTm9kZVZpc2l0b3IsXG4gIG5vZGVUeXBlOiBOWyd0eXBlJ11cbik6IE5vZGVUcmF2ZXJzYWw8Tj4gfCBOb2RlVHJhdmVyc2FsPEFTVC5Ob2RlPiB8IHVuZGVmaW5lZCB7XG4gIGlmIChub2RlVHlwZSA9PT0gJ1RlbXBsYXRlJyB8fCBub2RlVHlwZSA9PT0gJ0Jsb2NrJykge1xuICAgIGlmICh2aXNpdG9yLlByb2dyYW0pIHtcbiAgICAgIGlmIChERVZNT0RFKSB7XG4gICAgICAgIGRlcHJlY2F0ZShgVE9ET2ApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmlzaXRvci5Qcm9ncmFtIGFzIGFueTtcbiAgICB9XG4gIH1cblxuICBsZXQgaGFuZGxlciA9IHZpc2l0b3Jbbm9kZVR5cGVdO1xuICBpZiAoaGFuZGxlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGhhbmRsZXIgYXMgTm9kZVRyYXZlcnNhbDxOPjtcbiAgfVxuICByZXR1cm4gdmlzaXRvci5BbGw7XG59XG5cbmZ1bmN0aW9uIHZpc2l0Tm9kZTxOIGV4dGVuZHMgQVNULk5vZGU+KFxuICB2aXNpdG9yOiBOb2RlVmlzaXRvcixcbiAgbm9kZTogTlxuKTogQVNULk5vZGUgfCBBU1QuTm9kZVtdIHwgdW5kZWZpbmVkIHwgbnVsbCB8IHZvaWQge1xuICBsZXQgaGFuZGxlcjogTm9kZVRyYXZlcnNhbDxOPiA9IGdldE5vZGVIYW5kbGVyKHZpc2l0b3IsIG5vZGUudHlwZSk7XG4gIGxldCBlbnRlcjtcbiAgbGV0IGV4aXQ7XG5cbiAgaWYgKGhhbmRsZXIgIT09IHVuZGVmaW5lZCkge1xuICAgIGVudGVyID0gZ2V0RW50ZXJGdW5jdGlvbihoYW5kbGVyKTtcbiAgICBleGl0ID0gZ2V0RXhpdEZ1bmN0aW9uKGhhbmRsZXIpO1xuICB9XG5cbiAgbGV0IHJlc3VsdDogQVNULk5vZGUgfCBBU1QuTm9kZVtdIHwgdW5kZWZpbmVkIHwgbnVsbCB8IHZvaWQ7XG4gIGlmIChlbnRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmVzdWx0ID0gZW50ZXIobm9kZSk7XG4gIH1cblxuICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQgJiYgcmVzdWx0ICE9PSBudWxsKSB7XG4gICAgaWYgKEpTT04uc3RyaW5naWZ5KG5vZGUpID09PSBKU09OLnN0cmluZ2lmeShyZXN1bHQpKSB7XG4gICAgICByZXN1bHQgPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdCkpIHtcbiAgICAgIHZpc2l0QXJyYXkodmlzaXRvciwgcmVzdWx0KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2aXNpdE5vZGUodmlzaXRvciwgcmVzdWx0KSB8fCByZXN1bHQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGV0IGtleXMgPSB2aXNpdG9yS2V5c1tub2RlLnR5cGVdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQga2V5ID0ga2V5c1tpXSBhcyBWaXNpdG9yS2V5c1tOWyd0eXBlJ11dICYga2V5b2YgTjtcbiAgICAgIC8vIHdlIGtub3cgaWYgaXQgaGFzIGNoaWxkIGtleXMgd2UgY2FuIHdpZGVuIHRvIGEgUGFyZW50Tm9kZVxuICAgICAgdmlzaXRLZXkodmlzaXRvciwgaGFuZGxlciwgbm9kZSBhcyBOLCBrZXkpO1xuICAgIH1cblxuICAgIGlmIChleGl0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlc3VsdCA9IGV4aXQobm9kZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZ2V0PE4gZXh0ZW5kcyBBU1QuTm9kZT4oXG4gIG5vZGU6IE4sXG4gIGtleTogVmlzaXRvcktleXNbTlsndHlwZSddXSAmIGtleW9mIE5cbik6IEFTVC5Ob2RlIHwgQVNULk5vZGVbXSB7XG4gIHJldHVybiAobm9kZVtrZXldIGFzIHVua25vd24pIGFzIEFTVC5Ob2RlIHwgQVNULk5vZGVbXTtcbn1cblxuZnVuY3Rpb24gc2V0PE4gZXh0ZW5kcyBBU1QuTm9kZSwgSyBleHRlbmRzIGtleW9mIE4+KG5vZGU6IE4sIGtleTogSywgdmFsdWU6IE5bS10pOiB2b2lkIHtcbiAgbm9kZVtrZXldID0gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHZpc2l0S2V5PE4gZXh0ZW5kcyBBU1QuTm9kZT4oXG4gIHZpc2l0b3I6IE5vZGVWaXNpdG9yLFxuICBoYW5kbGVyOiBOb2RlVHJhdmVyc2FsPE4+LFxuICBub2RlOiBOLFxuICBrZXk6IFZpc2l0b3JLZXlzW05bJ3R5cGUnXV0gJiBrZXlvZiBOXG4pIHtcbiAgbGV0IHZhbHVlID0gZ2V0KG5vZGUsIGtleSk7XG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBsZXQga2V5RW50ZXI7XG4gIGxldCBrZXlFeGl0O1xuXG4gIGlmIChoYW5kbGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICBsZXQga2V5SGFuZGxlciA9IGdldEtleUhhbmRsZXIoaGFuZGxlciwga2V5KTtcbiAgICBpZiAoa2V5SGFuZGxlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBrZXlFbnRlciA9IGdldEVudGVyRnVuY3Rpb24oa2V5SGFuZGxlcik7XG4gICAgICBrZXlFeGl0ID0gZ2V0RXhpdEZ1bmN0aW9uKGtleUhhbmRsZXIpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChrZXlFbnRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKGtleUVudGVyKG5vZGUsIGtleSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgY2Fubm90UmVwbGFjZU9yUmVtb3ZlSW5LZXlIYW5kbGVyWWV0KG5vZGUsIGtleSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgdmlzaXRBcnJheSh2aXNpdG9yLCB2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgbGV0IHJlc3VsdCA9IHZpc2l0Tm9kZSh2aXNpdG9yLCB2YWx1ZSk7XG4gICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBUT0RPOiBkeW5hbWljYWxseSBjaGVjayB0aGUgcmVzdWx0cyBieSBoYXZpbmcgYSB0YWJsZSBvZlxuICAgICAgLy8gZXhwZWN0ZWQgbm9kZSB0eXBlcyBpbiB2YWx1ZSBzcGFjZSwgbm90IGp1c3QgdHlwZSBzcGFjZVxuICAgICAgYXNzaWduS2V5KG5vZGUsIGtleSwgdmFsdWUsIHJlc3VsdCBhcyBhbnkpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChrZXlFeGl0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoa2V5RXhpdChub2RlLCBrZXkpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IGNhbm5vdFJlcGxhY2VPclJlbW92ZUluS2V5SGFuZGxlcllldChub2RlLCBrZXkpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB2aXNpdEFycmF5KHZpc2l0b3I6IE5vZGVWaXNpdG9yLCBhcnJheTogQVNULk5vZGVbXSkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IHJlc3VsdCA9IHZpc2l0Tm9kZSh2aXNpdG9yLCBhcnJheVtpXSk7XG4gICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpICs9IHNwbGljZUFycmF5KGFycmF5LCBpLCByZXN1bHQpIC0gMTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzaWduS2V5PE4gZXh0ZW5kcyBBU1QuTm9kZSwgSyBleHRlbmRzIFZpc2l0b3JLZXk8Tj4+KFxuICBub2RlOiBOLFxuICBrZXk6IEssXG4gIHZhbHVlOiBBU1QuTm9kZSxcbiAgcmVzdWx0OiBOW0tdIHwgW05bS11dIHwgbnVsbFxuKSB7XG4gIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICB0aHJvdyBjYW5ub3RSZW1vdmVOb2RlKHZhbHVlLCBub2RlLCBrZXkpO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSkge1xuICAgIGlmIChyZXN1bHQubGVuZ3RoID09PSAxKSB7XG4gICAgICBzZXQobm9kZSwga2V5LCByZXN1bHRbMF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocmVzdWx0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBjYW5ub3RSZW1vdmVOb2RlKHZhbHVlLCBub2RlLCBrZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgY2Fubm90UmVwbGFjZU5vZGUodmFsdWUsIG5vZGUsIGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNldChub2RlLCBrZXksIHJlc3VsdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3BsaWNlQXJyYXkoYXJyYXk6IEFTVC5Ob2RlW10sIGluZGV4OiBudW1iZXIsIHJlc3VsdDogQVNULk5vZGUgfCBBU1QuTm9kZVtdIHwgbnVsbCkge1xuICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgYXJyYXkuc3BsaWNlKGluZGV4LCAxKTtcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdCkpIHtcbiAgICBhcnJheS5zcGxpY2UoaW5kZXgsIDEsIC4uLnJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdC5sZW5ndGg7XG4gIH0gZWxzZSB7XG4gICAgYXJyYXkuc3BsaWNlKGluZGV4LCAxLCByZXN1bHQpO1xuICAgIHJldHVybiAxO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRyYXZlcnNlKG5vZGU6IEFTVC5Ob2RlLCB2aXNpdG9yOiBOb2RlVmlzaXRvcikge1xuICB2aXNpdE5vZGUodmlzaXRvciwgbm9kZSk7XG59XG4iXSwic291cmNlUm9vdCI6IiJ9