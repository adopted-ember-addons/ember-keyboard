"use strict";
const AsyncDiskCache = require("async-disk-cache");
const SyncDiskCache = require("sync-disk-cache");
const Dependencies = require("../dependencies");
const Rimraf = require("rimraf");
const process = require("process");
const nativePromise_1 = require("../util/nativePromise");
const assertNever_1 = require("../util/assertNever");
const rimraf = Rimraf.sync;
const PersistentStrategy = {
    init(ctx) {
        // not happy about having to cast through `any` here.
        let constructor = ctx.constructor;
        if (!constructor._persistentCacheKey) {
            constructor._persistentCacheKey = this.cacheKey(ctx);
        }
        this._cache = new AsyncDiskCache(constructor._persistentCacheKey, {
            location: process.env['BROCCOLI_PERSISTENT_FILTER_CACHE_ROOT'],
            compression: 'deflate'
        });
        this._syncCache = new SyncDiskCache(constructor._persistentCacheKey, {
            location: process.env['BROCCOLI_PERSISTENT_FILTER_CACHE_ROOT']
        });
        if (process.env['CLEAR_BROCCOLI_PERSISTENT_FILTER_CACHE'] === 'true') {
            // this._cache.clear is async and can result in race conditions here.
            // TODO: update async-disk-cache to have a synchronous `clearSync` method.
            rimraf(this._cache.root);
            rimraf(this._syncCache.root);
        }
    },
    cacheKey(ctx) {
        return ctx.cacheKey();
    },
    async processString(ctx, contents, relativePath, forceInvalidation, instrumentation) {
        let key = ctx.cacheKeyProcessString(contents, relativePath);
        let cache = this._cache;
        let value;
        let entry = await nativePromise_1.default(cache.get(key));
        if (entry.isCached && !forceInvalidation) {
            instrumentation.persistentCacheHit++;
            value = JSON.parse(entry.value);
        }
        else {
            instrumentation.persistentCachePrime++;
            let result = await ctx.processString(contents, relativePath);
            if (typeof result === 'string') {
                value = { output: result };
            }
            else {
                value = result;
            }
            let stringValue = JSON.stringify(value);
            await nativePromise_1.default(cache.set(key, stringValue));
        }
        let result = await ctx.postProcess(value, relativePath);
        if (result === undefined) {
            assertNever_1.default(result, 'You must return an object from `Filter.prototype.postProcess`.');
        }
        return result.output;
    },
    /**
     * By default initial dependencies are empty.
     * @returns {Dependencies}
     */
    initialDependencies(rootFS, inputEncoding) {
        let result = this._syncCache.get('__dependencies__');
        let dependencies;
        if (result.isCached) {
            let data = JSON.parse(result.value);
            dependencies = Dependencies.deserialize(data, rootFS, inputEncoding);
        }
        else {
            // Dependencies start out empty; they are sealed as if they came from
            // the previous build iteration.
            dependencies = new Dependencies(rootFS, inputEncoding);
            dependencies.seal().captureDependencyState();
        }
        return dependencies;
    },
    /**
     * Seals the dependencies and captures the dependency state.
     * @param dependencies {Dependencies} The dependencies to seal.
     */
    sealDependencies(dependencies) {
        dependencies.seal().captureDependencyState();
        let data = dependencies.serialize();
        this._syncCache.set('__dependencies__', JSON.stringify(data));
    }
};
module.exports = PersistentStrategy;
//# sourceMappingURL=persistent.js.map