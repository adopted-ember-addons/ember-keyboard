import type { InputNode } from 'broccoli-node-api';
import Plugin = require('broccoli-plugin');
import FSTree = require('fs-tree-diff');
import debugGenerator = require('heimdalljs-logger');
import Dependencies = require('./dependencies');
import Processor = require('./processor');
import { ProcessStringResult as ProcessResult } from './strategies/strategy';
import Entry from 'fs-tree-diff/lib/entry';
declare class ApplyPatchesSchema {
    mkdir: number;
    rmdir: number;
    unlink: number;
    change: number;
    create: number;
    other: number;
    processed: number;
    linked: number;
    handleFile: number;
    processString: number;
    processStringTime: number;
    persistentCacheHit: number;
    persistentCachePrime: number;
    handleFileTime: number;
    constructor();
}
interface Options {
    name?: string;
    annotation?: string;
    persist?: boolean;
    extensions?: Array<string>;
    targetExtension?: string;
    inputEncoding?: string;
    outputEncoding?: string;
    async?: boolean;
    dependencyInvalidation?: boolean;
    concurrency?: number;
}
declare abstract class Filter extends Plugin {
    processor: Processor;
    dependencies: Dependencies | null;
    currentTree: FSTree;
    extensions: undefined | Array<string>;
    targetExtension: string | undefined;
    inputEncoding: string | undefined;
    outputEncoding: string | undefined;
    async: boolean;
    dependencyInvalidation: boolean;
    _canProcessCache: object;
    _destFilePathCache: object;
    _needsReset: boolean;
    concurrency: number;
    _outputLinks: Record<string, boolean>;
    _logger: debugGenerator.Logger;
    static shouldPersist(env: typeof process.env, persist: boolean | undefined): boolean;
    constructor(inputTree: InputNode, options: Options);
    build(): Promise<void>;
    _handleFile(relativePath: string, srcDir: string, destDir: string, entry: Entry, outputPath: string, forceInvalidation: boolean, isChange: boolean, stats: ApplyPatchesSchema): Promise<string | Record<"output", string> | undefined>;
    cacheKey(): string;
    baseDir(): string;
    /**
     * @public
     *
     * optionally override this to build a more robust cache key
     * @param  {String} string The contents of a file that is being processed
     * @return {String}        A cache key
     */
    cacheKeyProcessString(string: string, relativePath: string): string;
    canProcessFile(relativePath: string, entry: Entry): boolean;
    isDirectory(relativePath: string, entry: Entry): boolean;
    getDestFilePath(relativePath: string, entry: Entry): string | null;
    processAndCacheFile(srcDir: string, destDir: string, entry: Entry, forceInvalidation: boolean, isChange: boolean, instrumentation: ApplyPatchesSchema): Promise<string | ProcessResult | undefined>;
    processFile(_srcDir: string, _destDir: string, relativePath: string, forceInvalidation: boolean, isChange: boolean, instrumentation: ApplyPatchesSchema, entry: Entry): Promise<string | ProcessResult | undefined>;
    /**
     * @param _contents {string}
     * @param _relativePath {string}
     * @returns {string}
     */
    processString(_contents: string, _relativePath: string): string | ProcessResult | Promise<string | ProcessResult>;
    postProcess(result: ProcessResult, _relativePath: string): ProcessResult | Promise<ProcessResult>;
}
declare namespace Filter {
    type ProcessStringResult<Data = {}> = ProcessResult<Data>;
}
export = Filter;
//# sourceMappingURL=index.d.ts.map