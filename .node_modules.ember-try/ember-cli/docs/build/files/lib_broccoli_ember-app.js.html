<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>lib/broccoli/ember-app.js - ember-cli</title>
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/yui/3.18.0/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div class="yui3-g">
        <div id="sidebar" class="yui3-u">
            <div class="logo">
              <a href="../index.html">
                  <img src="https://ember-cli.com/assets/images/ember-cli-logo-small-dark.png">
              </a>
            </div>
            
            <div id="modules" class="sidebox">
                <div class="hd">
                    <h2 class="no-toc">Modules</h2>
                </div>
                <div class="bd">
                    <ul>
                            <li><a href="../modules/ember-cli.html">ember-cli</a>
                            </li>
                    </ul>
                </div>
            </div>
            
            <div id="classes" class="sidebox">
                <div class="hd">
                    <h2 class="no-toc">Classes</h2>
                </div>
                <div class="bd">
                    <ul>
                            <li><a href="../classes/Addon.html">Addon</a></li>
                            <li><a href="../classes/AmdTransformAddon.html">AmdTransformAddon</a></li>
                            <li><a href="../classes/Blueprint.html">Blueprint</a></li>
                            <li><a href="../classes/Builder.html">Builder</a></li>
                            <li><a href="../classes/CLI.html">CLI</a></li>
                            <li><a href="../classes/Command.html">Command</a></li>
                            <li><a href="../classes/DefaultPackager.html">DefaultPackager</a></li>
                            <li><a href="../classes/EmberAddon.html">EmberAddon</a></li>
                            <li><a href="../classes/EmberApp.html">EmberApp</a></li>
                            <li><a href="../classes/HardwareInfo.html">HardwareInfo</a></li>
                            <li><a href="../classes/HistorySupportAddon.html">HistorySupportAddon</a></li>
                            <li><a href="../classes/Instrumentation.html">Instrumentation</a></li>
                            <li><a href="../classes/NodeModulesList.html">NodeModulesList</a></li>
                            <li><a href="../classes/NpmTask.html">NpmTask</a></li>
                            <li><a href="../classes/PackageInfo.html">PackageInfo</a></li>
                            <li><a href="../classes/PackageInfoCache.html">PackageInfoCache</a></li>
                            <li><a href="../classes/Project.html">Project</a></li>
                            <li><a href="../classes/ServeFilesAddon.html">ServeFilesAddon</a></li>
                            <li><a href="../classes/TestsServerAddon.html">TestsServerAddon</a></li>
                            <li><a href="../classes/WatcherAddon.html">WatcherAddon</a></li>
                            <li><a href="../classes/WindowsSymlinkChecker.html">WindowsSymlinkChecker</a></li>
                    </ul>
                </div>
            </div>
            
            
            
            
            
            <div class="version-info">
              Version: 3.22.0-master-2eaee94140
            </div>
            
        </div>

        <div id="main" class="yui3-u">
            <div class="content"><div class="title">
  <h1 class="file-name">lib/broccoli/ember-app.js</h1>
</div>

<pre class="code prettyprint linenums">
&#x27;use strict&#x27;;

/**
@module ember-cli
*/
const fs = require(&#x27;fs&#x27;);
const path = require(&#x27;path&#x27;);
const p = require(&#x27;ember-cli-preprocess-registry/preprocessors&#x27;);
const chalk = require(&#x27;chalk&#x27;);
const resolve = require(&#x27;resolve&#x27;);

const Project = require(&#x27;../models/project&#x27;);

let preprocessJs = p.preprocessJs;
let isType = p.isType;

let preprocessTemplates = p.preprocessTemplates;

const concat = require(&#x27;broccoli-concat&#x27;);
const BroccoliDebug = require(&#x27;broccoli-debug&#x27;);
const AmdFunnel = require(&#x27;broccoli-amd-funnel&#x27;);
const mergeTrees = require(&#x27;./merge-trees&#x27;);
const WatchedDir = require(&#x27;broccoli-source&#x27;).WatchedDir;
const UnwatchedDir = require(&#x27;broccoli-source&#x27;).UnwatchedDir;
const BroccoliMergeTrees = require(&#x27;broccoli-merge-trees&#x27;);

const merge = require(&#x27;ember-cli-lodash-subset&#x27;).merge;
const defaultsDeep = require(&#x27;ember-cli-lodash-subset&#x27;).defaultsDeep;
const omitBy = require(&#x27;ember-cli-lodash-subset&#x27;).omitBy;
const isNull = require(&#x27;ember-cli-lodash-subset&#x27;).isNull;
const Funnel = require(&#x27;broccoli-funnel&#x27;);
const logger = require(&#x27;heimdalljs-logger&#x27;)(&#x27;ember-cli:ember-app&#x27;);
const addonProcessTree = require(&#x27;../utilities/addon-process-tree&#x27;);
const lintAddonsByType = require(&#x27;../utilities/lint-addons-by-type&#x27;);
const emberCLIBabelConfigKey = require(&#x27;../utilities/ember-cli-babel-config-key&#x27;);
const { isExperimentEnabled } = require(&#x27;../experiments&#x27;);
const semver = require(&#x27;semver&#x27;);
const DefaultPackager = require(&#x27;./default-packager&#x27;);

let DEFAULT_CONFIG = {
  storeConfigInMeta: true,
  autoRun: true,
  outputPaths: {
    app: {
      html: &#x27;index.html&#x27;,
    },
    tests: {
      js: &#x27;/assets/tests.js&#x27;,
    },
    vendor: {
      css: &#x27;/assets/vendor.css&#x27;,
      js: &#x27;/assets/vendor.js&#x27;,
    },
    testSupport: {
      css: &#x27;/assets/test-support.css&#x27;,
      js: {
        testSupport: &#x27;/assets/test-support.js&#x27;,
        testLoader: &#x27;/assets/test-loader.js&#x27;,
      },
    },
  },
  minifyCSS: {
    options: { relativeTo: &#x27;assets&#x27; },
  },
  sourcemaps: {},
  trees: {},
  jshintrc: {},
  addons: {},
};

class EmberApp {
  /**
   EmberApp is the main class Ember CLI uses to manage the Broccoli trees
   for your application. It is very tightly integrated with Broccoli and has
   a &#x60;toTree()&#x60; method you can use to get the entire tree for your application.

   Available init options:
   - storeConfigInMeta, defaults to &#x60;true&#x60;
   - autoRun, defaults to &#x60;true&#x60;
   - outputPaths, defaults to &#x60;{}&#x60;
   - minifyCSS, defaults to &#x60;{enabled: !!isProduction,options: { relativeTo: &#x27;assets&#x27; }}
   - minifyJS, defaults to &#x60;{enabled: !!isProduction}
   - sourcemaps, defaults to &#x60;{}&#x60;
   - trees, defaults to &#x60;{}&#x60;
   - jshintrc, defaults to &#x60;{}&#x60;
   - vendorFiles, defaults to &#x60;{}&#x60;
   - addons, defaults to &#x60;{ blacklist: [], whitelist: [] }&#x60;

   @class EmberApp
   @constructor
   @param {Object} [defaults]
   @param {Object} [options={}] Configuration options
   */
  constructor(defaults, options) {
    if (arguments.length === 0) {
      options = {};
    } else if (arguments.length === 1) {
      options = defaults;
    } else {
      defaultsDeep(options, defaults);
    }

    this._initProject(options);
    this.name = options.name || this.project.name();

    this.env = EmberApp.env();
    this.isProduction = this.env === &#x27;production&#x27;;

    this.registry = options.registry || p.defaultRegistry(this);

    this.bowerDirectory = this.project.bowerDirectory;

    this._initTestsAndHinting(options);
    this._initOptions(options);
    this._initVendorFiles();

    this._styleOutputFiles = {};

    // ensure addon.css always gets concated
    this._styleOutputFiles[this.options.outputPaths.vendor.css] = [];

    this._scriptOutputFiles = {};
    this._customTransformsMap = new Map();

    this.otherAssetPaths = [];
    this.legacyTestFilesToAppend = [];
    this.vendorTestStaticStyles = [];
    this._nodeModules = new Map();

    this.trees = this.options.trees;

    this.populateLegacyFiles();
    this.initializeAddons();
    this.project.addons.forEach((addon) =&gt; (addon.app = this));
    p.setupRegistry(this);
    this._importAddonTransforms();
    this._notifyAddonIncluded();

    this._debugTree = BroccoliDebug.buildDebugCallback(&#x27;ember-app&#x27;);

    this._defaultPackager = new DefaultPackager({
      env: this.env,
      name: this.name,
      autoRun: this.options.autoRun,
      project: this.project,
      registry: this.registry,
      sourcemaps: this.options.sourcemaps,
      minifyCSS: this.options.minifyCSS,
      areTestsEnabled: this.tests,
      styleOutputFiles: this._styleOutputFiles,
      scriptOutputFiles: this._scriptOutputFiles,
      storeConfigInMeta: this.options.storeConfigInMeta,
      customTransformsMap: this._customTransformsMap,
      additionalAssetPaths: this.otherAssetPaths,
      vendorTestStaticStyles: this.vendorTestStaticStyles,
      legacyTestFilesToAppend: this.legacyTestFilesToAppend,
      distPaths: {
        appJsFile: this.options.outputPaths.app.js,
        appCssFile: this.options.outputPaths.app.css,
        testJsFile: this.options.outputPaths.tests.js,
        appHtmlFile: this.options.outputPaths.app.html,
        vendorJsFile: this.options.outputPaths.vendor.js,
        vendorCssFile: this.options.outputPaths.vendor.css,
        testSupportJsFile: this.options.outputPaths.testSupport.js,
        testSupportCssFile: this.options.outputPaths.testSupport.css,
      },
    });

    this._isPackageHookSupplied = typeof this.options.package === &#x27;function&#x27;;
    this._cachedAddonBundles = {};
  }

  /**
    Initializes the &#x60;tests&#x60; and &#x60;hinting&#x60; properties.

    Defaults to &#x60;false&#x60; unless &#x60;ember test&#x60; was used or this is *not* a production build.

    @private
    @method _initTestsAndHinting
    @param {Object} options
  */
  _initTestsAndHinting(options) {
    let testsEnabledDefault = process.env.EMBER_CLI_TEST_COMMAND === &#x27;true&#x27; || !this.isProduction;

    this.tests = &#x27;tests&#x27; in options ? options.tests : testsEnabledDefault;
    this.hinting = &#x27;hinting&#x27; in options ? options.hinting : testsEnabledDefault;
  }

  /**
    Initializes the &#x60;project&#x60; property from &#x60;options.project&#x60; or the
    closest Ember CLI project from the current working directory.

    @private
    @method _initProject
    @param {Object} options
  */
  _initProject(options) {
    let app = this;

    this.project = options.project || Project.closestSync(process.cwd());

    if (options.configPath) {
      this.project.configPath = function () {
        return app._resolveLocal(options.configPath);
      };
      this.project.configCache.clear();
    }
  }

  /**
    Initializes the &#x60;options&#x60; property from the &#x60;options&#x60; parameter and
    a set of default values from Ember CLI.

    @private
    @method _initOptions
    @param {Object} options
  */
  _initOptions(options) {
    let resolvePathFor = (defaultPath, specified) =&gt; {
      let path = defaultPath;
      if (specified &amp;&amp; typeof specified === &#x27;string&#x27;) {
        path = specified;
      }
      let resolvedPath = this._resolveLocal(path);

      return resolvedPath;
    };

    let buildTreeFor = (defaultPath, specified, shouldWatch) =&gt; {
      if (specified !== null &amp;&amp; specified !== undefined &amp;&amp; typeof specified !== &#x27;string&#x27;) {
        return specified;
      }

      let tree = null;
      let resolvedPath = resolvePathFor(defaultPath, specified);
      if (fs.existsSync(resolvedPath)) {
        if (shouldWatch !== false) {
          tree = new WatchedDir(resolvedPath);
        } else {
          tree = new UnwatchedDir(resolvedPath);
        }
      }

      return tree;
    };
    let trees = (options &amp;&amp; options.trees) || {};

    let appTree = buildTreeFor(&#x27;app&#x27;, trees.app);

    let testsPath = typeof trees.tests === &#x27;string&#x27; ? resolvePathFor(&#x27;tests&#x27;, trees.tests) : null;
    let testsTree = buildTreeFor(&#x27;tests&#x27;, trees.tests, options.tests);

    // these are contained within app/ no need to watch again
    // (we should probably have the builder or the watcher dedup though)
    this._stylesPath = resolvePathFor(&#x27;app/styles&#x27;, trees.styles);

    let stylesTree = null;
    if (fs.existsSync(this._stylesPath)) {
      stylesTree = new UnwatchedDir(this._stylesPath);
    }

    let templatesTree = buildTreeFor(&#x27;app/templates&#x27;, trees.templates, false);

    // do not watch bower&#x27;s default directory by default
    let bowerTree = buildTreeFor(this.bowerDirectory, null, !!this.project._watchmanInfo.enabled);

    // Set the flag to make sure:
    //
    // - we do not blow up if there is no bower_components folder
    // - we do not attempt to merge bower and vendor together if they are the
    //   same tree
    this._bowerEnabled = this.bowerDirectory !== &#x27;vendor&#x27; &amp;&amp; fs.existsSync(this.bowerDirectory);

    let vendorTree = buildTreeFor(&#x27;vendor&#x27;, trees.vendor);
    let publicTree = buildTreeFor(&#x27;public&#x27;, trees.public);

    let detectedDefaultOptions = {
      babel: {},
      jshintrc: {
        app: this.project.root,
        tests: testsPath,
      },
      minifyCSS: {
        enabled: this.isProduction,
        options: { processImport: false },
      },
      // TODO: remove this with a deprecation (nothing in the default app/addon setup consumes it)
      minifyJS: {
        enabled: this.isProduction,
        options: {
          compress: {
            // this is adversely affects heuristics for IIFE eval
            // eslint-disable-next-line camelcase
            negate_iife: false,
            // limit sequences because of memory issues during parsing
            sequences: 30,
          },
          output: {
            // no difference in size and much easier to debug
            semicolons: false,
          },
        },
      },
      outputPaths: {
        app: {
          css: {
            app: &#x60;/assets/${this.name}.css&#x60;,
          },
          js: &#x60;/assets/${this.name}.js&#x60;,
        },
      },
      sourcemaps: {
        enabled: !this.isProduction,
        extensions: [&#x27;js&#x27;],
      },
      trees: {
        app: appTree,
        tests: testsTree,
        styles: stylesTree,
        templates: templatesTree,
        bower: bowerTree,
        vendor: vendorTree,
        public: publicTree,
      },
    };

    let emberCLIBabelInstance = this.project.findAddonByName(&#x27;ember-cli-babel&#x27;);
    if (emberCLIBabelInstance) {
      let version = this.project.require(&#x27;ember-cli-babel/package.json&#x27;).version;
      if (semver.lt(version, &#x27;6.0.0-alpha.1&#x27;)) {
        detectedDefaultOptions.babel = {
          modules: &#x27;amdStrict&#x27;,
          moduleIds: true,
          resolveModuleSource: require(&#x27;amd-name-resolver&#x27;).moduleResolve,
        };
      }

      let emberCLIBabelConfigKey = this._emberCLIBabelConfigKey();
      detectedDefaultOptions[emberCLIBabelConfigKey] = detectedDefaultOptions[emberCLIBabelConfigKey] || {};
      detectedDefaultOptions[emberCLIBabelConfigKey].compileModules = true;
    }

    this.options = defaultsDeep(options, detectedDefaultOptions, DEFAULT_CONFIG);

    // For now we must disable Babel sourcemaps due to unforeseen
    // performance regressions.
    if (!(&#x27;sourceMaps&#x27; in this.options.babel)) {
      this.options.babel.sourceMaps = false;
    }

    // Add testem.js to excludes for broccoli-asset-rev.
    // This will allow tests to run against the production builds.
    this.options.fingerprint = this.options.fingerprint || {};
    this.options.fingerprint.exclude = this.options.fingerprint.exclude || [];
    this.options.fingerprint.exclude.push(&#x27;testem&#x27;);
  }

  _emberCLIBabelConfigKey() {
    let emberCLIBabelInstance = this.project.findAddonByName(&#x27;ember-cli-babel&#x27;);

    return emberCLIBabelConfigKey(emberCLIBabelInstance);
  }

  /**
    Resolves a path relative to the project&#x27;s root

    @private
    @method _resolveLocal
  */
  _resolveLocal(to) {
    return path.join(this.project.root, to);
  }

  /**
    @private
    @method _initVendorFiles
  */
  _initVendorFiles() {
    let bowerDeps = this.project.bowerDependencies();
    let ember = this.project.findAddonByName(&#x27;ember-source&#x27;);
    let addonEmberCliShims = this.project.findAddonByName(&#x27;ember-cli-shims&#x27;);
    let bowerEmberCliShims = bowerDeps[&#x27;ember-cli-shims&#x27;];
    let developmentEmber;
    let productionEmber;
    let emberTesting;
    let emberShims = null;

    if (ember) {
      developmentEmber = ember.paths.debug;
      productionEmber = ember.paths.prod;
      emberTesting = ember.paths.testing;
      emberShims = ember.paths.shims;
    } else {
      if (bowerEmberCliShims) {
        emberShims = &#x60;${this.bowerDirectory}/ember-cli-shims/app-shims.js&#x60;;
      }

      // in Ember 1.10 and higher &#x60;ember.js&#x60; is deprecated in favor of
      // the more aptly named &#x60;ember.debug.js&#x60;.
      productionEmber = &#x60;${this.bowerDirectory}/ember/ember.prod.js&#x60;;
      developmentEmber = &#x60;${this.bowerDirectory}/ember/ember.debug.js&#x60;;
      if (!fs.existsSync(this._resolveLocal(developmentEmber))) {
        developmentEmber = &#x60;${this.bowerDirectory}/ember/ember.js&#x60;;
      }
      emberTesting = &#x60;${this.bowerDirectory}/ember/ember-testing.js&#x60;;
    }

    let handlebarsVendorFiles;
    if (&#x27;handlebars&#x27; in bowerDeps) {
      handlebarsVendorFiles = {
        development: &#x60;${this.bowerDirectory}/handlebars/handlebars.js&#x60;,
        production: &#x60;${this.bowerDirectory}/handlebars/handlebars.runtime.js&#x60;,
      };
    } else {
      handlebarsVendorFiles = null;
    }

    this.vendorFiles = omitBy(
      merge(
        {
          &#x27;handlebars.js&#x27;: handlebarsVendorFiles,
          &#x27;ember.js&#x27;: {
            development: developmentEmber,
            production: productionEmber,
          },
          &#x27;ember-testing.js&#x27;: [emberTesting, { type: &#x27;test&#x27; }],
          &#x27;app-shims.js&#x27;: emberShims,
          &#x27;ember-resolver.js&#x27;: [
            &#x60;${this.bowerDirectory}/ember-resolver/dist/modules/ember-resolver.js&#x60;,
            {
              exports: {
                &#x27;ember/resolver&#x27;: [&#x27;default&#x27;],
              },
            },
          ],
        },
        this.options.vendorFiles
      ),
      isNull
    );

    this._addJqueryInLegacyEmber();

    if (this._addonInstalled(&#x27;ember-resolver&#x27;) || !bowerDeps[&#x27;ember-resolver&#x27;]) {
      // if the project is using &#x60;ember-resolver&#x60; as an addon
      // remove it from &#x60;vendorFiles&#x60; (the npm version properly works
      // without &#x60;app.import&#x60;s)
      delete this.vendorFiles[&#x27;ember-resolver.js&#x27;];
    }

    // Warn if ember-cli-shims is not included.
    // certain versions of &#x60;ember-source&#x60; bundle them by default,
    // so we must check if that is the load mechanism of ember
    // before checking &#x60;bower&#x60;.
    let emberCliShimsRequired = this._checkEmberCliBabel(this.project.addons);
    if (!emberShims &amp;&amp; !addonEmberCliShims &amp;&amp; !bowerEmberCliShims &amp;&amp; emberCliShimsRequired) {
      this.project.ui.writeWarnLine(
        &quot;You have not included &#x60;ember-cli-shims&#x60; in your project&#x27;s &#x60;bower.json&#x60; or &#x60;package.json&#x60;. This only works if you provide an alternative yourself and unset &#x60;app.vendorFiles[&#x27;app-shims.js&#x27;]&#x60;.&quot;
      );
    }

    // If ember-testing.js is coming from Bower (not ember-source) and it does not
    // exist, then we remove it from vendor files. This is needed to support versions
    // of Ember older than 1.8.0 (when ember-testing.js was incldued in ember.js itself)
    if (!ember &amp;&amp; this.vendorFiles[&#x27;ember-testing.js&#x27;] &amp;&amp; !fs.existsSync(this.vendorFiles[&#x27;ember-testing.js&#x27;][0])) {
      delete this.vendorFiles[&#x27;ember-testing.js&#x27;];
    }
  }

  _addJqueryInLegacyEmber() {
    if (this.project.findAddonByName(&#x27;@ember/jquery&#x27;)) {
      return;
    }
    let ember = this.project.findAddonByName(&#x27;ember-source&#x27;);
    let jqueryPath;
    if (ember) {
      let optionFeatures = this.project.findAddonByName(&#x27;@ember/optional-features&#x27;);
      if (optionFeatures &amp;&amp; !optionFeatures.isFeatureEnabled(&#x27;jquery-integration&#x27;)) {
        return;
      }
      this.project.ui.writeDeprecateLine(
        &#x27;The integration of jQuery into Ember has been deprecated and will be removed with Ember 4.0. You can either&#x27; +
          &#x27; opt-out of using jQuery, or install the &#x60;@ember/jquery&#x60; addon to provide the jQuery integration. Please&#x27; +
          &#x27; consult the deprecation guide for further details: https://emberjs.com/deprecations/v3.x#toc_jquery-apis&#x27;
      );
      jqueryPath = ember.paths.jquery;
    } else {
      jqueryPath = &#x60;${this.bowerDirectory}/jquery/dist/jquery.js&#x60;;
    }
    this.vendorFiles = merge({ &#x27;jquery.js&#x27;: jqueryPath }, this.vendorFiles);
  }

  /**
    Returns the environment name

    @public
    @static
    @method env
    @return {String} Environment name
   */
  static env() {
    return process.env.EMBER_ENV || &#x27;development&#x27;;
  }

  /**
    Delegates to &#x60;broccoli-concat&#x60; with the &#x60;sourceMapConfig&#x60; option set to &#x60;options.sourcemaps&#x60;.

    @private
    @method _concatFiles
    @param tree
    @param options
    @return
  */
  _concatFiles(tree, options) {
    options.sourceMapConfig = this.options.sourcemaps;

    return concat(tree, options);
  }

  /**
    Checks the result of &#x60;addon.isEnabled()&#x60; if it exists, defaults to &#x60;true&#x60; otherwise.

    @private
    @method _addonEnabled
    @param {Addon} addon
    @return {Boolean}
  */
  _addonEnabled(addon) {
    return !addon.isEnabled || addon.isEnabled();
  }

  /**
    @private
    @method _addonDisabledByBlacklist
    @param {Addon} addon
    @return {Boolean}
  */
  _addonDisabledByBlacklist(addon) {
    let blacklist = this.options.addons.blacklist;
    return !!blacklist &amp;&amp; blacklist.indexOf(addon.name) !== -1;
  }

  /**
    @private
    @method _addonDisabledByWhitelist
    @param {Addon} addon
    @return {Boolean}
  */
  _addonDisabledByWhitelist(addon) {
    let whitelist = this.options.addons.whitelist;
    return !!whitelist &amp;&amp; whitelist.indexOf(addon.name) === -1;
  }

  /**
    @private
    @method _checkEmberCliBabel
    @param {Addons} addons
    @return {Boolean}
  */
  _checkEmberCliBabel(addons, result, roots) {
    addons = addons || [];
    result = result || false;
    roots = roots || {};

    let babelInstance = addons.find((addon) =&gt; addon.name === &#x27;ember-cli-babel&#x27;);
    if (babelInstance) {
      let version = babelInstance.pkg.version;
      if (semver.lt(version, &#x27;6.6.0&#x27;)) {
        result = true;
      }
      if (semver.lt(version, &#x27;6.0.0&#x27;) &amp;&amp; !roots[babelInstance.root]) {
        roots[babelInstance.root] = true;
        this.project.ui.writeDeprecateLine(
          &#x60;ember-cli-babel 5.x has been deprecated. Please upgrade to at least ember-cli-babel 6.6. Version ${version} located: ${babelInstance.root}&#x60;
        );
      }
    }

    return addons.some((addon) =&gt; this._checkEmberCliBabel(addon.addons, result, roots)) || result;
  }

  /**
    Returns whether an addon should be added to the project

    @private
    @method shouldIncludeAddon
    @param {Addon} addon
    @return {Boolean}
  */
  shouldIncludeAddon(addon) {
    if (!this._addonEnabled(addon)) {
      return false;
    }

    return !this._addonDisabledByBlacklist(addon) &amp;&amp; !this._addonDisabledByWhitelist(addon);
  }

  /**
    Calls the included hook on addons.

    @private
    @method _notifyAddonIncluded
  */
  _notifyAddonIncluded() {
    let addonNames = this.project.addons.map((addon) =&gt; addon.name);

    if (this.options.addons.blacklist) {
      this.options.addons.blacklist.forEach((addonName) =&gt; {
        if (addonNames.indexOf(addonName) === -1) {
          throw new Error(&#x60;Addon &quot;${addonName}&quot; defined in blacklist is not found&#x60;);
        }
      });
    }

    if (this.options.addons.whitelist) {
      this.options.addons.whitelist.forEach((addonName) =&gt; {
        if (addonNames.indexOf(addonName) === -1) {
          throw new Error(&#x60;Addon &quot;${addonName}&quot; defined in whitelist is not found&#x60;);
        }
      });
    }

    // the addons must be filtered before the &#x60;included&#x60; hook is called
    // in case an addon caches the project.addons list
    this.project.addons = this.project.addons.filter((addon) =&gt; this.shouldIncludeAddon(addon));

    this.project.addons.forEach((addon) =&gt; {
      if (addon.included) {
        addon.included(this);
      }
    });
  }

  /**
    Calls the importTransforms hook on addons.

    @private
    @method _importAddonTransforms
  */
  _importAddonTransforms() {
    this.project.addons.forEach((addon) =&gt; {
      if (this.shouldIncludeAddon(addon)) {
        if (addon.importTransforms) {
          let transforms = addon.importTransforms();

          if (!transforms) {
            throw new Error(&#x60;Addon &quot;${addon.name}&quot; did not return a transform map from importTransforms function&#x60;);
          }

          Object.keys(transforms).forEach((transformName) =&gt; {
            let transformConfig = {
              files: [],
              options: {},
            };

            // store the transform info
            if (typeof transforms[transformName] === &#x27;object&#x27;) {
              transformConfig[&#x27;callback&#x27;] = transforms[transformName].transform;
              transformConfig[&#x27;processOptions&#x27;] = transforms[transformName].processOptions;
            } else if (typeof transforms[transformName] === &#x27;function&#x27;) {
              transformConfig[&#x27;callback&#x27;] = transforms[transformName];
              transformConfig[&#x27;processOptions&#x27;] = (assetPath, entry, options) =&gt; options;
            } else {
              throw new Error(
                &#x60;Addon &quot;${addon.name}&quot; did not return a callback function correctly for transform &quot;${transformName}&quot;.&#x60;
              );
            }

            if (this._customTransformsMap.has(transformName)) {
              // there is already a transform with a same name, therefore we warn the user
              this.project.ui.writeWarnLine(
                &#x60;Addon &quot;${addon.name}&quot; is defining a transform name: ${transformName} that is already being defined. Using transform from addon: &quot;${addon.name}&quot;.&#x60;
              );
            }

            this._customTransformsMap.set(transformName, transformConfig);
          });
        }
      }
    });
  }

  /**
    Loads and initializes addons for this project.
    Calls initializeAddons on the Project.

    @private
    @method initializeAddons
  */
  initializeAddons() {
    this.project.initializeAddons();
  }

  _addonTreesFor(type) {
    return this.project.addons.reduce((sum, addon) =&gt; {
      if (addon.treeFor) {
        let tree = addon.treeFor(type);
        if (tree &amp;&amp; !mergeTrees.isEmptyTree(tree)) {
          sum.push({
            name: addon.name,
            tree,
            root: addon.root,
          });
        }
      }
      return sum;
    }, []);
  }

  /**
    Returns a list of trees for a given type, returned by all addons.

    @private
    @method addonTreesFor
    @param  {String} type Type of tree
    @return {Array}       List of trees
   */
  addonTreesFor(type) {
    return this._addonTreesFor(type).map((addonBundle) =&gt; addonBundle.tree);
  }

  _getDefaultPluginForType(type) {
    let plugins = this.registry.load(type);
    let defaultsForType = plugins.filter((plugin) =&gt; plugin.isDefaultForType);

    if (defaultsForType.length &gt; 1) {
      throw new Error(
        &#x60;There are multiple preprocessor plugins marked as default for &#x27;${type}&#x27;: ${defaultsForType
          .map((p) =&gt; p.name)
          .join(&#x27;, &#x27;)}&#x60;
      );
    }

    return defaultsForType[0];
  }

  _compileAddonTemplates(tree) {
    let defaultPluginForType = this._getDefaultPluginForType(&#x27;template&#x27;);
    let options = {
      annotation: &#x60;_compileAddonTemplates&#x60;,
      registry: this.registry,
    };

    if (defaultPluginForType) {
      tree = defaultPluginForType.toTree(tree, options);
    } else {
      tree = preprocessTemplates(tree, options);
    }

    return tree;
  }

  _compileAddonJs(tree) {
    let defaultPluginForType = this._getDefaultPluginForType(&#x27;js&#x27;);
    let options = {
      annotation: &#x27;_compileAddonJs&#x27;,
      registry: this.registry,
    };

    if (defaultPluginForType) {
      tree = defaultPluginForType.toTree(tree, options);
    } else {
      tree = preprocessJs(tree, &#x27;/&#x27;, &#x27;/&#x27;, options);
    }

    return tree;
  }

  _compileAddonTree(tree, skipTemplates) {
    if (!skipTemplates) {
      tree = this._compileAddonTemplates(tree);
    }
    tree = this._compileAddonJs(tree);

    return tree;
  }

  _precompileAppJsTree(tree) {
    let emberCLIBabelConfigKey = this._emberCLIBabelConfigKey();

    let original = this.options[emberCLIBabelConfigKey];

    // the app will handle transpilation after it tree-shakes
    // do it here instead of the constructor because
    // ember-data and others do their own compilation in their
    // treeForAddon without calling super
    // they need the original params preserved because they call
    // babel themselves and expect compilation the old way
    this.options[emberCLIBabelConfigKey] = Object.assign({}, original, {
      compileModules: false,
      disablePresetEnv: true,
      disableDebugTooling: true,
      disableEmberModulesAPIPolyfill: true,
    });

    tree = preprocessJs(tree, &#x27;/&#x27;, &#x27;/&#x27;, {
      annotation: &#x60;_precompileAppJsTree&#x60;,
      registry: this.registry,
    });

    // return the original params because there are multiple
    // entrances to preprocessJs
    this.options[emberCLIBabelConfigKey] = original;

    return tree;
  }

  /**
    Runs addon post-processing on a given tree and returns the processed tree.

    This enables addons to do process immediately **after** the preprocessor for a
    given type is run, but before concatenation occurs. If an addon wishes to
    apply a transform before the preprocessors run, they can instead implement the
    preprocessTree hook.

    To utilize this addons implement &#x60;postprocessTree&#x60; hook.

    An example, would be to apply some broccoli transform on all JS files, but
    only after the existing pre-processors have run.

    &#x60;&#x60;&#x60;js
    module.exports = {
      name: &#x27;my-cool-addon&#x27;,
      postprocessTree(type, tree) {
        if (type === &#x27;js&#x27;) {
          return someBroccoliTransform(tree);
        }

        return tree;
      }
    }

    &#x60;&#x60;&#x60;

    @private
    @method addonPostprocessTree
    @param  {String} type Type of tree
    @param  {Tree}   tree Tree to process
    @return {Tree}        Processed tree
   */
  addonPostprocessTree(type, tree) {
    return addonProcessTree(this.project, &#x27;postprocessTree&#x27;, type, tree);
  }

  /**
    Runs addon pre-processing on a given tree and returns the processed tree.

    This enables addons to do process immediately **before** the preprocessor for a
    given type is run.  If an addon wishes to apply a transform  after the
    preprocessors run, they can instead implement the postprocessTree hook.

    To utilize this addons implement &#x60;preprocessTree&#x60; hook.

    An example, would be to remove some set of files before the preprocessors run.

    &#x60;&#x60;&#x60;js
    var stew = require(&#x27;broccoli-stew&#x27;);

    module.exports = {
      name: &#x27;my-cool-addon&#x27;,
      preprocessTree(type, tree) {
        if (type === &#x27;js&#x27; &amp;&amp; type === &#x27;template&#x27;) {
          return stew.rm(tree, someGlobPattern);
        }

        return tree;
      }
    }
    &#x60;&#x60;&#x60;

    @private
    @method addonPreprocessTree
    @param  {String} type Type of tree
    @param  {Tree}   tree Tree to process
    @return {Tree}        Processed tree
   */
  addonPreprocessTree(type, tree) {
    return addonProcessTree(this.project, &#x27;preprocessTree&#x27;, type, tree);
  }

  /**
    Runs addon lintTree hooks and returns a single tree containing all
    their output.

    @private
    @method addonLintTree
    @param  {String} type Type of tree
    @param  {Tree}   tree Tree to process
    @return {Tree}        Processed tree
   */
  addonLintTree(type, tree) {
    let output = lintAddonsByType(this.project.addons, type, tree);

    return mergeTrees(output, {
      overwrite: true,
      annotation: &#x60;TreeMerger (lint ${type})&#x60;,
    });
  }

  /**
    Imports legacy imports in this.vendorFiles

    @private
    @method populateLegacyFiles
  */
  populateLegacyFiles() {
    let name;
    for (name in this.vendorFiles) {
      let args = this.vendorFiles[name];

      if (args === null) {
        continue;
      }

      this.import.apply(this, [].concat(args));
    }
  }

  podTemplates() {
    return new Funnel(this.trees.app, {
      include: this._podTemplatePatterns(),
      exclude: [&#x27;templates/**/*&#x27;],
      destDir: this.name,
      annotation: &#x27;Funnel: Pod Templates&#x27;,
    });
  }

  _templatesTree() {
    if (!this._cachedTemplateTree) {
      let trees = [];
      if (this.trees.templates) {
        let standardTemplates = new Funnel(this.trees.templates, {
          srcDir: &#x27;/&#x27;,
          destDir: &#x60;${this.name}/templates&#x60;,
          annotation: &#x27;Funnel: Templates&#x27;,
        });

        trees.push(standardTemplates);
      }

      if (this.trees.app) {
        trees.push(this.podTemplates());
      }

      this._cachedTemplateTree = mergeTrees(trees, {
        annotation: &#x27;TreeMerge (templates)&#x27;,
      });
    }

    return this._cachedTemplateTree;
  }

  /*
   * Gather application and add-ons javascript files and return them in a single
   * tree.
   *
   * Resulting tree:
   *
   * &#x60;&#x60;&#x60;
   * the-best-app-ever/
   * ├── adapters
   * │   └── application.js
   * ├── app.js
   * ├── components
   * ├── controllers
   * ├── helpers
   * │   ├── and.js
   * │   ├── app-version.js
   * │   ├── await.js
   * │   ├── camelize.js
   * │   ├── cancel-all.js
   * │   ├── dasherize.js
   * │   ├── dec.js
   * │   ├── drop.js
   * │   └── eq.js
   * ...
   * &#x60;&#x60;&#x60;
   *
   * Note, files in the example are &quot;made up&quot; and will differ from the real
   * application.
   *
   * @private
   * @method getAppJavascript
   * @return {BroccoliTree}
   */
  getAppJavascript(isPackageHookSupplied) {
    let appTrees = [].concat(this.addonTreesFor(&#x27;app&#x27;), this.trees.app).filter(Boolean);

    let mergedApp = mergeTrees(appTrees, {
      overwrite: true,
      annotation: &#x27;TreeMerger (app)&#x27;,
    });

    let appTree = new Funnel(mergedApp, {
      srcDir: &#x27;/&#x27;,
      destDir: this.name,
      annotation: &#x27;ProcessedAppTree&#x27;,
    });

    if (isExperimentEnabled(&#x27;PACKAGER&#x27;) &amp;&amp; isPackageHookSupplied) {
      appTree = this._precompileAppJsTree(appTree);
    }

    return appTree;
  }

  /*
   * Gather add-ons style (css/sass/less) files and return them in a single
   * tree.
   *
   * Resulting tree:
   *
   * &#x60;&#x60;&#x60;
   * the-best-app-ever/
   * └── app
   *     └── styles
   *         ├── ember-basic-dropdown.scss
   *         └── ember-power-select.scss
   * &#x60;&#x60;&#x60;
   *
   * @private
   * @method getStyles
   * @return {BroccoliTree}
   */
  getStyles() {
    let styles;
    if (this.trees.styles) {
      styles = new Funnel(this.trees.styles, {
        srcDir: &#x27;/&#x27;,
        destDir: &#x27;/app/styles&#x27;,
        annotation: &#x27;Funnel (styles)&#x27;,
      });
    }
    let addons = this.addonTreesFor(&#x27;styles&#x27;);

    styles = mergeTrees(addons.concat(styles), {
      overwrite: true,
      annotation: &#x27;Styles&#x27;,
    });

    return styles;
  }

  /*
   * Gather add-ons template files and return them in a single tree.
   *
   * Resulting tree:
   *
   * &#x60;&#x60;&#x60;
   * the-best-app-ever/
   * └── templates
   *     ├── application.hbs
   *     ├── error.hbs
   *     ├── index.hbs
   *     └── loading.hbs
   * &#x60;&#x60;&#x60;
   *
   * Note, files in the example are &quot;made up&quot; and will differ from the real
   * application.
   *
   * @private
   * @method getAddonTemplates
   * @return {BroccoliTree}
   */
  getAddonTemplates() {
    let addonTrees = this.addonTreesFor(&#x27;templates&#x27;);
    let mergedTemplates = mergeTrees(addonTrees, {
      overwrite: true,
      annotation: &#x27;TreeMerger (templates)&#x27;,
    });

    let addonTemplates = new Funnel(mergedTemplates, {
      srcDir: &#x27;/&#x27;,
      destDir: &#x60;${this.name}/templates&#x60;,
      annotation: &#x27;ProcessedTemplateTree&#x27;,
    });

    return addonTemplates;
  }

  /**
    @private
    @method _podTemplatePatterns
    @return {Array} An array of regular expressions.
  */
  _podTemplatePatterns() {
    return this.registry.extensionsForType(&#x27;template&#x27;).map((extension) =&gt; &#x60;**/*/template.${extension}&#x60;);
  }

  _nodeModuleTrees() {
    if (!this._cachedNodeModuleTrees) {
      this._cachedNodeModuleTrees = Array.from(
        this._nodeModules.values(),
        (module) =&gt;
          new Funnel(module.path, {
            srcDir: &#x27;/&#x27;,
            destDir: &#x60;node_modules/${module.name}/&#x60;,
            annotation: &#x60;Funnel (node_modules/${module.name})&#x60;,
          })
      );
    }

    return this._cachedNodeModuleTrees;
  }

  _addonBundles(type) {
    if (!this._cachedAddonBundles[type]) {
      let addonBundles = this._addonTreesFor(type);

      this._cachedAddonBundles[type] = addonBundles;
    }

    return this._cachedAddonBundles[type];
  }

  /*
   * @private
   * @method @createAddonTree
   */
  createAddonTree(type, outputDir, options) {
    let addonBundles = this._addonBundles(type, options);

    let tree = mergeTrees(
      addonBundles.map(({ tree }) =&gt; tree),
      {
        overwrite: true,
        annotation: &#x60;TreeMerger (${type})&#x60;,
      }
    );

    return new Funnel(tree, {
      destDir: outputDir,
      annotation: &#x60;Funnel: ${outputDir} ${type}&#x60;,
    });
  }

  addonTree() {
    if (!this._cachedAddonTree) {
      this._cachedAddonTree = this.createAddonTree(&#x27;addon&#x27;, &#x27;addon-tree-output&#x27;);
    }

    return this._cachedAddonTree;
  }

  addonTestSupportTree() {
    if (!this._cachedAddonTestSupportTree) {
      this._cachedAddonTestSupportTree = this.createAddonTree(&#x27;addon-test-support&#x27;, &#x27;addon-test-support&#x27;);
    }

    return this._cachedAddonTestSupportTree;
  }

  /*
   * Gather all dependencies external to &#x60;ember-cli&#x60;, namely:
   *
   * + app &#x60;vendor&#x60; files
   * + add-ons&#x27; &#x60;vendor&#x60; files
   * + bower packages
   * + node modules
   *
   * Resulting tree:
   *
   * &#x60;&#x60;&#x60;
   * /
   * ├── addon-tree-output/
   * ├── bower_components/
   * └── vendor/
   * &#x60;&#x60;&#x60;
   *
   * @private
   * @method getExternalTree
   * @return {BroccoliTree}
   */
  getExternalTree() {
    if (!this._cachedExternalTree) {
      let vendorTrees = this.addonTreesFor(&#x27;vendor&#x27;);

      vendorTrees.push(this.trees.vendor);

      let vendor = this._defaultPackager.packageVendor(
        mergeTrees(vendorTrees, {
          overwrite: true,
          annotation: &#x27;TreeMerger (vendor)&#x27;,
        })
      );

      let addons = this.addonTree();

      let trees = [vendor].concat(addons);
      if (this._bowerEnabled) {
        let bower = this._defaultPackager.packageBower(this.trees.bower, this.bowerDirectory);

        trees.push(bower);
      }

      trees = this._nodeModuleTrees().concat(trees);

      this._cachedExternalTree = mergeTrees(trees, {
        annotation: &#x27;TreeMerger (ExternalTree)&#x27;,
        overwrite: true,
      });
    }

    return this._cachedExternalTree;
  }

  /*
   * Gather all tests under &#x60;tests&#x60; folder.
   *
   * Resulting tree:
   *
   * &#x60;&#x60;&#x60;
   * /
   * └── tests/
   *     ├── acceptance/
   *     ├── addon-test-support/
   *     ├── helpers/
   *     ├── integration/
   *     ├── lint/
   *     ├── unit/
   *     ├── index.html
   *     └── test-helper.js
   * &#x60;&#x60;&#x60;
   *
   * @private
   * @method getTests
   * @return {BroccoliTree}
   */
  getTests() {
    let addonTrees = this.addonTreesFor(&#x27;test-support&#x27;);

    if (this.hinting) {
      addonTrees.push(this.getLintTests());
    }

    let addonTestSupportFiles = this.addonTestSupportTree();
    let allTests = mergeTrees(addonTrees.concat(this.trees.tests, addonTestSupportFiles), {
      overwrite: true,
      annotation: &#x27;TreeMerger (tests)&#x27;,
    });

    return new Funnel(allTests, {
      destDir: &#x27;tests&#x27;,
    });
  }

  /*
   * Merges both application and add-ons public files and returns them in a
   * single tree.
   *
   * Given a tree:
   *
   * &#x60;&#x60;&#x60;
   * ├── 500.html
   * ├── images
   * ├── maintenance.html
   * └── robots.txt
   * &#x60;&#x60;&#x60;
   *
   * And add-on tree:
   *
   * &#x60;&#x60;&#x60;
   * ember-fetch/
   * └── fastboot-fetch.js
   * &#x60;&#x60;&#x60;
   *
   * Returns:
   *
   * &#x60;&#x60;&#x60;
   * ├── 500.html
   * ├── ember-fetch
   * │   └── fastboot-fetch.js
   * ├── images
   * ├── maintenance.html
   * └── robots.txt
   * &#x60;&#x60;&#x60;
   *
   * @private
   * @method getPublic
   * @return {BroccoliTree}
   */
  getPublic() {
    let addonPublicTrees = this.addonTreesFor(&#x27;public&#x27;);
    addonPublicTrees = addonPublicTrees.concat(this.trees.public);

    let mergedPublicTrees = mergeTrees(addonPublicTrees, {
      annotation: &#x27;Public&#x27;,
      overwrite: true,
    });

    return new Funnel(mergedPublicTrees, {
      destDir: &#x27;public&#x27;,
    });
  }

  /**
    Runs the &#x60;app&#x60;, &#x60;tests&#x60; and &#x60;templates&#x60; trees through the chain of addons that produces lint trees.

    Those lint trees are afterwards funneled into the &#x60;tests&#x60; folder, babel-ified and returned as an array.

    @private
    @method getLintTests
    @return {Array}
   */
  getLintTests() {
    let lintTrees = [];

    if (this.trees.app) {
      let lintedApp = this.addonLintTree(&#x27;app&#x27;, this.trees.app);
      lintedApp = new Funnel(lintedApp, {
        destDir: &#x27;lint&#x27;,
        annotation: &#x27;Funnel (lint app)&#x27;,
      });

      lintTrees.push(lintedApp);
    }

    let lintedTests = this.addonLintTree(&#x27;tests&#x27;, this.trees.tests);
    let lintedTemplates = this.addonLintTree(&#x27;templates&#x27;, this._templatesTree());

    lintedTests = new Funnel(lintedTests, {
      destDir: &#x27;lint&#x27;,
      annotation: &#x27;Funnel (lint tests)&#x27;,
    });

    lintedTemplates = new Funnel(lintedTemplates, {
      destDir: &#x27;lint&#x27;,
      annotation: &#x27;Funnel (lint templates)&#x27;,
    });

    return mergeTrees([lintedTests, lintedTemplates].concat(lintTrees), {
      overwrite: true,
    });
  }

  /**
   * @private
   * @method _addonInstalled
   * @param  {String} addonName The name of the addon we are checking to see if it&#x27;s installed
   * @return {Boolean}
   */
  _addonInstalled(addonName) {
    return !!this.registry.availablePlugins[addonName];
  }

  /**
    @public
    @method dependencies
    @return {Object} Alias to the project&#x27;s dependencies function
  */
  dependencies(pkg) {
    return this.project.dependencies(pkg);
  }

  /**
    Imports an asset into the application.

    @public
    @method import
    @param {Object|String} asset Either a path to the asset or an object with environment names and paths as key-value pairs.
    @param {Object} [options] Options object
    @param {String} [options.type=&#x27;vendor&#x27;] Either &#x27;vendor&#x27; or &#x27;test&#x27;
    @param {Boolean} [options.prepend=false] Whether or not this asset should be prepended
    @param {String} [options.destDir] Destination directory, defaults to the name of the directory the asset is in
    @param {String} [options.outputFile] Specifies the output file for given import. Defaults to assets/vendor.{js,css}
    @param {Array} [options.using] Specifies the array of transformations to be done on the asset. Can do an amd shim and/or custom transformation
    */
  import(asset, options) {
    let assetPath = this._getAssetPath(asset);

    if (!assetPath) {
      return;
    }

    options = defaultsDeep(options || {}, {
      type: &#x27;vendor&#x27;,
      prepend: false,
    });

    let match = assetPath.match(/^node_modules\/((@[^/]+\/)?[^/]+)\//);
    if (match !== null) {
      let basedir = options.resolveFrom || this.project.root;
      let name = match[1];
      let _path = path.dirname(resolve.sync(&#x60;${name}/package.json&#x60;, { basedir }));
      this._nodeModules.set(_path, { name, path: _path });
    }

    let directory = path.dirname(assetPath);
    let subdirectory = directory.replace(new RegExp(&#x60;^vendor/|${this.bowerDirectory}|node_modules/&#x60;), &#x27;&#x27;);
    let extension = path.extname(assetPath);

    if (!extension) {
      throw new Error(
        &#x27;You must pass a file to &#x60;app.import&#x60;. For directories specify them to the constructor under the &#x60;trees&#x60; option.&#x27;
      );
    }

    this._import(assetPath, options, directory, subdirectory, extension);
  }

  /**
    @private
    @method _import
    @param {String} assetPath
    @param {Object} options
    @param {String} directory
    @param {String} subdirectory
    @param {String} extension
   */
  _import(assetPath, options, directory, subdirectory, extension) {
    // TODO: refactor, this has gotten very messy. Relevant tests: tests/unit/broccoli/ember-app-test.js
    let basename = path.basename(assetPath);

    if (isType(assetPath, &#x27;js&#x27;, { registry: this.registry })) {
      if (options.using) {
        if (!Array.isArray(options.using)) {
          throw new Error(&#x27;You must pass an array of transformations for &#x60;using&#x60; option&#x27;);
        }
        options.using.forEach((entry) =&gt; {
          if (!entry.transformation) {
            throw new Error(
              &#x60;while importing ${assetPath}: each entry in the \&#x60;using\&#x60; list must have a \&#x60;transformation\&#x60; name&#x60;
            );
          }

          let transformName = entry.transformation;

          if (!this._customTransformsMap.has(transformName)) {
            let availableTransformNames = Array.from(this._customTransformsMap.keys()).join(&#x27;,&#x27;);
            throw new Error(
              &#x60;while import ${assetPath}: found an unknown transformation name ${transformName}. Available transformNames are: ${availableTransformNames}&#x60;
            );
          }

          // process options for the transform and update the options
          let customTransforms = this._customTransformsMap.get(transformName);
          customTransforms.options = customTransforms.processOptions(assetPath, entry, customTransforms.options);
          customTransforms.files.push(assetPath);
        });
      }

      if (options.type === &#x27;vendor&#x27;) {
        options.outputFile = options.outputFile || this.options.outputPaths.vendor.js;
        addOutputFile(&#x27;firstOneWins&#x27;, this._scriptOutputFiles, assetPath, options);
      } else if (options.type === &#x27;test&#x27;) {
        if (!allowImport(&#x27;firstOneWins&#x27;, this.legacyTestFilesToAppend, assetPath, options)) {
          return;
        }
        if (options.prepend) {
          this.legacyTestFilesToAppend.unshift(assetPath);
        } else {
          this.legacyTestFilesToAppend.push(assetPath);
        }
      } else {
        throw new Error(
          &#x60;You must pass either \&#x60;vendor\&#x60; or \&#x60;test\&#x60; for options.type in your call to \&#x60;app.import\&#x60; for file: ${basename}&#x60;
        );
      }
    } else if (extension === &#x27;.css&#x27;) {
      if (options.type === &#x27;vendor&#x27;) {
        options.outputFile = options.outputFile || this.options.outputPaths.vendor.css;
        addOutputFile(&#x27;lastOneWins&#x27;, this._styleOutputFiles, assetPath, options);
      } else {
        if (!allowImport(&#x27;lastOneWins&#x27;, this.vendorTestStaticStyles, assetPath, options)) {
          return;
        }
        if (options.prepend) {
          this.vendorTestStaticStyles.unshift(assetPath);
        } else {
          this.vendorTestStaticStyles.push(assetPath);
        }
      }
    } else {
      let destDir = options.destDir;
      if (destDir === &#x27;&#x27;) {
        destDir = &#x27;/&#x27;;
      }
      this.otherAssetPaths.push({
        src: directory,
        file: basename,
        dest: destDir || subdirectory,
      });
    }
  }

  /**
    @private
    @method _getAssetPath
    @param {(Object|String)} asset
    @return {(String|undefined)} assetPath
   */
  _getAssetPath(asset) {
    /* @type {String} */
    let assetPath;

    if (typeof asset !== &#x27;object&#x27;) {
      assetPath = asset;
    } else if (this.env in asset) {
      assetPath = asset[this.env];
    } else {
      assetPath = asset.development;
    }

    if (!assetPath) {
      return;
    }

    assetPath = assetPath.split(&#x27;\\&#x27;).join(&#x27;/&#x27;);

    if (assetPath.split(&#x27;/&#x27;).length &lt; 2) {
      console.log(
        chalk.red(
          &#x60;Using \&#x60;app.import\&#x60; with a file in the root of \&#x60;vendor/\&#x60; causes a significant performance penalty. Please move \&#x60;${assetPath}\&#x60; into a subdirectory.&#x60;
        )
      );
    }

    if (/[*,]/.test(assetPath)) {
      throw new Error(
        &#x60;You must pass a file path (without glob pattern) to \&#x60;app.import\&#x60;.  path was: \&#x60;${assetPath}\&#x60;&#x60;
      );
    }

    return assetPath;
  }

  /**
    Returns an array of trees for this application

    @private
    @method toArray
    @return {Array} An array of trees
   */
  toArray() {
    return [
      this.getAddonTemplates(),
      this.getStyles(),
      this.getTests(),
      this.getExternalTree(),
      this.getPublic(),
      this.getAppJavascript(this._isPackageHookSupplied),
    ].filter(Boolean);
  }

  _legacyAddonCompile(type, outputDir, _options) {
    let options = Object.assign(
      {
        // moduleNormalizerDisabled: this.options.moduleNormalizerDisabled,
        amdFunnelDisabled: this.options.amdFunnelDisabled,
        skipTemplates: false,
      },
      _options
    );

    let addonBundles = this._cachedAddonBundles[type];

    let addonTrees = addonBundles.map((addonBundle) =&gt; {
      let { name, tree, root } = addonBundle;

      let precompiledSource = tree;

      if (!options.amdFunnelDisabled) {
        // don&#x27;t want to double compile the AMD modules
        let hasAlreadyPrintedAmdDeprecation;
        precompiledSource = new AmdFunnel(precompiledSource, {
          callback: () =&gt; {
            if (!hasAlreadyPrintedAmdDeprecation) {
              this.project.ui.writeDeprecateLine(
                &#x60;Addon &quot;${name}&quot; (found at &quot;${root}&quot;) is manually generating AMD modules. Code should be ES6 modules only. Support for this will be removed in a future version.&#x60;
              );
              hasAlreadyPrintedAmdDeprecation = true;
            }
          },
          annotation: &#x60;AmdFunnel (${type} ${name})&#x60;,
        });
      }

      return [tree, precompiledSource];
    });

    let precompiledSource = addonTrees.map((pair) =&gt; pair[1]);
    addonTrees = addonTrees.map((pair) =&gt; pair[0]);

    precompiledSource = mergeTrees(precompiledSource, {
      overwrite: true,
      annotation: &#x60;TreeMerger (${type})&#x60;,
    });

    precompiledSource = this._debugTree(precompiledSource, &#x60;precompiledAddonTree:${type}&#x60;);

    let compiledSource = this._compileAddonTree(precompiledSource, options.skipTemplates);

    compiledSource = this._debugTree(compiledSource, &#x60;postcompiledAddonTree:${type}&#x60;);

    let combinedAddonTree;

    if (options.amdFunnelDisabled) {
      combinedAddonTree = compiledSource;
    } else {
      combinedAddonTree = mergeTrees(addonTrees.concat(compiledSource), {
        overwrite: true,
        annotation: &#x60;AmdFunnel TreeMerger (${type})&#x60;,
      });
    }

    return new Funnel(combinedAddonTree, {
      destDir: outputDir,
      annotation: &#x60;Funnel: ${outputDir} ${type}&#x60;,
    });
  }

  _legacyPackage(fullTree) {
    let javascriptTree = this._defaultPackager.packageJavascript(fullTree);
    let stylesTree = this._defaultPackager.packageStyles(fullTree);
    let appIndex = this._defaultPackager.processIndex(fullTree);
    let additionalAssets = this._defaultPackager.importAdditionalAssets(fullTree);
    let publicTree = this._defaultPackager.packagePublic(fullTree);

    let sourceTrees = [appIndex, javascriptTree, stylesTree, additionalAssets, publicTree].filter(Boolean);

    if (this.tests &amp;&amp; this.trees.tests) {
      sourceTrees.push(this._defaultPackager.packageTests(fullTree));
    }

    return mergeTrees(sourceTrees, {
      overwrite: true,
      annotation: &#x27;Application Dist&#x27;,
    });
  }

  /**
    Returns the merged tree for this application

    @public
    @method toTree
    @param  {Array} [additionalTrees] Array of additional trees to merge
    @return {Tree}                  Merged tree for this application
   */
  toTree(additionalTrees) {
    let packagedTree;
    let packageFn = this.options.package;

    let fullTree = mergeTrees(this.toArray(), {
      overwrite: true,
      annotation: &#x27;Full Application&#x27;,
    });

    fullTree = this._debugTree(fullTree, &#x27;prepackage&#x27;);

    if (isExperimentEnabled(&#x27;PACKAGER&#x27;)) {
      if (this._isPackageHookSupplied) {
        packagedTree = packageFn.call(this, fullTree);
      } else {
        this.project.ui.writeWarnLine(&#x27;&#x60;package&#x60; hook must be a function, falling back to default packaging.&#x27;);
      }
    }

    if (!packagedTree) {
      packagedTree = this._legacyPackage(fullTree);
    }

    let trees = [].concat(packagedTree, additionalTrees).filter(Boolean);
    let combinedPackageTree = new BroccoliMergeTrees(trees);

    return this.addonPostprocessTree(&#x27;all&#x27;, combinedPackageTree);
  }
}

module.exports = EmberApp;

function addOutputFile(strategy, container, assetPath, options) {
  let outputFile = options.outputFile;

  if (!outputFile) {
    throw new Error(&#x27;outputFile is not specified&#x27;);
  }

  if (!container[outputFile]) {
    container[outputFile] = [];
  }
  if (!allowImport(strategy, container[outputFile], assetPath, options)) {
    return;
  }

  if (options.prepend) {
    container[outputFile].unshift(assetPath);
  } else {
    container[outputFile].push(assetPath);
  }
}

// In this strategy the last instance of the asset in the array is the one which will be used.
// This applies to CSS where the last asset always &quot;wins&quot; no matter what.
function _lastOneWins(fileList, assetPath, options) {
  let assetIndex = fileList.indexOf(assetPath);

  // Doesn&#x27;t exist in the current fileList. Safe to remove.
  if (assetIndex === -1) {
    return true;
  }

  logger.info(&#x60;Highlander Rule: duplicate \&#x60;app.import(${assetPath})\&#x60;. Only including the last by order.&#x60;);

  if (options.prepend) {
    // The existing asset is _already after_ this inclusion and would win.
    // Therefore this branch is a no-op.
    return false;
  } else {
    // The existing asset is _before_ this inclusion and needs to be removed.
    fileList.splice(fileList.indexOf(assetPath), 1);
    return true;
  }
}

// In JS the asset which would be first will win.
// If it is something which includes globals we want those defined as early as
// possible. Any initialization would likely be repeated. Any mutation of global
// state that occurs on initialization is likely _fixed_.
// Any module definitions will be identical except in the scenario where they&#x27;red
// reified to reassignment. This is likely fine.
function _firstOneWins(fileList, assetPath, options) {
  let assetIndex = fileList.indexOf(assetPath);

  // Doesn&#x27;t exist in the current fileList. Safe to remove.
  if (assetIndex === -1) {
    return true;
  }

  logger.info(&#x60;Highlander Rule: duplicate \&#x60;app.import(${assetPath})\&#x60;. Only including the first by order.&#x60;);

  if (options.prepend) {
    // The existing asset is _after_ this inclusion and needs to be removed.
    fileList.splice(fileList.indexOf(assetPath), 1);
    return true;
  } else {
    // The existing asset is _already before_ this inclusion and would win.
    // Therefore this branch is a no-op.
    return false;
  }
}

function allowImport(strategy, fileList, assetPath, options) {
  if (strategy === &#x27;firstOneWins&#x27;) {
    // We must find all occurrences and decide what to do with each.
    return _firstOneWins.call(undefined, fileList, assetPath, options);
  } else if (strategy === &#x27;lastOneWins&#x27;) {
    // We can simply use the &quot;last one wins&quot; strategy.
    return _lastOneWins.call(undefined, fileList, assetPath, options);
  } else {
    return true;
  }
}

</pre>

</div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
</body>
</html>
