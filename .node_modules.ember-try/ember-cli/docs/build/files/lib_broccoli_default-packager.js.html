<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>lib/broccoli/default-packager.js - ember-cli</title>
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/yui/3.18.0/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div class="yui3-g">
        <div id="sidebar" class="yui3-u">
            <div class="logo">
              <a href="../index.html">
                  <img src="https://ember-cli.com/assets/images/ember-cli-logo-small-dark.png">
              </a>
            </div>
            
            <div id="modules" class="sidebox">
                <div class="hd">
                    <h2 class="no-toc">Modules</h2>
                </div>
                <div class="bd">
                    <ul>
                            <li><a href="../modules/ember-cli.html">ember-cli</a>
                            </li>
                    </ul>
                </div>
            </div>
            
            <div id="classes" class="sidebox">
                <div class="hd">
                    <h2 class="no-toc">Classes</h2>
                </div>
                <div class="bd">
                    <ul>
                            <li><a href="../classes/Addon.html">Addon</a></li>
                            <li><a href="../classes/AmdTransformAddon.html">AmdTransformAddon</a></li>
                            <li><a href="../classes/Blueprint.html">Blueprint</a></li>
                            <li><a href="../classes/Builder.html">Builder</a></li>
                            <li><a href="../classes/CLI.html">CLI</a></li>
                            <li><a href="../classes/Command.html">Command</a></li>
                            <li><a href="../classes/DefaultPackager.html">DefaultPackager</a></li>
                            <li><a href="../classes/EmberAddon.html">EmberAddon</a></li>
                            <li><a href="../classes/EmberApp.html">EmberApp</a></li>
                            <li><a href="../classes/HardwareInfo.html">HardwareInfo</a></li>
                            <li><a href="../classes/HistorySupportAddon.html">HistorySupportAddon</a></li>
                            <li><a href="../classes/Instrumentation.html">Instrumentation</a></li>
                            <li><a href="../classes/NodeModulesList.html">NodeModulesList</a></li>
                            <li><a href="../classes/NpmTask.html">NpmTask</a></li>
                            <li><a href="../classes/PackageInfo.html">PackageInfo</a></li>
                            <li><a href="../classes/PackageInfoCache.html">PackageInfoCache</a></li>
                            <li><a href="../classes/Project.html">Project</a></li>
                            <li><a href="../classes/ServeFilesAddon.html">ServeFilesAddon</a></li>
                            <li><a href="../classes/TestsServerAddon.html">TestsServerAddon</a></li>
                            <li><a href="../classes/WatcherAddon.html">WatcherAddon</a></li>
                            <li><a href="../classes/WindowsSymlinkChecker.html">WindowsSymlinkChecker</a></li>
                    </ul>
                </div>
            </div>
            
            
            
            
            
            <div class="version-info">
              Version: 3.22.0-master-2eaee94140
            </div>
            
        </div>

        <div id="main" class="yui3-u">
            <div class="content"><div class="title">
  <h1 class="file-name">lib/broccoli/default-packager.js</h1>
</div>

<pre class="code prettyprint linenums">
&#x27;use strict&#x27;;

const p = require(&#x27;ember-cli-preprocess-registry/preprocessors&#x27;);
const path = require(&#x27;path&#x27;);
const concat = require(&#x27;broccoli-concat&#x27;);
const Funnel = require(&#x27;broccoli-funnel&#x27;);
const BroccoliDebug = require(&#x27;broccoli-debug&#x27;);
const mergeTrees = require(&#x27;./merge-trees&#x27;);
const ConfigLoader = require(&#x27;broccoli-config-loader&#x27;);
const UnwatchedDir = require(&#x27;broccoli-source&#x27;).UnwatchedDir;
const ConfigReplace = require(&#x27;broccoli-config-replace&#x27;);
const emberAppUtils = require(&#x27;../utilities/ember-app-utils&#x27;);
const funnelReducer = require(&#x27;broccoli-funnel-reducer&#x27;);
const addonProcessTree = require(&#x27;../utilities/addon-process-tree&#x27;);

const preprocessCss = p.preprocessCss;
const preprocessJs = p.preprocessJs;
const preprocessTemplates = p.preprocessTemplates;
const preprocessMinifyCss = p.preprocessMinifyCss;

const DEFAULT_BOWER_PATH = &#x27;bower_components&#x27;;
const DEFAULT_VENDOR_PATH = &#x27;vendor&#x27;;
const EMBER_CLI_INTERNAL_FILES_PATH = &#x27;/vendor/ember-cli/&#x27;;
const EMBER_CLI_FILES = [
  &#x27;app-boot.js&#x27;,
  &#x27;app-config.js&#x27;,
  &#x27;app-prefix.js&#x27;,
  &#x27;app-suffix.js&#x27;,
  &#x27;test-support-prefix.js&#x27;,
  &#x27;test-support-suffix.js&#x27;,
  &#x27;tests-prefix.js&#x27;,
  &#x27;tests-suffix.js&#x27;,
  &#x27;vendor-prefix.js&#x27;,
  &#x27;vendor-suffix.js&#x27;,
];

const configReplacePatterns = emberAppUtils.configReplacePatterns;

function callAddonsPreprocessTreeHook(project, type, tree) {
  return addonProcessTree(project, &#x27;preprocessTree&#x27;, type, tree);
}

function callAddonsPostprocessTreeHook(project, type, tree) {
  return addonProcessTree(project, &#x27;postprocessTree&#x27;, type, tree);
}

/*
  Creates an object with lists of files to be concatenated into &#x60;vendor.js&#x60; file.

  Given a map that looks like:

  &#x60;&#x60;&#x60;
  {
    &#x27;assets/vendor.js&#x27;: [
      &#x27;vendor/ember-cli-shims/app-shims.js&#x27;,
      &#x27;vendor/loader/loader.js&#x27;,
      &#x27;vendor/ember-resolver/legacy-shims.js&#x27;,
      ...
    ]
  }
  &#x60;&#x60;&#x60;

  Produces an object that looks like:

  &#x60;&#x60;&#x60;
  {
    headerFiles: [
     &#x27;vendor/ember-cli/vendor-prefix.js&#x27;,
     &#x27;vendor/loader/loader.js&#x27;,
     &#x27;vendor/ember/jquery/jquery.js&#x27;,
     &#x27;vendor/ember/ember.debug.js&#x27;,
     &#x27;vendor/ember-cli-shims/app-shims.js&#x27;,
     &#x27;vendor/ember-resolver/legacy-shims.js&#x27;
    ],
    inputFiles: [
      &#x27;addon-tree-output/**\/*.js&#x27;
    ],
    footerFiles: [
      &#x27;vendor/ember-cli/vendor-suffix.js&#x27;
    ],
    annotation: &#x27;Vendor JS&#x27;
  }
  &#x60;&#x60;&#x60;

  @private
  @method getVendorFiles
  @param {Object} files A list of files to include into &#x60;&lt;file-name&gt;.js&#x60;
  @param {Boolean} isMainVendorFile Boolean flag to indicate if we are dealing with &#x60;vendor.js&#x60; file
  @return {Object} An object with lists of files to be concatenated into &#x60;vendor.js&#x60; file.
 */
function getVendorFiles(files, isMainVendorFile) {
  return {
    headerFiles: files,
    inputFiles: isMainVendorFile ? [&#x27;addon-tree-output/**/*.js&#x27;] : [],
    footerFiles: isMainVendorFile ? [&#x27;vendor/ember-cli/vendor-suffix.js&#x27;] : [],
  };
}

/**
 * Responsible for packaging Ember.js application.
 *
 * @class DefaultPackager
 * @constructor
 */
module.exports = class DefaultPackager {
  constructor(options) {
    this._cachedTests = null;
    this._cachedBower = null;
    this._cachedVendor = null;
    this._cachedPublic = null;
    this._cachedConfig = null;
    this._cachedJavascript = null;
    this._cachedProcessedIndex = null;
    this._cachedTransformedTree = null;
    this._cachedProcessedStyles = null;
    this._cachedProcessedTemplates = null;
    this._cachedProcessedJavascript = null;
    this._cachedEmberCliInternalTree = null;
    this._cachedProcessedAdditionalAssets = null;
    this._cachedProcessedAppAndDependencies = null;

    this.options = options || {};

    this._debugTree = BroccoliDebug.buildDebugCallback(&#x27;default-packager&#x27;);

    this.env = this.options.env;
    this.name = this.options.name;
    this.autoRun = this.options.autoRun;
    this.project = this.options.project;
    this.registry = this.options.registry;
    this.sourcemaps = this.options.sourcemaps;
    this.minifyCSS = this.options.minifyCSS;
    this.distPaths = this.options.distPaths;
    this.areTestsEnabled = this.options.areTestsEnabled;
    this.styleOutputFiles = this.options.styleOutputFiles;
    this.scriptOutputFiles = this.options.scriptOutputFiles;
    this.storeConfigInMeta = this.options.storeConfigInMeta;
    this.customTransformsMap = this.options.customTransformsMap;
    this.additionalAssetPaths = this.options.additionalAssetPaths;
    this.vendorTestStaticStyles = this.options.vendorTestStaticStyles;
    this.legacyTestFilesToAppend = this.options.legacyTestFilesToAppend;
  }

  /*
   * Replaces variables in &#x60;index.html&#x60; file with values from
   * &#x60;config/environment.js&#x60; and returns a single tree that contains
   * &#x60;index.html&#x60; file with populated values.
   *
   * Input tree:
   *
   * &#x60;&#x60;&#x60;
   * /
   * ├── addon-tree-output/
   * ├── the-best-app-ever/
   * ├── bower_components/
   * └── vendor/
   * &#x60;&#x60;&#x60;
   *
   * Returns:
   *
   * &#x60;&#x60;&#x60;
   * /
   * └── index.html
   * &#x60;&#x60;&#x60;
   *
   * @private
   * @method processIndex
   * @param {BroccoliTree}
   * @return {BroccoliTree}
   */
  processIndex(tree) {
    if (this._cachedProcessedIndex === null) {
      let indexFilePath = this.distPaths.appHtmlFile;

      let index = new Funnel(tree, {
        allowEmtpy: true,
        include: [&#x60;${this.name}/index.html&#x60;],
        getDestinationPath: () =&gt; indexFilePath,
        annotation: &#x27;Classic: index.html&#x27;,
      });

      let patterns = configReplacePatterns({
        addons: this.project.addons,
        autoRun: this.autoRun,
        storeConfigInMeta: this.storeConfigInMeta,
      });

      this._cachedProcessedIndex = new ConfigReplace(index, this.packageConfig(), {
        configPath: path.join(this.name, &#x27;config&#x27;, &#x27;environments&#x27;, &#x60;${this.env}.json&#x60;),
        files: [indexFilePath],
        patterns,
      });
    }

    return this._cachedProcessedIndex;
  }

  /*
   * Combines compiled javascript, external files (node modules, bower
   * components), vendor files and processed configuration (based on the
   * environment) into a single tree.
   *
   * Input tree:
   *
   * &#x60;&#x60;&#x60;
   * /
   * ├── addon-tree-output/
   * ├── the-best-app-ever/
   * ├── bower_components/
   * └── vendor/
   * &#x60;&#x60;&#x60;
   *
   * Changes are made &quot;inline&quot; so the output tree has the same structure.
   *
   * @private
   * @method processAppAndDependencies
   * @param {BroccoliTree}
   * @return {BroccoliTree}
   */
  processAppAndDependencies(allTrees) {
    if (this._cachedProcessedAppAndDependencies === null) {
      let config = this.packageConfig();
      let internal = this.packageEmberCliInternalFiles();
      let appContentsWithCompiledTemplates = this._debugTree(
        this.processTemplates(allTrees),
        &#x27;app-and-deps:post-templates&#x27;
      );

      let trees = [allTrees, appContentsWithCompiledTemplates].filter(Boolean);

      let mergedTree = this._debugTree(
        mergeTrees(trees, {
          annotation: &#x27;TreeMerger (preprocessedApp &amp; templates)&#x27;,
          overwrite: true,
        }),
        &#x27;app-and-deps:merged&#x27;
      );

      let external = this.applyCustomTransforms(allTrees);
      let postprocessedApp = this.processJavascript(mergedTree);

      let sourceTrees = [external, postprocessedApp, config, internal];

      this._cachedProcessedAppAndDependencies = this._debugTree(
        mergeTrees(sourceTrees, {
          overwrite: true,
          annotation: &#x27;Processed Application and Dependencies&#x27;,
        }),
        &#x27;app-and-deps:final&#x27;
      );
    }

    return this._cachedProcessedAppAndDependencies;
  }

  /*
   * Adds additional assets to the results tree, given the following list:
   *
   * &#x60;&#x60;&#x60;
   * [{
   *   src: &#x27;vendor/font-awesome/fonts&#x27;,
   *   file: &#x27;FontAwesome.otf&#x27;,
   *   dest: &#x27;fonts&#x27;
   * }]
   * &#x60;&#x60;&#x60;
   *
   * where &#x60;src&#x60; is a source path, &#x60;file&#x60; is a file name, and &#x60;dest&#x60; is a new
   * destination.
   *
   * @private
   * @method importAdditionalAssets
   * @param {BroccoliTree}
   * @return {BroccoliTree}
   */
  importAdditionalAssets(tree) {
    if (this._cachedProcessedAdditionalAssets === null) {
      let otherAssetTrees = funnelReducer(this.additionalAssetPaths).map((options) =&gt; {
        let files = options.include.join(&#x27;,&#x27;);
        options.annotation = &#x60;${options.srcDir}/{${files}} =&gt; ${options.destDir}/{${files}}&#x60;;

        return new Funnel(tree, options);
      });

      this._cachedProcessedAdditionalAssets = mergeTrees(otherAssetTrees, {
        annotation: &#x27;Processed Additional Assets&#x27;,
      });
    }

    return this._cachedProcessedAdditionalAssets;
  }

  /*
   * Runs all registered transformations on the passed in tree and returns the
   * result.
   *
   * Passed-in tree:
   *
   * &#x60;&#x60;&#x60;
   * /
   * ├── addon-tree-output/
   * ├── bower_components/
   * └── vendor/
   * &#x60;&#x60;&#x60;
   *
   * &#x60;customTransformsMap&#x60; has information about files that needed to be
   * transformed and the actual transformation functions that are executed.
   *
   * @private
   * @method applyCustomTransforms
   * @param {BroccoliTree} External (vendor) tree
   * @return {BroccoliTree}
   */
  applyCustomTransforms(externalTree) {
    if (this._cachedTransformedTree === null) {
      this._cachedTransformedTree = externalTree;

      for (let customTransformEntry of this.customTransformsMap) {
        let transformName = customTransformEntry[0];
        let transformConfig = customTransformEntry[1];

        let transformTree = new Funnel(this._cachedTransformedTree, {
          files: transformConfig.files,
          annotation: &#x60;Funnel (custom transform: ${transformName})&#x60;,
        });

        this._cachedTransformedTree = mergeTrees(
          [this._cachedTransformedTree, transformConfig.callback(transformTree, transformConfig.options)],
          {
            annotation: &#x60;TreeMerger (custom transform: ${transformName})&#x60;,
            overwrite: true,
          }
        );
      }
    }

    return this._cachedTransformedTree;
  }

  /*
   * Returns a single tree with &#x60;ember-cli&#x60; internal files with the following
   * structure:
   *
   * &#x60;&#x60;&#x60;
   * vendor/
   * └── ember-cli
   *     ├── app-boot.js
   *     ├── app-config.js
   *     ├── app-prefix.js
   *     ├── app-suffix.js
   *     ├── test-support-suffix.js
   *     ├── test-support-prefix.js
   *     ├── tests-prefix.js
   *     ├── tests-suffix.js
   *     ├── vendor-prefix.js
   *     └── vendor-suffix.js
   * &#x60;&#x60;&#x60;
   *
   * Note, that the contents of these files is being matched against several
   * internal &#x60;ember-cli&#x60; variables, such as:
   *
   * + &#x60;{{MODULE_PREFIX}}&#x60;
   * + different types of &#x60;{{content-for}}&#x60; (&#x60;{{content-for &#x27;app-boot&#x27;}}&#x60;)
   *
   * @private
   * @method packageEmberCliInternalFiles
   * @return {BroccoliTree}
   */
  packageEmberCliInternalFiles() {
    if (this._cachedEmberCliInternalTree === null) {
      let patterns = configReplacePatterns({
        addons: this.project.addons,
        autoRun: this.autoRun,
        storeConfigInMeta: this.storeConfigInMeta,
      });

      let configTree = this.packageConfig();
      let configPath = path.join(this.name, &#x27;config&#x27;, &#x27;environments&#x27;, &#x60;${this.env}.json&#x60;);

      let emberCLITree = new ConfigReplace(new UnwatchedDir(__dirname), configTree, {
        configPath,
        files: EMBER_CLI_FILES,
        patterns,
      });

      this._cachedEmberCliInternalTree = new Funnel(emberCLITree, {
        files: EMBER_CLI_FILES,
        destDir: EMBER_CLI_INTERNAL_FILES_PATH,
        annotation: &#x27;Packaged Ember CLI Internal Files&#x27;,
      });
    }

    return this._cachedEmberCliInternalTree;
  }

  /*
   * Runs pre/post-processors hooks on the template files and returns a single
   * tree with the processed templates.
   *
   * Given a tree:
   *
   * &#x60;&#x60;&#x60;
   * /
   * ├── addon-tree-output/
   * ├── bower_components/
   * ├── the-best-app-ever/
   * └── vendor/
   * &#x60;&#x60;&#x60;
   *
   * Returns:
   *
   * &#x60;&#x60;&#x60;
   * the-best-app-ever/
   * └── templates
   *     ├── application.js
   *     ├── error.js
   *     ├── index.js
   *     └── loading.js
   * &#x60;&#x60;&#x60;
   *
   * @private
   * @method processTemplates
   * @param {BroccoliTree} tree
   * @return {BroccoliTree}
   */
  processTemplates(inputTree) {
    if (this._cachedProcessedTemplates === null) {
      let appFiles = new Funnel(inputTree, {
        srcDir: &#x60;${this.name}/&#x60;,
        destDir: &#x60;${this.name}/&#x60;,
        annotation: &#x27;processTemplates: app files&#x27;,
      });

      let mergedTemplates = [appFiles];

      mergedTemplates = mergeTrees(mergedTemplates, {
        overwrite: true,
        annotation: &#x27;Templates&#x27;,
      });
      let preprocessedTemplatesFromAddons = callAddonsPreprocessTreeHook(this.project, &#x27;template&#x27;, mergedTemplates);

      this._cachedProcessedTemplates = callAddonsPostprocessTreeHook(
        this.project,
        &#x27;template&#x27;,
        preprocessTemplates(preprocessedTemplatesFromAddons, {
          registry: this.registry,
        })
      );
    }

    return this._cachedProcessedTemplates;
  }

  /*
   * Runs pre/post-processors hooks on the javascript files and returns a single
   * tree with the processed javascript.
   *
   * Given a tree:
   *
   * &#x60;&#x60;&#x60;
   * /
   * ├── addon-tree-output/
   * ├── bower_components/
   * ├── the-best-app-ever/
   * └── vendor/
   * &#x60;&#x60;&#x60;
   *
   * Returns:
   *
   * &#x60;&#x60;&#x60;
   * the-best-app-ever/
   * ├── adapters
   * │   └── application.js
   * ├── app.js
   * ├── components
   * ├── controllers
   * ├── helpers
   * │   ├── and.js
   * │   ├── app-version.js
   * │   ├── await.js
   * │   ├── camelize.js
   * │   ├── cancel-all.js
   * │   ├── dasherize.js
   * │   ├── dec.js
   * │   ├── drop.js
   * │   └── eq.js
   * ...
   * &#x60;&#x60;&#x60;
   *
   * @private
   * @method processJavascript
   * @param {BroccoliTree} tree
   * @return {BroccoliTree}
   */
  processJavascript(tree) {
    if (this._cachedProcessedJavascript === null) {
      let javascript = new Funnel(tree, {
        srcDir: this.name,
        destDir: this.name,
        annotation: &#x27;&#x27;,
      });
      let app = callAddonsPreprocessTreeHook(this.project, &#x27;js&#x27;, javascript);

      let preprocessedApp = preprocessJs(app, &#x27;/&#x27;, this.name, {
        registry: this.registry,
      });

      this._cachedProcessedJavascript = callAddonsPostprocessTreeHook(this.project, &#x27;js&#x27;, preprocessedApp);
    }

    return this._cachedProcessedJavascript;
  }

  /*
   * Compiles application css files, runs pre/post-processors hooks on the them,
   * concatenates them into one application and vendor files and returns a
   * single tree.
   *
   * Given an input tree that looks like:
   *
   * &#x60;&#x60;&#x60;
   * addon-tree-output/
   *   ...
   * bower_components/
   *   hint.css/
   *   ...
   * the-best-app-ever/
   *   styles/
   *   ...
   * vendor/
   *   font-awesome/
   *   ...
   * &#x60;&#x60;&#x60;
   *
   * Returns:
   *
   * &#x60;&#x60;&#x60;
   * assets/
   *   the-best-app-ever.css
   *   vendor.css
   * &#x60;&#x60;&#x60;
   *
   * @private
   * @method packageStyles
   * @return {BroccoliTree}
   */
  packageStyles(tree) {
    if (this._cachedProcessedStyles === null) {
      let cssMinificationEnabled = this.minifyCSS.enabled;
      let options = {
        outputPaths: this.distPaths.appCssFile,
        registry: this.registry,
        minifyCSS: this.minifyCSS.options,
      };

      let stylesAndVendor = callAddonsPreprocessTreeHook(this.project, &#x27;css&#x27;, tree);
      stylesAndVendor = this._debugTree(stylesAndVendor, &#x27;mu-layout:addonsPreprocessTree:css&#x27;);

      let preprocessedStyles = preprocessCss(stylesAndVendor, &#x27;/app/styles&#x27;, &#x27;/assets&#x27;, options);
      preprocessedStyles = this._debugTree(preprocessedStyles, &#x27;mu-layout:preprocess:css&#x27;);

      let vendorStyles = [];
      for (let outputFile in this.styleOutputFiles) {
        let isMainVendorFile = outputFile === this.distPaths.vendorCssFile;
        let headerFiles = this.styleOutputFiles[outputFile];
        let inputFiles = isMainVendorFile ? [&#x27;addon-tree-output/**/__COMPILED_STYLES__/**/*.css&#x27;] : [];

        vendorStyles.push(
          concat(stylesAndVendor, {
            headerFiles,
            inputFiles,
            outputFile,
            allowNone: true,
            annotation: &#x60;Concat: Vendor Styles${outputFile}&#x60;,
          })
        );
      }

      vendorStyles = mergeTrees(vendorStyles, {
        annotation: &#x27;TreeMerger (vendorStyles)&#x27;,
        overwrite: true,
      });

      if (cssMinificationEnabled === true) {
        options.minifyCSS.registry = options.registry;
        preprocessedStyles = preprocessMinifyCss(preprocessedStyles, options.minifyCSS);
        vendorStyles = preprocessMinifyCss(vendorStyles, options.minifyCSS);
      }

      this._cachedProcessedStyles = callAddonsPostprocessTreeHook(
        this.project,
        &#x27;css&#x27;,
        mergeTrees([preprocessedStyles, vendorStyles], {
          annotation: &#x27;Packaged Styles&#x27;,
        })
      );
    }

    return this._cachedProcessedStyles;
  }

  /*
   * Given an input tree, returns a properly assembled Broccoli tree with bower
   * components.
   *
   * Given a tree:
   *
   * &#x60;&#x60;&#x60;
   * ├── ember.js/
   * ├── pusher/
   * └── raven-js/
   * &#x60;&#x60;&#x60;
   *
   * Returns:
   *
   * &#x60;&#x60;&#x60;
   * [bowerDirectory]/
   * ├── ember.js/
   * ├── pusher/
   * └── raven-js/
   * &#x60;&#x60;&#x60;
   *
   * @private
   * @method packageBower
   * @param {BroccoliTree} tree
   * @param {String} bowerDirectory Custom path to bower components
   */
  packageBower(tree, bowerDirectory) {
    if (this._cachedBower === null) {
      this._cachedBower = new Funnel(tree, {
        destDir: bowerDirectory || DEFAULT_BOWER_PATH,
        annotation: &#x27;Packaged Bower&#x27;,
      });
    }

    return this._cachedBower;
  }

  /*
   * Given an input tree, returns a properly assembled Broccoli tree with vendor
   * files.
   *
   * Given a tree:
   *
   * &#x60;&#x60;&#x60;
   * ├── babel-polyfill/
   * ├── ember-cli-shims/
   * ├── ember-load-initializers/
   * ├── ember-qunit/
   * ├── ember-resolver/
   * ├── sinon/
   * └── tether/
   * &#x60;&#x60;&#x60;
   *
   * Returns:
   *
   * &#x60;&#x60;&#x60;
   * vendor/
   * ├── babel-polyfill/
   * ├── ember-cli-shims/
   * ├── ember-load-initializers/
   * ├── ember-qunit/
   * ├── ember-resolver/
   * ├── sinon/
   * └── tether/
   * &#x60;&#x60;&#x60;
   *
   * @private
   * @method packageVendor
   * @param {BroccoliTree} tree
   */
  packageVendor(tree) {
    if (this._cachedVendor === null) {
      this._cachedVendor = new Funnel(tree, {
        destDir: DEFAULT_VENDOR_PATH,
        annotation: &#x27;Packaged Vendor&#x27;,
      });
    }

    return this._cachedVendor;
  }

  /*
   * Given an input tree, returns a properly assembled Broccoli tree with tests
   * files.
   *
   * Given a tree:
   *
   * &#x60;&#x60;&#x60;
   * addon-tree-output/
   * bower_components/
   * the-best-app-ever/
   * tests/
   * ├── acceptance/
   * ├── helpers/
   * ├── index.html
   * ├── integration/
   * ├── test-helper.js
   * └── unit/
   * &#x60;&#x60;&#x60;
   *
   * Returns:
   *
   * &#x60;&#x60;&#x60;
   * [name]/
   * └── tests
   *     ├── acceptance/
   *     ├── helpers/
   *     ├── index.html
   *     ├── integration/
   *     ├── test-helper.js
   *     └── unit/
   * &#x60;&#x60;&#x60;
   *
   * @private
   * @method processTests
   * @param {BroccoliTree} tree
   */
  processTests(tree) {
    if (this._cachedTests === null) {
      let addonTestSupportTree = new Funnel(tree, {
        srcDir: &#x27;tests/addon-test-support&#x27;,
        destDir: &#x27;addon-test-support&#x27;,
      });

      let testTree = new Funnel(tree, {
        srcDir: &#x27;tests&#x27;,
        exclude: [&#x27;addon-test-support/**/*&#x27;],
      });

      let treeToCompile = new Funnel(testTree, {
        destDir: &#x60;${this.name}/tests&#x60;,
        annotation: &#x27;Tests To Process&#x27;,
      });

      treeToCompile = callAddonsPreprocessTreeHook(this.project, &#x27;test&#x27;, treeToCompile);

      const inputPath = &#x27;/tests&#x27;;
      let preprocessedTests = preprocessJs(treeToCompile, inputPath, this.name, {
        registry: this.registry,
      });

      let mergedTestTrees = mergeTrees([addonTestSupportTree, preprocessedTests], {
        overwrite: true,
        annotation: &#x27;Packaged Tests&#x27;,
      });

      this._cachedTests = callAddonsPostprocessTreeHook(this.project, &#x27;test&#x27;, mergedTestTrees);
    }

    return this._cachedTests;
  }

  /*
   * Concatenates all test files into one, as follows:
   *
   * Given an input tree that looks like:
   *
   * &#x60;&#x60;&#x60;
   * addon-tree-output/
   * bower_components/
   * the-best-app-ever/
   * tests/
   * ├── acceptance/
   * ├── helpers/
   * ├── index.html
   * ├── integration/
   * ├── test-helper.js
   * └── unit/
   * vendor/
   * &#x60;&#x60;&#x60;
   *
   * Returns:
   *
   * &#x60;&#x60;&#x60;
   * assets/
   *   tests.js
   *   test.map (if sourcemaps are enabled)
   *   test-support.js
   *   test-support.map (if sourcemaps are enabled)
   *   test-support.css
   * &#x60;&#x60;&#x60;
   *
   * @private
   * @method packageTests
   * @param {BroccoliTree}
   * @return {BroccoliTree}
   */
  packageTests(tree) {
    let coreTestTree = this.processTests(tree);

    let testIndex = this.processTestIndex(tree);
    let appTestTree = this.packageApplicationTests(coreTestTree);
    let testFilesTree = this.packageTestFiles(tree, coreTestTree);

    return mergeTrees([testIndex, appTestTree, testFilesTree], {
      annotation: &#x27;Packaged Tests&#x27;,
    });
  }

  /*
   * Replaces variables in &#x60;tests/index.html&#x60; file with values from
   * &#x60;config/environment.js&#x60; and returns a single tree that contains
   * &#x60;index.html&#x60; file with populated values.
   *
   * Input tree:
   *
   * &#x60;&#x60;&#x60;
   * /
   * ├── addon-tree-output/
   * ├── the-best-app-ever/
   * ├── bower_components/
   * ├── tests/
   * └── vendor/
   * &#x60;&#x60;&#x60;
   *
   * Returns:
   *
   * &#x60;&#x60;&#x60;
   * └── tests
   *     └── index.html/
   * &#x60;&#x60;&#x60;
   *
   * @private
   * @method processTestIndex
   * @param {BroccoliTree}
   * @return {BroccoliTree}
   */
  processTestIndex(tree) {
    let index = new Funnel(tree, {
      srcDir: &#x27;/tests&#x27;,
      files: [&#x27;index.html&#x27;],
      destDir: &#x27;/tests&#x27;,
      annotation: &#x27;Funnel (test index)&#x27;,
    });

    let patterns = configReplacePatterns({
      addons: this.project.addons,
      autoRun: this.autoRun,
      storeConfigInMeta: this.storeConfigInMeta,
    });

    let configPath = path.join(this.name, &#x27;config&#x27;, &#x27;environments&#x27;, &#x27;test.json&#x27;);

    return new ConfigReplace(index, this.packageConfig(), {
      configPath,
      files: [&#x27;tests/index.html&#x27;],
      env: &#x27;test&#x27;,
      patterns,
    });
  }

  /*
   * Wraps application configuration into AMD module:
   *
   * &#x60;&#x60;&#x60;javascript
   * define(&#x27;the-best-app-ever/config/environment&#x27;, [], function() {
   *   // read the meta tag that contains escaped configuration from
   *   // &#x60;index.html&#x60; and return as an object
   * });
   * &#x60;&#x60;&#x60;
   *
   * Given a tree:
   *
   * &#x60;&#x60;&#x60;
   * environments/
   * ├── development.json
   * └── test.json
   * &#x60;&#x60;&#x60;
   *
   * Returns:
   *
   * &#x60;&#x60;&#x60;
   * └── vendor
   *     └── ember-cli
   *         └── app-config.js
   * &#x60;&#x60;&#x60;
   * @private
   * @method packageTestApplicationConfig
   */
  packageTestApplicationConfig() {
    let files = [&#x27;app-config.js&#x27;];
    let patterns = configReplacePatterns({
      addons: this.project.addons,
      autoRun: this.autoRun,
      storeConfigInMeta: this.storeConfigInMeta,
    });

    let configPath = path.join(this.name, &#x27;config&#x27;, &#x27;environments&#x27;, &#x60;test.json&#x60;);
    let emberCLITree = new ConfigReplace(new UnwatchedDir(__dirname), this.packageConfig(), {
      configPath,
      files,
      patterns,
    });

    return new Funnel(emberCLITree, {
      files,
      srcDir: &#x27;/&#x27;,
      destDir: &#x27;/vendor/ember-cli/&#x27;,
      annotation: &#x27;Funnel (test-app-config-tree)&#x27;,
    });
  }

  /*
   * Concatenates all application test files into one, as follows:
   *
   * Given an input tree that looks like:
   *
   * &#x60;&#x60;&#x60;
   * addon-tree-output/
   * bower_components/
   * the-best-app-ever/
   * tests/
   * ├── acceptance/
   * ├── helpers/
   * ├── index.html
   * ├── integration/
   * ├── test-helper.js
   * └── unit/
   * vendor/
   * &#x60;&#x60;&#x60;
   *
   * Returns:
   *
   * &#x60;&#x60;&#x60;
   * assets/
   *   tests.js
   *   test.map (if sourcemaps are enabled)
   * &#x60;&#x60;&#x60;
   *
   * @private
   * @method packageApplicationTests
   * @param {BroccoliTree}
   * @return {BroccoliTree}
   */
  packageApplicationTests(tree) {
    let appTestTrees = []
      .concat(this.packageEmberCliInternalFiles(), this.packageTestApplicationConfig(), tree)
      .filter(Boolean);

    appTestTrees = mergeTrees(appTestTrees, {
      overwrite: true,
      annotation: &#x27;TreeMerger (appTestTrees)&#x27;,
    });

    return concat(appTestTrees, {
      inputFiles: [&#x27;**/tests/**/*.js&#x27;],
      headerFiles: [&#x27;vendor/ember-cli/tests-prefix.js&#x27;],
      footerFiles: [&#x27;vendor/ember-cli/app-config.js&#x27;, &#x27;vendor/ember-cli/tests-suffix.js&#x27;],
      outputFile: this.distPaths.testJsFile,
      annotation: &#x27;Concat: App Tests&#x27;,
      sourceMapConfig: this.sourcemaps,
    });
  }

  /*
   * Concatenates all test support files into one, as follows:
   *
   * Given an input tree that looks like:
   *
   * &#x60;&#x60;&#x60;
   * addon-tree-output/
   * bower_components/
   * the-best-app-ever/
   * tests/
   * ├── acceptance/
   * ├── helpers/
   * ├── index.html
   * ├── integration/
   * ├── test-helper.js
   * └── unit/
   * vendor/
   * &#x60;&#x60;&#x60;
   *
   * Returns:
   *
   * &#x60;&#x60;&#x60;
   * assets/
   *   test-support.js
   *   test-support.map (if sourcemaps are enabled)
   *   test-support.css
   * &#x60;&#x60;&#x60;
   *
   * @private
   * @method packageTestFiles
   * @return {BroccoliTree}
   */
  packageTestFiles(tree, coreTestTree) {
    let testSupportPath = this.distPaths.testSupportJsFile;

    testSupportPath = testSupportPath.testSupport || testSupportPath;

    let emberCLITree = this.packageEmberCliInternalFiles();

    let headerFiles = [].concat(&#x27;vendor/ember-cli/test-support-prefix.js&#x27;, this.legacyTestFilesToAppend);

    let inputFiles = [&#x27;addon-test-support/**/*.js&#x27;];

    let footerFiles = [&#x27;vendor/ember-cli/test-support-suffix.js&#x27;];

    let external = this.applyCustomTransforms(tree);

    let baseMergedTree = mergeTrees([emberCLITree, tree, external, coreTestTree], {
      overwrite: true,
    });
    let testJs = concat(baseMergedTree, {
      headerFiles,
      inputFiles,
      footerFiles,
      outputFile: testSupportPath,
      annotation: &#x27;Concat: Test Support JS&#x27;,
      allowNone: true,
      sourceMapConfig: this.sourcemaps,
    });

    let testemPath = path.join(__dirname, &#x27;testem&#x27;);
    testemPath = path.dirname(testemPath);

    let testemTree = new Funnel(new UnwatchedDir(testemPath), {
      files: [&#x27;testem.js&#x27;],
      annotation: &#x27;Funnel (testem)&#x27;,
    });

    let sourceTrees = [testemTree, testJs];

    if (this.vendorTestStaticStyles.length &gt; 0) {
      sourceTrees.push(
        concat(tree, {
          headerFiles: this.vendorTestStaticStyles,
          outputFile: this.distPaths.testSupportCssFile,
          annotation: &#x27;Concat: Test Support CSS&#x27;,
          sourceMapConfig: this.sourcemaps,
        })
      );
    }

    return mergeTrees(sourceTrees, {
      overwrite: true,
      annotation: &#x27;TreeMerger (testFiles)&#x27;,
    });
  }

  /*
   * Returns a flattened input tree.
   *
   * Given a tree:
   *
   * &#x60;&#x60;&#x60;
   * public
   * ├── crossdomain.xml
   * ├── ember-fetch
   * ├── favicon.ico
   * ├── images
   * └── robots.txt
   * &#x60;&#x60;&#x60;
   *
   * Returns:
   *
   * &#x60;&#x60;&#x60;
   * ├── crossdomain.xml
   * ├── ember-fetch
   * ├── favicon.ico
   * ├── images
   * └── robots.txt
   * &#x60;&#x60;&#x60;
   *
   * @private
   * @method packagePublic
   * @param {BroccoliTree} tree
   * @return {BroccoliTree}
   */
  packagePublic(tree) {
    if (this._cachedPublic === null) {
      this._cachedPublic = new Funnel(tree, {
        srcDir: &#x27;public&#x27;,
        destDir: &#x27;.&#x27;,
      });
    }

    return this._cachedPublic;
  }

  /*
   * Given an input tree, returns a properly assembled Broccoli tree with
   * configuration files.
   *
   * Given a tree:
   *
   * &#x60;&#x60;&#x60;
   * environments/
   * ├── development.json
   * └── test.json
   * &#x60;&#x60;&#x60;
   *
   * Returns:
   *
   * &#x60;&#x60;&#x60;
   * └── [name]
   *     └── config
   *         └── environments
   *             ├── development.json
   *             └── test.json
   * &#x60;&#x60;&#x60;
   * @private
   * @method packageConfig
   */
  packageConfig() {
    let env = this.env;
    let name = this.name;
    let project = this.project;
    let configPath = this.project.configPath();

    if (this._cachedConfig === null) {
      let configTree = new ConfigLoader(path.dirname(configPath), {
        env,
        tests: this.areTestsEnabled || false,
        project,
      });

      this._cachedConfig = new Funnel(configTree, {
        destDir: &#x60;${name}/config&#x60;,
        annotation: &#x27;Packaged Config&#x27;,
      });
    }

    return this._cachedConfig;
  }

  /*
   * Concatenates all javascript Broccoli trees into one, as follows:
   *
   * Given an input tree that looks like:
   *
   * &#x60;&#x60;&#x60;
   * addon-tree-output/
   *   ember-ajax/
   *   ember-data/
   *   ember-engines/
   *   ember-resolver/
   *   ...
   * bower_components/
   *   usertiming/
   *   sinonjs/
   *   ...
   * the-best-app-ever/
   *   components/
   *   config/
   *   helpers/
   *   routes/
   *   ...
   * vendor/
   *   ...
   *   babel-core/
   *   ...
   *   broccoli-concat/
   *   ...
   *   ember-cli-template-lint/
   *   ...
   * &#x60;&#x60;&#x60;
   *
   * Returns:
   *
   * &#x60;&#x60;&#x60;
   * assets/
   *   the-best-app-ever.js
   *   the-best-app-ever.map (if sourcemaps are enabled)
   *   vendor.js
   *   vendor.map (if sourcemaps are enabled)
   * &#x60;&#x60;&#x60;
   *
   * @private
   * @method packageJavascript
   * @return {BroccoliTree}
   */
  packageJavascript(tree) {
    if (this._cachedJavascript === null) {
      let applicationJs = this.processAppAndDependencies(tree);

      let vendorFilePath = this.distPaths.vendorJsFile;
      this.scriptOutputFiles[vendorFilePath].unshift(&#x27;vendor/ember-cli/vendor-prefix.js&#x27;);

      let appJs = this.packageApplicationJs(applicationJs);
      let vendorJs = this.packageVendorJs(applicationJs);

      this._cachedJavascript = mergeTrees([appJs, vendorJs], {
        overwrite: true,
        annotation: &#x27;Packaged Javascript&#x27;,
      });
    }

    return this._cachedJavascript;
  }

  /*
   * Concatenates all application&#x27;s javascript Broccoli trees into one, as follows:
   *
   * Given an input tree that looks like:
   *
   * &#x60;&#x60;&#x60;
   * addon-tree-output/
   *   ember-ajax/
   *   ember-data/
   *   ember-engines/
   *   ember-resolver/
   *   ...
   * bower_components/
   *   usertiming/
   *   sinonjs/
   *   ...
   * the-best-app-ever/
   *   components/
   *   config/
   *   helpers/
   *   routes/
   *   ...
   * vendor/
   *   ...
   *   babel-core/
   *   ...
   *   broccoli-concat/
   *   ...
   *   ember-cli-template-lint/
   *   ...
   * &#x60;&#x60;&#x60;
   *
   * Returns:
   *
   * &#x60;&#x60;&#x60;
   * assets/
   *   the-best-app-ever.js
   *   the-best-app-ever.map (if sourcemaps are enabled)
   * &#x60;&#x60;&#x60;
   *
   * @private
   * @method packageApplicationJs
   * @return {BroccoliTree}
   */
  packageApplicationJs(tree) {
    let inputFiles = [&#x60;${this.name}/**/*.js&#x60;];
    let headerFiles = [&#x27;vendor/ember-cli/app-prefix.js&#x27;];
    let footerFiles = [
      &#x27;vendor/ember-cli/app-suffix.js&#x27;,
      &#x27;vendor/ember-cli/app-config.js&#x27;,
      &#x27;vendor/ember-cli/app-boot.js&#x27;,
    ];

    return concat(tree, {
      inputFiles,
      headerFiles,
      footerFiles,
      outputFile: this.distPaths.appJsFile,
      annotation: &#x27;Packaged Application Javascript&#x27;,
      separator: &#x27;\n;&#x27;,
      sourceMapConfig: this.sourcemaps,
    });
  }

  /*
   * Concatenates all application&#x27;s vendor javascript Broccoli trees into one, as follows:
   *
   * Given an input tree that looks like:
   * &#x60;&#x60;&#x60;
   * addon-tree-output/
   *   ember-ajax/
   *   ember-data/
   *   ember-engines/
   *   ember-resolver/
   *   ...
   * bower_components/
   *   usertiming/
   *   sinonjs/
   *   ...
   * the-best-app-ever/
   *   components/
   *   config/
   *   helpers/
   *   routes/
   *   ...
   * vendor/
   *   ...
   *   babel-core/
   *   ...
   *   broccoli-concat/
   *   ...
   *   ember-cli-template-lint/
   *   ...
   * &#x60;&#x60;&#x60;
   *
   * Returns:
   *
   * &#x60;&#x60;&#x60;
   * assets/
   *   vendor.js
   *   vendor.map (if sourcemaps are enabled)
   * &#x60;&#x60;&#x60;
   *
   * @method packageVendorJs
   * @param {BroccoliTree} tree
   * @return {BroccoliTree}
   */
  packageVendorJs(tree) {
    let importPaths = Object.keys(this.scriptOutputFiles);

    // iterate over the keys and concat files
    // to support scenarios like
    // app.import(&#x27;vendor/foobar.js&#x27;, { outputFile: &#x27;assets/baz.js&#x27; });
    let vendorTrees = importPaths.map((importPath) =&gt; {
      let files = this.scriptOutputFiles[importPath];
      let isMainVendorFile = importPath === this.distPaths.vendorJsFile;

      const vendorObject = getVendorFiles(files, isMainVendorFile);

      return concat(tree, {
        inputFiles: vendorObject.inputFiles,
        headerFiles: vendorObject.headerFiles,
        footerFiles: vendorObject.footerFiles,
        outputFile: importPath,
        annotation: &#x60;Package ${importPath}&#x60;,
        separator: &#x27;\n;&#x27;,
        sourceMapConfig: this.sourcemaps,
      });
    });

    return mergeTrees(vendorTrees, {
      overwrite: true,
      annotation: &#x27;Packaged Vendor Javascript&#x27;,
    });
  }
};

</pre>

</div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
</body>
</html>
