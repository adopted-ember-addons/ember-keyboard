"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createIteratorRef = createIteratorRef;
exports.createIteratorItemRef = createIteratorItemRef;

var _globalContext = require("@glimmer/global-context");

var _util = require("@glimmer/util");

var _env = require("@glimmer/env");

var _validator = require("@glimmer/validator");

var _reference = require("./reference");

const NULL_IDENTITY = {};

const KEY = (_, index) => index;

const INDEX = (_, index) => String(index);

const IDENTITY = item => {
  if (item === null) {
    // Returning null as an identity will cause failures since the iterator
    // can't tell that it's actually supposed to be null
    return NULL_IDENTITY;
  }

  return item;
};

function keyForPath(path) {
  if (_env.DEBUG && path[0] === '@') {
    throw new Error(`invalid keypath: '${path}', valid keys: @index, @identity, or a path`);
  }

  return uniqueKeyFor(item => (0, _globalContext.getPath)(item, path));
}

function makeKeyFor(key) {
  switch (key) {
    case '@key':
      return uniqueKeyFor(KEY);

    case '@index':
      return uniqueKeyFor(INDEX);

    case '@identity':
      return uniqueKeyFor(IDENTITY);

    default:
      return keyForPath(key);
  }
}

class WeakMapWithPrimitives {
  get weakMap() {
    if (this._weakMap === undefined) {
      this._weakMap = new WeakMap();
    }

    return this._weakMap;
  }

  get primitiveMap() {
    if (this._primitiveMap === undefined) {
      this._primitiveMap = new Map();
    }

    return this._primitiveMap;
  }

  set(key, value) {
    if ((0, _util.isObject)(key) || typeof key === 'function') {
      this.weakMap.set(key, value);
    } else {
      this.primitiveMap.set(key, value);
    }
  }

  get(key) {
    if ((0, _util.isObject)(key) || typeof key === 'function') {
      return this.weakMap.get(key);
    } else {
      return this.primitiveMap.get(key);
    }
  }

}

const IDENTITIES = new WeakMapWithPrimitives();

function identityForNthOccurence(value, count) {
  let identities = IDENTITIES.get(value);

  if (identities === undefined) {
    identities = [];
    IDENTITIES.set(value, identities);
  }

  let identity = identities[count];

  if (identity === undefined) {
    identity = {
      value,
      count
    };
    identities[count] = identity;
  }

  return identity;
}
/**
 * When iterating over a list, it's possible that an item with the same unique
 * key could be encountered twice:
 *
 * ```js
 * let arr = ['same', 'different', 'same', 'same'];
 * ```
 *
 * In general, we want to treat these items as _unique within the list_. To do
 * this, we track the occurences of every item as we iterate the list, and when
 * an item occurs more than once, we generate a new unique key just for that
 * item, and that occurence within the list. The next time we iterate the list,
 * and encounter an item for the nth time, we can get the _same_ key, and let
 * Glimmer know that it should reuse the DOM for the previous nth occurence.
 */


function uniqueKeyFor(keyFor) {
  let seen = new WeakMapWithPrimitives();
  return (value, memo) => {
    let key = keyFor(value, memo);
    let count = seen.get(key) || 0;
    seen.set(key, count + 1);

    if (count === 0) {
      return key;
    }

    return identityForNthOccurence(key, count);
  };
}

function createIteratorRef(listRef, key) {
  return (0, _reference.createComputeRef)(() => {
    let iterable = (0, _reference.valueForRef)(listRef);
    let keyFor = makeKeyFor(key);

    if (Array.isArray(iterable)) {
      return new ArrayIterator(iterable, keyFor);
    }

    let maybeIterator = (0, _globalContext.toIterator)(iterable);

    if (maybeIterator === null) {
      return new ArrayIterator(_util.EMPTY_ARRAY, () => null);
    }

    return new IteratorWrapper(maybeIterator, keyFor);
  });
}

function createIteratorItemRef(_value) {
  let value = _value;
  let tag = (0, _validator.createTag)();
  return (0, _reference.createComputeRef)(() => {
    (0, _validator.consumeTag)(tag);
    return value;
  }, newValue => {
    if (value !== newValue) {
      value = newValue;
      (0, _validator.dirtyTag)(tag);
    }
  });
}

class IteratorWrapper {
  constructor(inner, keyFor) {
    this.inner = inner;
    this.keyFor = keyFor;
  }

  isEmpty() {
    return this.inner.isEmpty();
  }

  next() {
    let nextValue = this.inner.next();

    if (nextValue !== null) {
      nextValue.key = this.keyFor(nextValue.value, nextValue.memo);
    }

    return nextValue;
  }

}

class ArrayIterator {
  constructor(iterator, keyFor) {
    this.iterator = iterator;
    this.keyFor = keyFor;
    this.pos = 0;

    if (iterator.length === 0) {
      this.current = {
        kind: 'empty'
      };
    } else {
      this.current = {
        kind: 'first',
        value: iterator[this.pos]
      };
    }
  }

  isEmpty() {
    return this.current.kind === 'empty';
  }

  next() {
    let value;
    let current = this.current;

    if (current.kind === 'first') {
      this.current = {
        kind: 'progress'
      };
      value = current.value;
    } else if (this.pos >= this.iterator.length - 1) {
      return null;
    } else {
      value = this.iterator[++this.pos];
    }

    let {
      keyFor
    } = this;
    let key = keyFor(value, this.pos);
    let memo = this.pos;
    return {
      key,
      value,
      memo
    };
  }

}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3JlZmVyZW5jZS9saWIvaXRlcmFibGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7QUFFQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUE0QkEsTUFBTSxhQUFhLEdBQW5CLEVBQUE7O0FBRUEsTUFBTSxHQUFHLEdBQVcsQ0FBQSxDQUFBLEVBQUEsS0FBQSxLQUFwQixLQUFBOztBQUNBLE1BQU0sS0FBSyxHQUFXLENBQUEsQ0FBQSxFQUFBLEtBQUEsS0FBYyxNQUFNLENBQTFDLEtBQTBDLENBQTFDOztBQUNBLE1BQU0sUUFBUSxHQUFZLElBQUQsSUFBUztBQUNoQyxNQUFJLElBQUksS0FBUixJQUFBLEVBQW1CO0FBQ2pCO0FBQ0E7QUFDQSxXQUFBLGFBQUE7QUFDRDs7QUFFRCxTQUFBLElBQUE7QUFQRixDQUFBOztBQVVBLFNBQUEsVUFBQSxDQUFBLElBQUEsRUFBZ0M7QUFDOUIsTUFBSSxjQUFTLElBQUksQ0FBSixDQUFJLENBQUosS0FBYixHQUFBLEVBQThCO0FBQzVCLFVBQU0sSUFBQSxLQUFBLENBQVUscUJBQXFCLElBQXJDLDZDQUFNLENBQU47QUFDRDs7QUFDRCxTQUFPLFlBQVksQ0FBRSxJQUFELElBQVUsNEJBQU8sSUFBUCxFQUE5QixJQUE4QixDQUFYLENBQW5CO0FBQ0Q7O0FBRUQsU0FBQSxVQUFBLENBQUEsR0FBQSxFQUErQjtBQUM3QixVQUFBLEdBQUE7QUFDRSxTQUFBLE1BQUE7QUFDRSxhQUFPLFlBQVksQ0FBbkIsR0FBbUIsQ0FBbkI7O0FBQ0YsU0FBQSxRQUFBO0FBQ0UsYUFBTyxZQUFZLENBQW5CLEtBQW1CLENBQW5COztBQUNGLFNBQUEsV0FBQTtBQUNFLGFBQU8sWUFBWSxDQUFuQixRQUFtQixDQUFuQjs7QUFDRjtBQUNFLGFBQU8sVUFBVSxDQUFqQixHQUFpQixDQUFqQjtBQVJKO0FBVUQ7O0FBRUQsTUFBQSxxQkFBQSxDQUEyQjtBQUl6QixNQUFBLE9B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QUFDRDs7QUFuQ2dCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0UGF0aCwgdG9JdGVyYXRvciB9IGZyb20gJ0BnbGltbWVyL2dsb2JhbC1jb250ZXh0JztcbmltcG9ydCB7IE9wdGlvbiwgRGljdCB9IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgRU1QVFlfQVJSQVksIGlzT2JqZWN0IH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5pbXBvcnQgeyBERUJVRyB9IGZyb20gJ0BnbGltbWVyL2Vudic7XG5pbXBvcnQgeyBjcmVhdGVUYWcsIGNvbnN1bWVUYWcsIGRpcnR5VGFnIH0gZnJvbSAnQGdsaW1tZXIvdmFsaWRhdG9yJztcbmltcG9ydCB7IFJlZmVyZW5jZSwgUmVmZXJlbmNlRW52aXJvbm1lbnQsIHZhbHVlRm9yUmVmLCBjcmVhdGVDb21wdXRlUmVmIH0gZnJvbSAnLi9yZWZlcmVuY2UnO1xuXG5leHBvcnQgaW50ZXJmYWNlIEl0ZXJhdGlvbkl0ZW08VCwgVT4ge1xuICBrZXk6IHVua25vd247XG4gIHZhbHVlOiBUO1xuICBtZW1vOiBVO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFic3RyYWN0SXRlcmF0b3I8VCwgVSwgViBleHRlbmRzIEl0ZXJhdGlvbkl0ZW08VCwgVT4+IHtcbiAgaXNFbXB0eSgpOiBib29sZWFuO1xuICBuZXh0KCk6IE9wdGlvbjxWPjtcbn1cblxuZXhwb3J0IHR5cGUgT3BhcXVlSXRlcmF0aW9uSXRlbSA9IEl0ZXJhdGlvbkl0ZW08dW5rbm93biwgdW5rbm93bj47XG5leHBvcnQgdHlwZSBPcGFxdWVJdGVyYXRvciA9IEFic3RyYWN0SXRlcmF0b3I8dW5rbm93biwgdW5rbm93biwgT3BhcXVlSXRlcmF0aW9uSXRlbT47XG5cbmV4cG9ydCBpbnRlcmZhY2UgSXRlcmF0b3JEZWxlZ2F0ZSB7XG4gIGlzRW1wdHkoKTogYm9vbGVhbjtcbiAgbmV4dCgpOiB7IHZhbHVlOiB1bmtub3duOyBtZW1vOiB1bmtub3duIH0gfCBudWxsO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEl0ZXJhdG9yUmVmZXJlbmNlRW52aXJvbm1lbnQgZXh0ZW5kcyBSZWZlcmVuY2VFbnZpcm9ubWVudCB7XG4gIGdldFBhdGgob2JqOiB1bmtub3duLCBwYXRoOiBzdHJpbmcpOiB1bmtub3duO1xuICB0b0l0ZXJhdG9yKG9iajogdW5rbm93bik6IE9wdGlvbjxJdGVyYXRvckRlbGVnYXRlPjtcbn1cblxudHlwZSBLZXlGb3IgPSAoaXRlbTogdW5rbm93biwgaW5kZXg6IHVua25vd24pID0+IHVua25vd247XG5cbmNvbnN0IE5VTExfSURFTlRJVFkgPSB7fTtcblxuY29uc3QgS0VZOiBLZXlGb3IgPSAoXywgaW5kZXgpID0+IGluZGV4O1xuY29uc3QgSU5ERVg6IEtleUZvciA9IChfLCBpbmRleCkgPT4gU3RyaW5nKGluZGV4KTtcbmNvbnN0IElERU5USVRZOiBLZXlGb3IgPSAoaXRlbSkgPT4ge1xuICBpZiAoaXRlbSA9PT0gbnVsbCkge1xuICAgIC8vIFJldHVybmluZyBudWxsIGFzIGFuIGlkZW50aXR5IHdpbGwgY2F1c2UgZmFpbHVyZXMgc2luY2UgdGhlIGl0ZXJhdG9yXG4gICAgLy8gY2FuJ3QgdGVsbCB0aGF0IGl0J3MgYWN0dWFsbHkgc3VwcG9zZWQgdG8gYmUgbnVsbFxuICAgIHJldHVybiBOVUxMX0lERU5USVRZO1xuICB9XG5cbiAgcmV0dXJuIGl0ZW07XG59O1xuXG5mdW5jdGlvbiBrZXlGb3JQYXRoKHBhdGg6IHN0cmluZyk6IEtleUZvciB7XG4gIGlmIChERUJVRyAmJiBwYXRoWzBdID09PSAnQCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQga2V5cGF0aDogJyR7cGF0aH0nLCB2YWxpZCBrZXlzOiBAaW5kZXgsIEBpZGVudGl0eSwgb3IgYSBwYXRoYCk7XG4gIH1cbiAgcmV0dXJuIHVuaXF1ZUtleUZvcigoaXRlbSkgPT4gZ2V0UGF0aChpdGVtIGFzIG9iamVjdCwgcGF0aCkpO1xufVxuXG5mdW5jdGlvbiBtYWtlS2V5Rm9yKGtleTogc3RyaW5nKSB7XG4gIHN3aXRjaCAoa2V5KSB7XG4gICAgY2FzZSAnQGtleSc6XG4gICAgICByZXR1cm4gdW5pcXVlS2V5Rm9yKEtFWSk7XG4gICAgY2FzZSAnQGluZGV4JzpcbiAgICAgIHJldHVybiB1bmlxdWVLZXlGb3IoSU5ERVgpO1xuICAgIGNhc2UgJ0BpZGVudGl0eSc6XG4gICAgICByZXR1cm4gdW5pcXVlS2V5Rm9yKElERU5USVRZKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGtleUZvclBhdGgoa2V5KTtcbiAgfVxufVxuXG5jbGFzcyBXZWFrTWFwV2l0aFByaW1pdGl2ZXM8VD4ge1xuICBwcml2YXRlIF93ZWFrTWFwPzogV2Vha01hcDxvYmplY3QsIFQ+O1xuICBwcml2YXRlIF9wcmltaXRpdmVNYXA/OiBNYXA8dW5rbm93biwgVD47XG5cbiAgcHJpdmF0ZSBnZXQgd2Vha01hcCgpIHtcbiAgICBpZiAodGhpcy5fd2Vha01hcCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl93ZWFrTWFwID0gbmV3IFdlYWtNYXAoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fd2Vha01hcDtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0IHByaW1pdGl2ZU1hcCgpIHtcbiAgICBpZiAodGhpcy5fcHJpbWl0aXZlTWFwID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX3ByaW1pdGl2ZU1hcCA9IG5ldyBNYXAoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcHJpbWl0aXZlTWFwO1xuICB9XG5cbiAgc2V0KGtleTogdW5rbm93biwgdmFsdWU6IFQpIHtcbiAgICBpZiAoaXNPYmplY3Qoa2V5KSB8fCB0eXBlb2Yga2V5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLndlYWtNYXAuc2V0KGtleSBhcyBvYmplY3QsIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wcmltaXRpdmVNYXAuc2V0KGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIGdldChrZXk6IHVua25vd24pOiBUIHwgdW5kZWZpbmVkIHtcbiAgICBpZiAoaXNPYmplY3Qoa2V5KSB8fCB0eXBlb2Yga2V5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gdGhpcy53ZWFrTWFwLmdldChrZXkgYXMgb2JqZWN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMucHJpbWl0aXZlTWFwLmdldChrZXkpO1xuICAgIH1cbiAgfVxufVxuXG5jb25zdCBJREVOVElUSUVTID0gbmV3IFdlYWtNYXBXaXRoUHJpbWl0aXZlczxvYmplY3RbXT4oKTtcblxuZnVuY3Rpb24gaWRlbnRpdHlGb3JOdGhPY2N1cmVuY2UodmFsdWU6IGFueSwgY291bnQ6IG51bWJlcikge1xuICBsZXQgaWRlbnRpdGllcyA9IElERU5USVRJRVMuZ2V0KHZhbHVlKTtcblxuICBpZiAoaWRlbnRpdGllcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWRlbnRpdGllcyA9IFtdO1xuICAgIElERU5USVRJRVMuc2V0KHZhbHVlLCBpZGVudGl0aWVzKTtcbiAgfVxuXG4gIGxldCBpZGVudGl0eSA9IGlkZW50aXRpZXNbY291bnRdO1xuXG4gIGlmIChpZGVudGl0eSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWRlbnRpdHkgPSB7IHZhbHVlLCBjb3VudCB9O1xuICAgIGlkZW50aXRpZXNbY291bnRdID0gaWRlbnRpdHk7XG4gIH1cblxuICByZXR1cm4gaWRlbnRpdHk7XG59XG5cbi8qKlxuICogV2hlbiBpdGVyYXRpbmcgb3ZlciBhIGxpc3QsIGl0J3MgcG9zc2libGUgdGhhdCBhbiBpdGVtIHdpdGggdGhlIHNhbWUgdW5pcXVlXG4gKiBrZXkgY291bGQgYmUgZW5jb3VudGVyZWQgdHdpY2U6XG4gKlxuICogYGBganNcbiAqIGxldCBhcnIgPSBbJ3NhbWUnLCAnZGlmZmVyZW50JywgJ3NhbWUnLCAnc2FtZSddO1xuICogYGBgXG4gKlxuICogSW4gZ2VuZXJhbCwgd2Ugd2FudCB0byB0cmVhdCB0aGVzZSBpdGVtcyBhcyBfdW5pcXVlIHdpdGhpbiB0aGUgbGlzdF8uIFRvIGRvXG4gKiB0aGlzLCB3ZSB0cmFjayB0aGUgb2NjdXJlbmNlcyBvZiBldmVyeSBpdGVtIGFzIHdlIGl0ZXJhdGUgdGhlIGxpc3QsIGFuZCB3aGVuXG4gKiBhbiBpdGVtIG9jY3VycyBtb3JlIHRoYW4gb25jZSwgd2UgZ2VuZXJhdGUgYSBuZXcgdW5pcXVlIGtleSBqdXN0IGZvciB0aGF0XG4gKiBpdGVtLCBhbmQgdGhhdCBvY2N1cmVuY2Ugd2l0aGluIHRoZSBsaXN0LiBUaGUgbmV4dCB0aW1lIHdlIGl0ZXJhdGUgdGhlIGxpc3QsXG4gKiBhbmQgZW5jb3VudGVyIGFuIGl0ZW0gZm9yIHRoZSBudGggdGltZSwgd2UgY2FuIGdldCB0aGUgX3NhbWVfIGtleSwgYW5kIGxldFxuICogR2xpbW1lciBrbm93IHRoYXQgaXQgc2hvdWxkIHJldXNlIHRoZSBET00gZm9yIHRoZSBwcmV2aW91cyBudGggb2NjdXJlbmNlLlxuICovXG5mdW5jdGlvbiB1bmlxdWVLZXlGb3Ioa2V5Rm9yOiBLZXlGb3IpIHtcbiAgbGV0IHNlZW4gPSBuZXcgV2Vha01hcFdpdGhQcmltaXRpdmVzPG51bWJlcj4oKTtcblxuICByZXR1cm4gKHZhbHVlOiB1bmtub3duLCBtZW1vOiB1bmtub3duKSA9PiB7XG4gICAgbGV0IGtleSA9IGtleUZvcih2YWx1ZSwgbWVtbyk7XG4gICAgbGV0IGNvdW50ID0gc2Vlbi5nZXQoa2V5KSB8fCAwO1xuXG4gICAgc2Vlbi5zZXQoa2V5LCBjb3VudCArIDEpO1xuXG4gICAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH1cblxuICAgIHJldHVybiBpZGVudGl0eUZvck50aE9jY3VyZW5jZShrZXksIGNvdW50KTtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUl0ZXJhdG9yUmVmKGxpc3RSZWY6IFJlZmVyZW5jZSwga2V5OiBzdHJpbmcpIHtcbiAgcmV0dXJuIGNyZWF0ZUNvbXB1dGVSZWYoKCkgPT4ge1xuICAgIGxldCBpdGVyYWJsZSA9IHZhbHVlRm9yUmVmKGxpc3RSZWYpIGFzIHsgW1N5bWJvbC5pdGVyYXRvcl06IGFueSB9IHwgbnVsbCB8IGZhbHNlO1xuXG4gICAgbGV0IGtleUZvciA9IG1ha2VLZXlGb3Ioa2V5KTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZXJhYmxlKSkge1xuICAgICAgcmV0dXJuIG5ldyBBcnJheUl0ZXJhdG9yKGl0ZXJhYmxlLCBrZXlGb3IpO1xuICAgIH1cblxuICAgIGxldCBtYXliZUl0ZXJhdG9yID0gdG9JdGVyYXRvcihpdGVyYWJsZSk7XG5cbiAgICBpZiAobWF5YmVJdGVyYXRvciA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG5ldyBBcnJheUl0ZXJhdG9yKEVNUFRZX0FSUkFZLCAoKSA9PiBudWxsKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEl0ZXJhdG9yV3JhcHBlcihtYXliZUl0ZXJhdG9yLCBrZXlGb3IpO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUl0ZXJhdG9ySXRlbVJlZihfdmFsdWU6IHVua25vd24pIHtcbiAgbGV0IHZhbHVlID0gX3ZhbHVlO1xuICBsZXQgdGFnID0gY3JlYXRlVGFnKCk7XG5cbiAgcmV0dXJuIGNyZWF0ZUNvbXB1dGVSZWYoXG4gICAgKCkgPT4ge1xuICAgICAgY29uc3VtZVRhZyh0YWcpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgKG5ld1ZhbHVlKSA9PiB7XG4gICAgICBpZiAodmFsdWUgIT09IG5ld1ZhbHVlKSB7XG4gICAgICAgIHZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgIGRpcnR5VGFnKHRhZyk7XG4gICAgICB9XG4gICAgfVxuICApO1xufVxuXG5jbGFzcyBJdGVyYXRvcldyYXBwZXIgaW1wbGVtZW50cyBPcGFxdWVJdGVyYXRvciB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgaW5uZXI6IEl0ZXJhdG9yRGVsZWdhdGUsIHByaXZhdGUga2V5Rm9yOiBLZXlGb3IpIHt9XG5cbiAgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5pbm5lci5pc0VtcHR5KCk7XG4gIH1cblxuICBuZXh0KCkge1xuICAgIGxldCBuZXh0VmFsdWUgPSB0aGlzLmlubmVyLm5leHQoKSBhcyBPcGFxdWVJdGVyYXRpb25JdGVtO1xuXG4gICAgaWYgKG5leHRWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgbmV4dFZhbHVlLmtleSA9IHRoaXMua2V5Rm9yKG5leHRWYWx1ZS52YWx1ZSwgbmV4dFZhbHVlLm1lbW8pO1xuICAgIH1cblxuICAgIHJldHVybiBuZXh0VmFsdWU7XG4gIH1cbn1cblxuY2xhc3MgQXJyYXlJdGVyYXRvciBpbXBsZW1lbnRzIE9wYXF1ZUl0ZXJhdG9yIHtcbiAgcHJpdmF0ZSBjdXJyZW50OiB7IGtpbmQ6ICdlbXB0eScgfSB8IHsga2luZDogJ2ZpcnN0JzsgdmFsdWU6IHVua25vd24gfSB8IHsga2luZDogJ3Byb2dyZXNzJyB9O1xuICBwcml2YXRlIHBvcyA9IDA7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBpdGVyYXRvcjogdW5rbm93bltdLCBwcml2YXRlIGtleUZvcjogS2V5Rm9yKSB7XG4gICAgaWYgKGl0ZXJhdG9yLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5jdXJyZW50ID0geyBraW5kOiAnZW1wdHknIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY3VycmVudCA9IHsga2luZDogJ2ZpcnN0JywgdmFsdWU6IGl0ZXJhdG9yW3RoaXMucG9zXSB9O1xuICAgIH1cbiAgfVxuXG4gIGlzRW1wdHkoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudC5raW5kID09PSAnZW1wdHknO1xuICB9XG5cbiAgbmV4dCgpOiBPcHRpb248SXRlcmF0aW9uSXRlbTx1bmtub3duLCBudW1iZXI+PiB7XG4gICAgbGV0IHZhbHVlOiB1bmtub3duO1xuXG4gICAgbGV0IGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgaWYgKGN1cnJlbnQua2luZCA9PT0gJ2ZpcnN0Jykge1xuICAgICAgdGhpcy5jdXJyZW50ID0geyBraW5kOiAncHJvZ3Jlc3MnIH07XG4gICAgICB2YWx1ZSA9IGN1cnJlbnQudmFsdWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLnBvcyA+PSB0aGlzLml0ZXJhdG9yLmxlbmd0aCAtIDEpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IHRoaXMuaXRlcmF0b3JbKyt0aGlzLnBvc107XG4gICAgfVxuXG4gICAgbGV0IHsga2V5Rm9yIH0gPSB0aGlzO1xuXG4gICAgbGV0IGtleSA9IGtleUZvcih2YWx1ZSBhcyBEaWN0LCB0aGlzLnBvcyk7XG4gICAgbGV0IG1lbW8gPSB0aGlzLnBvcztcblxuICAgIHJldHVybiB7IGtleSwgdmFsdWUsIG1lbW8gfTtcbiAgfVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==