'use strict';
var fs = require("fs");
var MatcherCollection = require("matcher-collection");
var ensurePosix = require("ensure-posix-path");
var path = require("path");
function walkSync(baseDir, inputOptions) {
    var options = handleOptions(inputOptions);
    var mapFunct;
    if (options.includeBasePath) {
        mapFunct = function (entry) {
            return entry.basePath.split(path.sep).join('/') + '/' + entry.relativePath;
        };
    }
    else {
        mapFunct = function (entry) {
            return entry.relativePath;
        };
    }
    return _walkSync(baseDir, options, null, []).map(mapFunct);
}
function getStat(path) {
    try {
        return fs.statSync(path);
    }
    catch (error) {
        if (error !== null && typeof error === 'object' && (error.code === 'ENOENT' || error.code === 'ENOTDIR')) {
            return;
        }
        throw error;
    }
}
(function (walkSync) {
    function entries(baseDir, inputOptions) {
        var options = handleOptions(inputOptions);
        return _walkSync(ensurePosix(baseDir), options, null, []);
    }
    walkSync.entries = entries;
    ;
    var Entry = /** @class */ (function () {
        function Entry(relativePath, basePath, mode, size, mtime) {
            this.relativePath = relativePath;
            this.basePath = basePath;
            this.mode = mode;
            this.size = size;
            this.mtime = mtime;
        }
        Object.defineProperty(Entry.prototype, "fullPath", {
            get: function () {
                return this.basePath + "/" + this.relativePath;
            },
            enumerable: true,
            configurable: true
        });
        Entry.prototype.isDirectory = function () {
            return (this.mode & 61440) === 16384;
        };
        return Entry;
    }());
    walkSync.Entry = Entry;
})(walkSync || (walkSync = {}));
function isDefined(val) {
    return typeof val !== 'undefined';
}
function handleOptions(_options) {
    var options = {};
    if (Array.isArray(_options)) {
        options.globs = _options;
    }
    else if (_options) {
        options = _options;
    }
    return options;
}
function handleRelativePath(_relativePath) {
    if (_relativePath == null) {
        return '';
    }
    else if (_relativePath.slice(-1) !== '/') {
        return _relativePath + '/';
    }
    else {
        return _relativePath;
    }
}
function lexicographically(a, b) {
    var aPath = a.relativePath;
    var bPath = b.relativePath;
    if (aPath === bPath) {
        return 0;
    }
    else if (aPath < bPath) {
        return -1;
    }
    else {
        return 1;
    }
}
function _walkSync(baseDir, options, _relativePath, visited) {
    // Inside this function, prefer string concatenation to the slower path.join
    // https://github.com/joyent/node/pull/6929
    var relativePath = handleRelativePath(_relativePath);
    var realPath = fs.realpathSync(baseDir + '/' + relativePath);
    if (visited.indexOf(realPath) >= 0) {
        return [];
    }
    else {
        visited.push(realPath);
    }
    try {
        var globs = options.globs;
        var ignorePatterns = options.ignore;
        var globMatcher = void 0;
        var ignoreMatcher_1;
        var results = [];
        if (ignorePatterns) {
            ignoreMatcher_1 = new MatcherCollection(ignorePatterns);
        }
        if (globs) {
            globMatcher = new MatcherCollection(globs);
        }
        if (globMatcher && !globMatcher.mayContain(relativePath)) {
            return results;
        }
        var names = fs.readdirSync(baseDir + '/' + relativePath);
        var entries = names.map(function (name) {
            var entryRelativePath = relativePath + name;
            if (ignoreMatcher_1 && ignoreMatcher_1.match(entryRelativePath)) {
                return;
            }
            var fullPath = baseDir + '/' + entryRelativePath;
            var stats = getStat(fullPath);
            if (stats && stats.isDirectory()) {
                return new walkSync.Entry(entryRelativePath + '/', baseDir, stats.mode, stats.size, stats.mtime.getTime());
            }
            else {
                return new walkSync.Entry(entryRelativePath, baseDir, stats && stats.mode || 0, stats && stats.size || 0, stats && stats.mtime.getTime() || 0);
            }
        }).filter(isDefined);
        var sortedEntries = entries.sort(lexicographically);
        for (var i = 0; i < sortedEntries.length; ++i) {
            var entry = sortedEntries[i];
            if (entry.isDirectory()) {
                if (options.directories !== false && (!globMatcher || globMatcher.match(entry.relativePath))) {
                    results.push(entry);
                }
                results = results.concat(_walkSync(baseDir, options, entry.relativePath, visited));
            }
            else {
                if (!globMatcher || globMatcher.match(entry.relativePath)) {
                    results.push(entry);
                }
            }
        }
        return results;
    }
    finally {
        visited.pop();
    }
}
module.exports = walkSync;
