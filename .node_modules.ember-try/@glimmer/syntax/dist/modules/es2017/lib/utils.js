import SyntaxError from './errors/syntax-error'; // Regex to validate the identifier for block parameters.
// Based on the ID validation regex in Handlebars.

let ID_INVERSE_PATTERN = /[!"#%-,\.\/;->@\[-\^`\{-~]/; // Checks the element's attributes to see if it uses block params.
// If it does, registers the block params with the program and
// removes the corresponding attributes from the element.

export function parseElementBlockParams(element) {
  let params = parseBlockParams(element);
  if (params) element.blockParams = params;
}

function parseBlockParams(element) {
  let l = element.attributes.length;
  let attrNames = [];

  for (let i = 0; i < l; i++) {
    attrNames.push(element.attributes[i].name);
  }

  let asIndex = attrNames.indexOf('as');

  if (asIndex !== -1 && l > asIndex && attrNames[asIndex + 1].charAt(0) === '|') {
    // Some basic validation, since we're doing the parsing ourselves
    let paramsString = attrNames.slice(asIndex).join(' ');

    if (paramsString.charAt(paramsString.length - 1) !== '|' || paramsString.match(/\|/g).length !== 2) {
      throw new SyntaxError("Invalid block parameters syntax: '" + paramsString + "'", element.loc);
    }

    let params = [];

    for (let i = asIndex + 1; i < l; i++) {
      let param = attrNames[i].replace(/\|/g, '');

      if (param !== '') {
        if (ID_INVERSE_PATTERN.test(param)) {
          throw new SyntaxError("Invalid identifier for block parameters: '" + param + "' in '" + paramsString + "'", element.loc);
        }

        params.push(param);
      }
    }

    if (params.length === 0) {
      throw new SyntaxError("Cannot use zero block parameters: '" + paramsString + "'", element.loc);
    }

    element.attributes = element.attributes.slice(0, asIndex);
    return params;
  }

  return null;
}

export function childrenFor(node) {
  switch (node.type) {
    case 'Block':
    case 'Template':
      return node.body;

    case 'ElementNode':
      return node.children;
  }
}
export function appendChild(parent, node) {
  childrenFor(parent).push(node);
}
export function isLiteral(path) {
  return path.type === 'StringLiteral' || path.type === 'BooleanLiteral' || path.type === 'NumberLiteral' || path.type === 'NullLiteral' || path.type === 'UndefinedLiteral';
}
export function printLiteral(literal) {
  if (literal.type === 'UndefinedLiteral') {
    return 'undefined';
  } else {
    return JSON.stringify(literal.value);
  }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3N5bnRheC9saWIvdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBR0EsT0FBTyxXQUFQLE1BQXdCLHVCQUF4QixDLENBRUE7QUFDQTs7QUFFQSxJQUFJLGtCQUFrQixHQUFHLDRCQUF6QixDLENBRUE7QUFDQTtBQUNBOztBQUVBLE9BQU0sU0FBVSx1QkFBVixDQUFrQyxPQUFsQyxFQUEwRDtBQUM5RCxNQUFJLE1BQU0sR0FBRyxnQkFBZ0IsQ0FBQyxPQUFELENBQTdCO0FBQ0EsTUFBSSxNQUFKLEVBQVksT0FBTyxDQUFDLFdBQVIsR0FBc0IsTUFBdEI7QUFDYjs7QUFFRCxTQUFTLGdCQUFULENBQTBCLE9BQTFCLEVBQWtEO0FBQ2hELE1BQUksQ0FBQyxHQUFHLE9BQU8sQ0FBQyxVQUFSLENBQW1CLE1BQTNCO0FBQ0EsTUFBSSxTQUFTLEdBQUcsRUFBaEI7O0FBRUEsT0FBSyxJQUFJLENBQUMsR0FBRyxDQUFiLEVBQWdCLENBQUMsR0FBRyxDQUFwQixFQUF1QixDQUFDLEVBQXhCLEVBQTRCO0FBQzFCLElBQUEsU0FBUyxDQUFDLElBQVYsQ0FBZSxPQUFPLENBQUMsVUFBUixDQUFtQixDQUFuQixFQUFzQixJQUFyQztBQUNEOztBQUVELE1BQUksT0FBTyxHQUFHLFNBQVMsQ0FBQyxPQUFWLENBQWtCLElBQWxCLENBQWQ7O0FBRUEsTUFBSSxPQUFPLEtBQUssQ0FBQyxDQUFiLElBQWtCLENBQUMsR0FBRyxPQUF0QixJQUFpQyxTQUFTLENBQUMsT0FBTyxHQUFHLENBQVgsQ0FBVCxDQUF1QixNQUF2QixDQUE4QixDQUE5QixNQUFxQyxHQUExRSxFQUErRTtBQUM3RTtBQUNBLFFBQUksWUFBWSxHQUFHLFNBQVMsQ0FBQyxLQUFWLENBQWdCLE9BQWhCLEVBQXlCLElBQXpCLENBQThCLEdBQTlCLENBQW5COztBQUNBLFFBQ0UsWUFBWSxDQUFDLE1BQWIsQ0FBb0IsWUFBWSxDQUFDLE1BQWIsR0FBc0IsQ0FBMUMsTUFBaUQsR0FBakQsSUFDQSxZQUFZLENBQUMsS0FBYixDQUFtQixLQUFuQixFQUEyQixNQUEzQixLQUFzQyxDQUZ4QyxFQUdFO0FBQ0EsWUFBTSxJQUFJLFdBQUosQ0FBZ0IsdUNBQXVDLFlBQXZDLEdBQXNELEdBQXRFLEVBQTJFLE9BQU8sQ0FBQyxHQUFuRixDQUFOO0FBQ0Q7O0FBRUQsUUFBSSxNQUFNLEdBQUcsRUFBYjs7QUFDQSxTQUFLLElBQUksQ0FBQyxHQUFHLE9BQU8sR0FBRyxDQUF2QixFQUEwQixDQUFDLEdBQUcsQ0FBOUIsRUFBaUMsQ0FBQyxFQUFsQyxFQUFzQztBQUNwQyxVQUFJLEtBQUssR0FBRyxTQUFTLENBQUMsQ0FBRCxDQUFULENBQWEsT0FBYixDQUFxQixLQUFyQixFQUE0QixFQUE1QixDQUFaOztBQUNBLFVBQUksS0FBSyxLQUFLLEVBQWQsRUFBa0I7QUFDaEIsWUFBSSxrQkFBa0IsQ0FBQyxJQUFuQixDQUF3QixLQUF4QixDQUFKLEVBQW9DO0FBQ2xDLGdCQUFNLElBQUksV0FBSixDQUNKLCtDQUErQyxLQUEvQyxHQUF1RCxRQUF2RCxHQUFrRSxZQUFsRSxHQUFpRixHQUQ3RSxFQUVKLE9BQU8sQ0FBQyxHQUZKLENBQU47QUFJRDs7QUFDRCxRQUFBLE1BQU0sQ0FBQyxJQUFQLENBQVksS0FBWjtBQUNEO0FBQ0Y7O0FBRUQsUUFBSSxNQUFNLENBQUMsTUFBUCxLQUFrQixDQUF0QixFQUF5QjtBQUN2QixZQUFNLElBQUksV0FBSixDQUNKLHdDQUF3QyxZQUF4QyxHQUF1RCxHQURuRCxFQUVKLE9BQU8sQ0FBQyxHQUZKLENBQU47QUFJRDs7QUFFRCxJQUFBLE9BQU8sQ0FBQyxVQUFSLEdBQXFCLE9BQU8sQ0FBQyxVQUFSLENBQW1CLEtBQW5CLENBQXlCLENBQXpCLEVBQTRCLE9BQTVCLENBQXJCO0FBQ0EsV0FBTyxNQUFQO0FBQ0Q7O0FBRUQsU0FBTyxJQUFQO0FBQ0Q7O0FBRUQsT0FBTSxTQUFVLFdBQVYsQ0FDSixJQURJLEVBQzRDO0FBRWhELFVBQVEsSUFBSSxDQUFDLElBQWI7QUFDRSxTQUFLLE9BQUw7QUFDQSxTQUFLLFVBQUw7QUFDRSxhQUFPLElBQUksQ0FBQyxJQUFaOztBQUNGLFNBQUssYUFBTDtBQUNFLGFBQU8sSUFBSSxDQUFDLFFBQVo7QUFMSjtBQU9EO0FBRUQsT0FBTSxTQUFVLFdBQVYsQ0FDSixNQURJLEVBRUosSUFGSSxFQUVlO0FBRW5CLEVBQUEsV0FBVyxDQUFDLE1BQUQsQ0FBWCxDQUFvQixJQUFwQixDQUF5QixJQUF6QjtBQUNEO0FBSUQsT0FBTSxTQUFVLFNBQVYsQ0FDSixJQURJLEVBQ2lDO0FBRXJDLFNBQ0UsSUFBSSxDQUFDLElBQUwsS0FBYyxlQUFkLElBQ0EsSUFBSSxDQUFDLElBQUwsS0FBYyxnQkFEZCxJQUVBLElBQUksQ0FBQyxJQUFMLEtBQWMsZUFGZCxJQUdBLElBQUksQ0FBQyxJQUFMLEtBQWMsYUFIZCxJQUlBLElBQUksQ0FBQyxJQUFMLEtBQWMsa0JBTGhCO0FBT0Q7QUFFRCxPQUFNLFNBQVUsWUFBVixDQUF1QixPQUF2QixFQUEyQztBQUMvQyxNQUFJLE9BQU8sQ0FBQyxJQUFSLEtBQWlCLGtCQUFyQixFQUF5QztBQUN2QyxXQUFPLFdBQVA7QUFDRCxHQUZELE1BRU87QUFDTCxXQUFPLElBQUksQ0FBQyxTQUFMLENBQWUsT0FBTyxDQUFDLEtBQXZCLENBQVA7QUFDRDtBQUNGIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQVNUIGZyb20gJy4vdHlwZXMvbm9kZXMnO1xuaW1wb3J0ICogYXMgSEJTIGZyb20gJy4vdHlwZXMvaGFuZGxlYmFycy1hc3QnO1xuaW1wb3J0IHsgT3B0aW9uIH0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgU3ludGF4RXJyb3IgZnJvbSAnLi9lcnJvcnMvc3ludGF4LWVycm9yJztcblxuLy8gUmVnZXggdG8gdmFsaWRhdGUgdGhlIGlkZW50aWZpZXIgZm9yIGJsb2NrIHBhcmFtZXRlcnMuXG4vLyBCYXNlZCBvbiB0aGUgSUQgdmFsaWRhdGlvbiByZWdleCBpbiBIYW5kbGViYXJzLlxuXG5sZXQgSURfSU5WRVJTRV9QQVRURVJOID0gL1shXCIjJS0sXFwuXFwvOy0+QFxcWy1cXF5gXFx7LX5dLztcblxuLy8gQ2hlY2tzIHRoZSBlbGVtZW50J3MgYXR0cmlidXRlcyB0byBzZWUgaWYgaXQgdXNlcyBibG9jayBwYXJhbXMuXG4vLyBJZiBpdCBkb2VzLCByZWdpc3RlcnMgdGhlIGJsb2NrIHBhcmFtcyB3aXRoIHRoZSBwcm9ncmFtIGFuZFxuLy8gcmVtb3ZlcyB0aGUgY29ycmVzcG9uZGluZyBhdHRyaWJ1dGVzIGZyb20gdGhlIGVsZW1lbnQuXG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUVsZW1lbnRCbG9ja1BhcmFtcyhlbGVtZW50OiBBU1QuRWxlbWVudE5vZGUpIHtcbiAgbGV0IHBhcmFtcyA9IHBhcnNlQmxvY2tQYXJhbXMoZWxlbWVudCk7XG4gIGlmIChwYXJhbXMpIGVsZW1lbnQuYmxvY2tQYXJhbXMgPSBwYXJhbXM7XG59XG5cbmZ1bmN0aW9uIHBhcnNlQmxvY2tQYXJhbXMoZWxlbWVudDogQVNULkVsZW1lbnROb2RlKTogT3B0aW9uPHN0cmluZ1tdPiB7XG4gIGxldCBsID0gZWxlbWVudC5hdHRyaWJ1dGVzLmxlbmd0aDtcbiAgbGV0IGF0dHJOYW1lcyA9IFtdO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgYXR0ck5hbWVzLnB1c2goZWxlbWVudC5hdHRyaWJ1dGVzW2ldLm5hbWUpO1xuICB9XG5cbiAgbGV0IGFzSW5kZXggPSBhdHRyTmFtZXMuaW5kZXhPZignYXMnKTtcblxuICBpZiAoYXNJbmRleCAhPT0gLTEgJiYgbCA+IGFzSW5kZXggJiYgYXR0ck5hbWVzW2FzSW5kZXggKyAxXS5jaGFyQXQoMCkgPT09ICd8Jykge1xuICAgIC8vIFNvbWUgYmFzaWMgdmFsaWRhdGlvbiwgc2luY2Ugd2UncmUgZG9pbmcgdGhlIHBhcnNpbmcgb3Vyc2VsdmVzXG4gICAgbGV0IHBhcmFtc1N0cmluZyA9IGF0dHJOYW1lcy5zbGljZShhc0luZGV4KS5qb2luKCcgJyk7XG4gICAgaWYgKFxuICAgICAgcGFyYW1zU3RyaW5nLmNoYXJBdChwYXJhbXNTdHJpbmcubGVuZ3RoIC0gMSkgIT09ICd8JyB8fFxuICAgICAgcGFyYW1zU3RyaW5nLm1hdGNoKC9cXHwvZykhLmxlbmd0aCAhPT0gMlxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiSW52YWxpZCBibG9jayBwYXJhbWV0ZXJzIHN5bnRheDogJ1wiICsgcGFyYW1zU3RyaW5nICsgXCInXCIsIGVsZW1lbnQubG9jKTtcbiAgICB9XG5cbiAgICBsZXQgcGFyYW1zID0gW107XG4gICAgZm9yIChsZXQgaSA9IGFzSW5kZXggKyAxOyBpIDwgbDsgaSsrKSB7XG4gICAgICBsZXQgcGFyYW0gPSBhdHRyTmFtZXNbaV0ucmVwbGFjZSgvXFx8L2csICcnKTtcbiAgICAgIGlmIChwYXJhbSAhPT0gJycpIHtcbiAgICAgICAgaWYgKElEX0lOVkVSU0VfUEFUVEVSTi50ZXN0KHBhcmFtKSkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcbiAgICAgICAgICAgIFwiSW52YWxpZCBpZGVudGlmaWVyIGZvciBibG9jayBwYXJhbWV0ZXJzOiAnXCIgKyBwYXJhbSArIFwiJyBpbiAnXCIgKyBwYXJhbXNTdHJpbmcgKyBcIidcIixcbiAgICAgICAgICAgIGVsZW1lbnQubG9jXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJhbXMucHVzaChwYXJhbSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBhcmFtcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcbiAgICAgICAgXCJDYW5ub3QgdXNlIHplcm8gYmxvY2sgcGFyYW1ldGVyczogJ1wiICsgcGFyYW1zU3RyaW5nICsgXCInXCIsXG4gICAgICAgIGVsZW1lbnQubG9jXG4gICAgICApO1xuICAgIH1cblxuICAgIGVsZW1lbnQuYXR0cmlidXRlcyA9IGVsZW1lbnQuYXR0cmlidXRlcy5zbGljZSgwLCBhc0luZGV4KTtcbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGlsZHJlbkZvcihcbiAgbm9kZTogQVNULkJsb2NrIHwgQVNULlRlbXBsYXRlIHwgQVNULkVsZW1lbnROb2RlXG4pOiBBU1QuVG9wTGV2ZWxTdGF0ZW1lbnRbXSB7XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSAnQmxvY2snOlxuICAgIGNhc2UgJ1RlbXBsYXRlJzpcbiAgICAgIHJldHVybiBub2RlLmJvZHk7XG4gICAgY2FzZSAnRWxlbWVudE5vZGUnOlxuICAgICAgcmV0dXJuIG5vZGUuY2hpbGRyZW47XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGVuZENoaWxkKFxuICBwYXJlbnQ6IEFTVC5CbG9jayB8IEFTVC5UZW1wbGF0ZSB8IEFTVC5FbGVtZW50Tm9kZSxcbiAgbm9kZTogQVNULlN0YXRlbWVudFxuKSB7XG4gIGNoaWxkcmVuRm9yKHBhcmVudCkucHVzaChub2RlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzTGl0ZXJhbChwYXRoOiBIQlMuRXhwcmVzc2lvbik6IHBhdGggaXMgSEJTLkxpdGVyYWw7XG5leHBvcnQgZnVuY3Rpb24gaXNMaXRlcmFsKHBhdGg6IEFTVC5FeHByZXNzaW9uKTogcGF0aCBpcyBBU1QuTGl0ZXJhbDtcbmV4cG9ydCBmdW5jdGlvbiBpc0xpdGVyYWwoXG4gIHBhdGg6IEhCUy5FeHByZXNzaW9uIHwgQVNULkV4cHJlc3Npb25cbik6IHBhdGggaXMgSEJTLkxpdGVyYWwgfCBBU1QuTGl0ZXJhbCB7XG4gIHJldHVybiAoXG4gICAgcGF0aC50eXBlID09PSAnU3RyaW5nTGl0ZXJhbCcgfHxcbiAgICBwYXRoLnR5cGUgPT09ICdCb29sZWFuTGl0ZXJhbCcgfHxcbiAgICBwYXRoLnR5cGUgPT09ICdOdW1iZXJMaXRlcmFsJyB8fFxuICAgIHBhdGgudHlwZSA9PT0gJ051bGxMaXRlcmFsJyB8fFxuICAgIHBhdGgudHlwZSA9PT0gJ1VuZGVmaW5lZExpdGVyYWwnXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcmludExpdGVyYWwobGl0ZXJhbDogQVNULkxpdGVyYWwpOiBzdHJpbmcge1xuICBpZiAobGl0ZXJhbC50eXBlID09PSAnVW5kZWZpbmVkTGl0ZXJhbCcpIHtcbiAgICByZXR1cm4gJ3VuZGVmaW5lZCc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGxpdGVyYWwudmFsdWUpO1xuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9