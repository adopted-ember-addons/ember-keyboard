'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CURRENT_TAG = exports.VOLATILE_TAG = exports.CONSTANT_TAG = exports.update = exports.dirty = exports.MonomorphicTagImpl = exports.ALLOW_CYCLES = exports.COMPUTE = exports.VOLATILE = exports.INITIAL = exports.CONSTANT = undefined;
exports.bump = bump;
exports.value = value;
exports.validate = validate;
exports.createTag = createTag;
exports.createUpdatableTag = createUpdatableTag;
exports.isConst = isConst;
exports.isConstTag = isConstTag;
exports.combineTagged = combineTagged;
exports.combineSlice = combineSlice;
exports.combine = combine;

var _util = require('@glimmer/util');

const symbol = typeof Symbol !== 'undefined' ? Symbol : key => `__${key}${Math.floor(Math.random() * Date.now())}__`;
const CONSTANT = exports.CONSTANT = 0;
const INITIAL = exports.INITIAL = 1;
const VOLATILE = exports.VOLATILE = 9007199254740991; // MAX_INT
let $REVISION = INITIAL;
function bump() {
    $REVISION++;
}
//////////
const COMPUTE = exports.COMPUTE = symbol('TAG_COMPUTE');
//////////
/**
 * `value` receives a tag and returns an opaque Revision based on that tag. This
 * snapshot can then later be passed to `validate` with the same tag to
 * determine if the tag has changed at all since the time that `value` was
 * called.
 *
 * The current implementation returns the global revision count directly for
 * performance reasons. This is an implementation detail, and should not be
 * relied on directly by users of these APIs. Instead, Revisions should be
 * treated as if they are opaque/unknown, and should only be interacted with via
 * the `value`/`validate` API.
 *
 * @param tag
 */
function value(_tag) {
    return $REVISION;
}
/**
 * `validate` receives a tag and a snapshot from a previous call to `value` with
 * the same tag, and determines if the tag is still valid compared to the
 * snapshot. If the tag's state has changed at all since then, `validate` will
 * return false, otherwise it will return true. This is used to determine if a
 * calculation related to the tags should be rerun.
 *
 * @param tag
 * @param snapshot
 */
function validate(tag, snapshot) {
    return snapshot >= tag[COMPUTE]();
}
const TYPE = symbol('TAG_TYPE');
let ALLOW_CYCLES = exports.ALLOW_CYCLES = undefined;
if (false) {
    exports.ALLOW_CYCLES = ALLOW_CYCLES = new WeakSet();
}
class MonomorphicTagImpl {
    constructor(type) {
        this.revision = INITIAL;
        this.lastChecked = INITIAL;
        this.lastValue = INITIAL;
        this.isUpdating = false;
        this.subtag = null;
        this.subtags = null;
        this[TYPE] = type;
    }
    [COMPUTE]() {
        let { lastChecked } = this;
        if (lastChecked !== $REVISION) {
            this.isUpdating = true;
            this.lastChecked = $REVISION;
            try {
                let { subtags, subtag, revision } = this;
                if (subtag !== null) {
                    revision = Math.max(revision, subtag[COMPUTE]());
                }
                if (subtags !== null) {
                    for (let i = 0; i < subtags.length; i++) {
                        let value = subtags[i][COMPUTE]();
                        revision = Math.max(value, revision);
                    }
                }
                this.lastValue = revision;
            } finally {
                this.isUpdating = false;
            }
        }
        if (this.isUpdating === true) {
            if (false && !ALLOW_CYCLES.has(this)) {
                throw new Error('Cycles in tags are not allowed');
            }
            this.lastChecked = ++$REVISION;
        }
        return this.lastValue;
    }
    static update(_tag, subtag) {
        if (false) {
            false && (0, _util.assert)(_tag[TYPE] === 1 /* Updatable */, 'Attempted to update a tag that was not updatable');
        }
        // TODO: TS 3.7 should allow us to do this via assertion
        let tag = _tag;
        if (subtag === CONSTANT_TAG) {
            tag.subtag = null;
        } else {
            tag.subtag = subtag;
            // subtag could be another type of tag, e.g. CURRENT_TAG or VOLATILE_TAG.
            // If so, lastChecked/lastValue will be undefined, result in these being
            // NaN. This is fine, it will force the system to recompute.
            tag.lastChecked = Math.min(tag.lastChecked, subtag.lastChecked);
            tag.lastValue = Math.max(tag.lastValue, subtag.lastValue);
        }
    }
    static dirty(tag) {
        if (false) {
            false && (0, _util.assert)(tag[TYPE] === 1 /* Updatable */ || tag[TYPE] === 0 /* Dirtyable */, 'Attempted to dirty a tag that was not dirtyable');
        }
        tag.revision = ++$REVISION;
    }
}
exports.MonomorphicTagImpl = MonomorphicTagImpl;
const dirty = exports.dirty = MonomorphicTagImpl.dirty;
const update = exports.update = MonomorphicTagImpl.update;
//////////
function createTag() {
    return new MonomorphicTagImpl(0 /* Dirtyable */);
}
function createUpdatableTag() {
    return new MonomorphicTagImpl(1 /* Updatable */);
}
//////////
const CONSTANT_TAG = exports.CONSTANT_TAG = new MonomorphicTagImpl(3 /* Constant */);
function isConst({ tag }) {
    return tag === CONSTANT_TAG;
}
function isConstTag(tag) {
    return tag === CONSTANT_TAG;
}
//////////
class VolatileTag {
    [COMPUTE]() {
        return VOLATILE;
    }
}
const VOLATILE_TAG = exports.VOLATILE_TAG = new VolatileTag();
//////////
class CurrentTag {
    [COMPUTE]() {
        return $REVISION;
    }
}
const CURRENT_TAG = exports.CURRENT_TAG = new CurrentTag();
//////////
function combineTagged(tagged) {
    let optimized = [];
    for (let i = 0, l = tagged.length; i < l; i++) {
        let tag = tagged[i].tag;
        if (tag === CONSTANT_TAG) continue;
        optimized.push(tag);
    }
    return _combine(optimized);
}
function combineSlice(slice) {
    let optimized = [];
    let node = slice.head();
    while (node !== null) {
        let tag = node.tag;
        if (tag !== CONSTANT_TAG) optimized.push(tag);
        node = slice.nextNode(node);
    }
    return _combine(optimized);
}
function combine(tags) {
    let optimized = [];
    for (let i = 0, l = tags.length; i < l; i++) {
        let tag = tags[i];
        if (tag === CONSTANT_TAG) continue;
        optimized.push(tag);
    }
    return _combine(optimized);
}
function _combine(tags) {
    switch (tags.length) {
        case 0:
            return CONSTANT_TAG;
        case 1:
            return tags[0];
        default:
            let tag = new MonomorphicTagImpl(2 /* Combinator */);
            tag.subtags = tags;
            return tag;
    }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3JlZmVyZW5jZS9saWIvdmFsaWRhdG9ycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7UUEyQk0sSSxHQUFBLEk7UUFzQ0EsSyxHQUFBLEs7UUFjQSxRLEdBQUEsUTtRQTRJQSxTLEdBQUEsUztRQUlBLGtCLEdBQUEsa0I7UUFRQSxPLEdBQUEsTztRQUlBLFUsR0FBQSxVO1FBMEJBLGEsR0FBQSxhO1FBWUEsWSxHQUFBLFk7UUFnQkEsTyxHQUFBLE87Ozs7QUFyUk4sTUFBTSxTQUNKLE9BQUEsTUFBQSxLQUFBLFdBQUEsR0FBQSxNQUFBLEdBRUksT0FBaUIsS0FBSyxHQUFHLEdBQUcsS0FBQSxLQUFBLENBQVcsS0FBQSxNQUFBLEtBQWdCLEtBQTNCLEdBQTJCLEVBQTNCLENBSGxDLElBQUE7QUFTTyxNQUFNLDhCQUFOLENBQUE7QUFDQSxNQUFNLDRCQUFOLENBQUE7QUFDQSxNQUFNLDhCQUFOLGdCQUFBLEMsQ0FBNkM7QUFFcEQsSUFBSSxZQUFKLE9BQUE7QUFFTSxTQUFBLElBQUEsR0FBYztBQUNsQjtBQUNEO0FBRUQ7QUFFTyxNQUFNLDRCQUF5QixPQUEvQixhQUErQixDQUEvQjtBQWdCUDtBQUVBOzs7Ozs7Ozs7Ozs7OztBQWNNLFNBQUEsS0FBQSxDQUFBLElBQUEsRUFBeUI7QUFDN0IsV0FBQSxTQUFBO0FBQ0Q7QUFFRDs7Ozs7Ozs7OztBQVVNLFNBQUEsUUFBQSxDQUFBLEdBQUEsRUFBQSxRQUFBLEVBQStDO0FBQ25ELFdBQU8sWUFBWSxJQUFuQixPQUFtQixHQUFuQjtBQUNEO0FBaUJELE1BQU0sT0FBc0IsT0FBNUIsVUFBNEIsQ0FBNUI7QUFFTyxJQUFBLCtDQUFBO0FBRVAsSUFBQSxLQUFBLEVBQVc7QUFDVCxZQUhLLFlBR0wsa0JBQWUsSUFBZixPQUFlLEVBQWY7QUFDRDtBQXFCSyxNQUFBLGtCQUFBLENBQXlCO0FBVzdCLGdCQUFBLElBQUEsRUFBcUM7QUFWN0IsYUFBQSxR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akMsUUFBSSxZQUFKLEVBQUE7QUFFQSxTQUFLLElBQUksSUFBSixDQUFBLEVBQVcsSUFBSSxLQUFwQixNQUFBLEVBQWlDLElBQWpDLENBQUEsRUFBQSxHQUFBLEVBQTZDO0FBQzNDLFlBQUksTUFBTSxLQUFWLENBQVUsQ0FBVjtBQUNBLFlBQUksUUFBSixZQUFBLEVBQTBCO0FBQzFCLGtCQUFBLElBQUEsQ0FBQSxHQUFBO0FBQ0Q7QUFFRCxXQUFPLFNBQVAsU0FBTyxDQUFQO0FBQ0Q7QUFFRCxTQUFBLFFBQUEsQ0FBQSxJQUFBLEVBQTZCO0FBQzNCLFlBQVEsS0FBUixNQUFBO0FBQ0UsYUFBQSxDQUFBO0FBQ0UsbUJBQUEsWUFBQTtBQUNGLGFBQUEsQ0FBQTtBQUNFLG1CQUFPLEtBQVAsQ0FBTyxDQUFQO0FBQ0Y7QUFDRSxnQkFBSSxNQUFNLElBQUEsa0JBQUEsQ0FBQSxDQUFBLENBQVYsZ0JBQVUsQ0FBVjtBQUNDLGdCQUFBLE9BQUEsR0FBQSxJQUFBO0FBQ0QsbUJBQUEsR0FBQTtBQVJKO0FBVUQiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTbGljZSwgTGlua2VkTGlzdE5vZGUsIGFzc2VydCB9IGZyb20gJ0BnbGltbWVyL3V0aWwnO1xuaW1wb3J0IHsgREVCVUcgfSBmcm9tICdAZ2xpbW1lci9sb2NhbC1kZWJ1Zy1mbGFncyc7XG5cbi8vLy8vLy8vLy9cblxuLy8gdXRpbHNcbnR5cGUgVW5pb25Ub0ludGVyc2VjdGlvbjxVPiA9IChVIGV4dGVuZHMgYW55ID8gKGs6IFUpID0+IHZvaWQgOiBuZXZlcikgZXh0ZW5kcyAoKFxuICBrOiBpbmZlciBJXG4pID0+IHZvaWQpXG4gID8gSVxuICA6IG5ldmVyO1xuXG5jb25zdCBzeW1ib2wgPVxuICB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJ1xuICAgID8gU3ltYm9sXG4gICAgOiAoa2V5OiBzdHJpbmcpID0+IGBfXyR7a2V5fSR7TWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogRGF0ZS5ub3coKSl9X19gIGFzIGFueTtcblxuLy8vLy8vLy8vL1xuXG5leHBvcnQgdHlwZSBSZXZpc2lvbiA9IG51bWJlcjtcblxuZXhwb3J0IGNvbnN0IENPTlNUQU5UOiBSZXZpc2lvbiA9IDA7XG5leHBvcnQgY29uc3QgSU5JVElBTDogUmV2aXNpb24gPSAxO1xuZXhwb3J0IGNvbnN0IFZPTEFUSUxFOiBSZXZpc2lvbiA9IDkwMDcxOTkyNTQ3NDA5OTE7IC8vIE1BWF9JTlRcblxubGV0ICRSRVZJU0lPTiA9IElOSVRJQUw7XG5cbmV4cG9ydCBmdW5jdGlvbiBidW1wKCkge1xuICAkUkVWSVNJT04rKztcbn1cblxuLy8vLy8vLy8vL1xuXG5leHBvcnQgY29uc3QgQ09NUFVURTogdW5pcXVlIHN5bWJvbCA9IHN5bWJvbCgnVEFHX0NPTVBVVEUnKTtcblxuZXhwb3J0IGludGVyZmFjZSBFbnRpdHlUYWc8VD4ge1xuICBbQ09NUFVURV0oKTogVDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUYWcgZXh0ZW5kcyBFbnRpdHlUYWc8UmV2aXNpb24+IHt9XG5cbmV4cG9ydCBpbnRlcmZhY2UgRW50aXR5VGFnZ2VkPFQ+IHtcbiAgdGFnOiBFbnRpdHlUYWc8VD47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGFnZ2VkIHtcbiAgdGFnOiBUYWc7XG59XG5cbi8vLy8vLy8vLy9cblxuLyoqXG4gKiBgdmFsdWVgIHJlY2VpdmVzIGEgdGFnIGFuZCByZXR1cm5zIGFuIG9wYXF1ZSBSZXZpc2lvbiBiYXNlZCBvbiB0aGF0IHRhZy4gVGhpc1xuICogc25hcHNob3QgY2FuIHRoZW4gbGF0ZXIgYmUgcGFzc2VkIHRvIGB2YWxpZGF0ZWAgd2l0aCB0aGUgc2FtZSB0YWcgdG9cbiAqIGRldGVybWluZSBpZiB0aGUgdGFnIGhhcyBjaGFuZ2VkIGF0IGFsbCBzaW5jZSB0aGUgdGltZSB0aGF0IGB2YWx1ZWAgd2FzXG4gKiBjYWxsZWQuXG4gKlxuICogVGhlIGN1cnJlbnQgaW1wbGVtZW50YXRpb24gcmV0dXJucyB0aGUgZ2xvYmFsIHJldmlzaW9uIGNvdW50IGRpcmVjdGx5IGZvclxuICogcGVyZm9ybWFuY2UgcmVhc29ucy4gVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBkZXRhaWwsIGFuZCBzaG91bGQgbm90IGJlXG4gKiByZWxpZWQgb24gZGlyZWN0bHkgYnkgdXNlcnMgb2YgdGhlc2UgQVBJcy4gSW5zdGVhZCwgUmV2aXNpb25zIHNob3VsZCBiZVxuICogdHJlYXRlZCBhcyBpZiB0aGV5IGFyZSBvcGFxdWUvdW5rbm93biwgYW5kIHNob3VsZCBvbmx5IGJlIGludGVyYWN0ZWQgd2l0aCB2aWFcbiAqIHRoZSBgdmFsdWVgL2B2YWxpZGF0ZWAgQVBJLlxuICpcbiAqIEBwYXJhbSB0YWdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbHVlKF90YWc6IFRhZyk6IFJldmlzaW9uIHtcbiAgcmV0dXJuICRSRVZJU0lPTjtcbn1cblxuLyoqXG4gKiBgdmFsaWRhdGVgIHJlY2VpdmVzIGEgdGFnIGFuZCBhIHNuYXBzaG90IGZyb20gYSBwcmV2aW91cyBjYWxsIHRvIGB2YWx1ZWAgd2l0aFxuICogdGhlIHNhbWUgdGFnLCBhbmQgZGV0ZXJtaW5lcyBpZiB0aGUgdGFnIGlzIHN0aWxsIHZhbGlkIGNvbXBhcmVkIHRvIHRoZVxuICogc25hcHNob3QuIElmIHRoZSB0YWcncyBzdGF0ZSBoYXMgY2hhbmdlZCBhdCBhbGwgc2luY2UgdGhlbiwgYHZhbGlkYXRlYCB3aWxsXG4gKiByZXR1cm4gZmFsc2UsIG90aGVyd2lzZSBpdCB3aWxsIHJldHVybiB0cnVlLiBUaGlzIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIGFcbiAqIGNhbGN1bGF0aW9uIHJlbGF0ZWQgdG8gdGhlIHRhZ3Mgc2hvdWxkIGJlIHJlcnVuLlxuICpcbiAqIEBwYXJhbSB0YWdcbiAqIEBwYXJhbSBzbmFwc2hvdFxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGUodGFnOiBUYWcsIHNuYXBzaG90OiBSZXZpc2lvbikge1xuICByZXR1cm4gc25hcHNob3QgPj0gdGFnW0NPTVBVVEVdKCk7XG59XG5cbi8vLy8vLy8vLy9cblxuLyoqXG4gKiBUaGlzIGVudW0gcmVwcmVzZW50cyBhbGwgb2YgdGhlIHBvc3NpYmxlIHRhZyB0eXBlcyBmb3IgdGhlIG1vbm9tb3JwaGljIHRhZyBjbGFzcy5cbiAqIE90aGVyIGN1c3RvbSB0YWcgY2xhc3NlcyBjYW4gZXhpc3QsIHN1Y2ggYXMgQ3VycmVudFRhZyBhbmQgVm9sYXRpbGVUYWcsIGJ1dCBmb3JcbiAqIHBlcmZvcm1hbmNlIHJlYXNvbnMsIGFueSB0eXBlIG9mIHRhZyB0aGF0IGlzIG1lYW50IHRvIGJlIHVzZWQgZnJlcXVlbnRseSBzaG91bGRcbiAqIGJlIGFkZGVkIHRvIHRoZSBtb25vbW9ycGhpYyB0YWcuXG4gKi9cbmNvbnN0IGVudW0gTW9ub21vcnBoaWNUYWdUeXBlcyB7XG4gIERpcnR5YWJsZSxcbiAgVXBkYXRhYmxlLFxuICBDb21iaW5hdG9yLFxuICBDb25zdGFudCxcbn1cblxuY29uc3QgVFlQRTogdW5pcXVlIHN5bWJvbCA9IHN5bWJvbCgnVEFHX1RZUEUnKTtcblxuZXhwb3J0IGxldCBBTExPV19DWUNMRVM6IFdlYWtTZXQ8VXBkYXRhYmxlVGFnPjtcblxuaWYgKERFQlVHKSB7XG4gIEFMTE9XX0NZQ0xFUyA9IG5ldyBXZWFrU2V0KCk7XG59XG5cbmludGVyZmFjZSBNb25vbW9ycGhpY1RhZ0Jhc2U8VCBleHRlbmRzIE1vbm9tb3JwaGljVGFnVHlwZXM+IGV4dGVuZHMgVGFnIHtcbiAgW1RZUEVdOiBUO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERpcnR5YWJsZVRhZyBleHRlbmRzIE1vbm9tb3JwaGljVGFnQmFzZTxNb25vbW9ycGhpY1RhZ1R5cGVzLkRpcnR5YWJsZT4ge31cbmV4cG9ydCBpbnRlcmZhY2UgVXBkYXRhYmxlVGFnIGV4dGVuZHMgTW9ub21vcnBoaWNUYWdCYXNlPE1vbm9tb3JwaGljVGFnVHlwZXMuVXBkYXRhYmxlPiB7fVxuZXhwb3J0IGludGVyZmFjZSBDb21iaW5hdG9yVGFnIGV4dGVuZHMgTW9ub21vcnBoaWNUYWdCYXNlPE1vbm9tb3JwaGljVGFnVHlwZXMuQ29tYmluYXRvcj4ge31cbmV4cG9ydCBpbnRlcmZhY2UgQ29uc3RhbnRUYWcgZXh0ZW5kcyBNb25vbW9ycGhpY1RhZ0Jhc2U8TW9ub21vcnBoaWNUYWdUeXBlcy5Db25zdGFudD4ge31cblxuaW50ZXJmYWNlIE1vbm9tb3JwaGljVGFnTWFwcGluZyB7XG4gIFtNb25vbW9ycGhpY1RhZ1R5cGVzLkRpcnR5YWJsZV06IERpcnR5YWJsZVRhZztcbiAgW01vbm9tb3JwaGljVGFnVHlwZXMuVXBkYXRhYmxlXTogVXBkYXRhYmxlVGFnO1xuICBbTW9ub21vcnBoaWNUYWdUeXBlcy5Db21iaW5hdG9yXTogQ29tYmluYXRvclRhZztcbiAgW01vbm9tb3JwaGljVGFnVHlwZXMuQ29uc3RhbnRdOiBDb25zdGFudFRhZztcbn1cblxudHlwZSBNb25vbW9ycGhpY1RhZyA9IFVuaW9uVG9JbnRlcnNlY3Rpb248TW9ub21vcnBoaWNUYWdNYXBwaW5nW01vbm9tb3JwaGljVGFnVHlwZXNdPjtcbnR5cGUgTW9ub21vcnBoaWNUYWdUeXBlID0gVW5pb25Ub0ludGVyc2VjdGlvbjxNb25vbW9ycGhpY1RhZ1R5cGVzPjtcblxuZXhwb3J0IGNsYXNzIE1vbm9tb3JwaGljVGFnSW1wbCBpbXBsZW1lbnRzIE1vbm9tb3JwaGljVGFnIHtcbiAgcHJpdmF0ZSByZXZpc2lvbiA9IElOSVRJQUw7XG4gIHByaXZhdGUgbGFzdENoZWNrZWQgPSBJTklUSUFMO1xuICBwcml2YXRlIGxhc3RWYWx1ZSA9IElOSVRJQUw7XG5cbiAgcHJpdmF0ZSBpc1VwZGF0aW5nID0gZmFsc2U7XG4gIHByaXZhdGUgc3VidGFnOiBUYWcgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBzdWJ0YWdzOiBUYWdbXSB8IG51bGwgPSBudWxsO1xuXG4gIFtUWVBFXTogTW9ub21vcnBoaWNUYWdUeXBlO1xuXG4gIGNvbnN0cnVjdG9yKHR5cGU6IE1vbm9tb3JwaGljVGFnVHlwZXMpIHtcbiAgICB0aGlzW1RZUEVdID0gdHlwZSBhcyBNb25vbW9ycGhpY1RhZ1R5cGU7XG4gIH1cblxuICBbQ09NUFVURV0oKTogUmV2aXNpb24ge1xuICAgIGxldCB7IGxhc3RDaGVja2VkIH0gPSB0aGlzO1xuXG4gICAgaWYgKGxhc3RDaGVja2VkICE9PSAkUkVWSVNJT04pIHtcbiAgICAgIHRoaXMuaXNVcGRhdGluZyA9IHRydWU7XG4gICAgICB0aGlzLmxhc3RDaGVja2VkID0gJFJFVklTSU9OO1xuXG4gICAgICB0cnkge1xuICAgICAgICBsZXQgeyBzdWJ0YWdzLCBzdWJ0YWcsIHJldmlzaW9uIH0gPSB0aGlzO1xuXG4gICAgICAgIGlmIChzdWJ0YWcgIT09IG51bGwpIHtcbiAgICAgICAgICByZXZpc2lvbiA9IE1hdGgubWF4KHJldmlzaW9uLCBzdWJ0YWdbQ09NUFVURV0oKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3VidGFncyAhPT0gbnVsbCkge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3VidGFncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gc3VidGFnc1tpXVtDT01QVVRFXSgpO1xuICAgICAgICAgICAgcmV2aXNpb24gPSBNYXRoLm1heCh2YWx1ZSwgcmV2aXNpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubGFzdFZhbHVlID0gcmV2aXNpb247XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aGlzLmlzVXBkYXRpbmcgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc1VwZGF0aW5nID09PSB0cnVlKSB7XG4gICAgICBpZiAoREVCVUcgJiYgIUFMTE9XX0NZQ0xFUy5oYXModGhpcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDeWNsZXMgaW4gdGFncyBhcmUgbm90IGFsbG93ZWQnKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5sYXN0Q2hlY2tlZCA9ICsrJFJFVklTSU9OO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmxhc3RWYWx1ZTtcbiAgfVxuXG4gIHN0YXRpYyB1cGRhdGUoX3RhZzogVXBkYXRhYmxlVGFnLCBzdWJ0YWc6IFRhZykge1xuICAgIGlmIChERUJVRykge1xuICAgICAgYXNzZXJ0KFxuICAgICAgICBfdGFnW1RZUEVdID09PSBNb25vbW9ycGhpY1RhZ1R5cGVzLlVwZGF0YWJsZSxcbiAgICAgICAgJ0F0dGVtcHRlZCB0byB1cGRhdGUgYSB0YWcgdGhhdCB3YXMgbm90IHVwZGF0YWJsZSdcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogVFMgMy43IHNob3VsZCBhbGxvdyB1cyB0byBkbyB0aGlzIHZpYSBhc3NlcnRpb25cbiAgICBsZXQgdGFnID0gX3RhZyBhcyBNb25vbW9ycGhpY1RhZ0ltcGw7XG5cbiAgICBpZiAoc3VidGFnID09PSBDT05TVEFOVF9UQUcpIHtcbiAgICAgIHRhZy5zdWJ0YWcgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YWcuc3VidGFnID0gc3VidGFnO1xuXG4gICAgICAvLyBzdWJ0YWcgY291bGQgYmUgYW5vdGhlciB0eXBlIG9mIHRhZywgZS5nLiBDVVJSRU5UX1RBRyBvciBWT0xBVElMRV9UQUcuXG4gICAgICAvLyBJZiBzbywgbGFzdENoZWNrZWQvbGFzdFZhbHVlIHdpbGwgYmUgdW5kZWZpbmVkLCByZXN1bHQgaW4gdGhlc2UgYmVpbmdcbiAgICAgIC8vIE5hTi4gVGhpcyBpcyBmaW5lLCBpdCB3aWxsIGZvcmNlIHRoZSBzeXN0ZW0gdG8gcmVjb21wdXRlLlxuICAgICAgdGFnLmxhc3RDaGVja2VkID0gTWF0aC5taW4odGFnLmxhc3RDaGVja2VkLCAoc3VidGFnIGFzIGFueSkubGFzdENoZWNrZWQpO1xuICAgICAgdGFnLmxhc3RWYWx1ZSA9IE1hdGgubWF4KHRhZy5sYXN0VmFsdWUsIChzdWJ0YWcgYXMgYW55KS5sYXN0VmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBkaXJ0eSh0YWc6IERpcnR5YWJsZVRhZyB8IFVwZGF0YWJsZVRhZykge1xuICAgIGlmIChERUJVRykge1xuICAgICAgYXNzZXJ0KFxuICAgICAgICB0YWdbVFlQRV0gPT09IE1vbm9tb3JwaGljVGFnVHlwZXMuVXBkYXRhYmxlIHx8IHRhZ1tUWVBFXSA9PT0gTW9ub21vcnBoaWNUYWdUeXBlcy5EaXJ0eWFibGUsXG4gICAgICAgICdBdHRlbXB0ZWQgdG8gZGlydHkgYSB0YWcgdGhhdCB3YXMgbm90IGRpcnR5YWJsZSdcbiAgICAgICk7XG4gICAgfVxuXG4gICAgKHRhZyBhcyBNb25vbW9ycGhpY1RhZ0ltcGwpLnJldmlzaW9uID0gKyskUkVWSVNJT047XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGRpcnR5ID0gTW9ub21vcnBoaWNUYWdJbXBsLmRpcnR5O1xuZXhwb3J0IGNvbnN0IHVwZGF0ZSA9IE1vbm9tb3JwaGljVGFnSW1wbC51cGRhdGU7XG5cbi8vLy8vLy8vLy9cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVRhZygpOiBEaXJ0eWFibGVUYWcge1xuICByZXR1cm4gbmV3IE1vbm9tb3JwaGljVGFnSW1wbChNb25vbW9ycGhpY1RhZ1R5cGVzLkRpcnR5YWJsZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVVcGRhdGFibGVUYWcoKTogVXBkYXRhYmxlVGFnIHtcbiAgcmV0dXJuIG5ldyBNb25vbW9ycGhpY1RhZ0ltcGwoTW9ub21vcnBoaWNUYWdUeXBlcy5VcGRhdGFibGUpO1xufVxuXG4vLy8vLy8vLy8vXG5cbmV4cG9ydCBjb25zdCBDT05TVEFOVF9UQUcgPSBuZXcgTW9ub21vcnBoaWNUYWdJbXBsKE1vbm9tb3JwaGljVGFnVHlwZXMuQ29uc3RhbnQpIGFzIENvbnN0YW50VGFnO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNDb25zdCh7IHRhZyB9OiBUYWdnZWQpOiBib29sZWFuIHtcbiAgcmV0dXJuIHRhZyA9PT0gQ09OU1RBTlRfVEFHO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNDb25zdFRhZyh0YWc6IFRhZyk6IHRhZyBpcyBDb25zdGFudFRhZyB7XG4gIHJldHVybiB0YWcgPT09IENPTlNUQU5UX1RBRztcbn1cblxuLy8vLy8vLy8vL1xuXG5jbGFzcyBWb2xhdGlsZVRhZyBpbXBsZW1lbnRzIFRhZyB7XG4gIFtDT01QVVRFXSgpIHtcbiAgICByZXR1cm4gVk9MQVRJTEU7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IFZPTEFUSUxFX1RBRyA9IG5ldyBWb2xhdGlsZVRhZygpO1xuXG4vLy8vLy8vLy8vXG5cbmNsYXNzIEN1cnJlbnRUYWcgaW1wbGVtZW50cyBDdXJyZW50VGFnIHtcbiAgW0NPTVBVVEVdKCkge1xuICAgIHJldHVybiAkUkVWSVNJT047XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IENVUlJFTlRfVEFHID0gbmV3IEN1cnJlbnRUYWcoKTtcblxuLy8vLy8vLy8vL1xuXG5leHBvcnQgZnVuY3Rpb24gY29tYmluZVRhZ2dlZCh0YWdnZWQ6IFJlYWRvbmx5QXJyYXk8VGFnZ2VkPik6IFRhZyB7XG4gIGxldCBvcHRpbWl6ZWQ6IFRhZ1tdID0gW107XG5cbiAgZm9yIChsZXQgaSA9IDAsIGwgPSB0YWdnZWQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgbGV0IHRhZyA9IHRhZ2dlZFtpXS50YWc7XG4gICAgaWYgKHRhZyA9PT0gQ09OU1RBTlRfVEFHKSBjb250aW51ZTtcbiAgICBvcHRpbWl6ZWQucHVzaCh0YWcpO1xuICB9XG5cbiAgcmV0dXJuIF9jb21iaW5lKG9wdGltaXplZCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21iaW5lU2xpY2Uoc2xpY2U6IFNsaWNlPFRhZ2dlZCAmIExpbmtlZExpc3ROb2RlPik6IFRhZyB7XG4gIGxldCBvcHRpbWl6ZWQ6IFRhZ1tdID0gW107XG5cbiAgbGV0IG5vZGUgPSBzbGljZS5oZWFkKCk7XG5cbiAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICBsZXQgdGFnID0gbm9kZS50YWc7XG5cbiAgICBpZiAodGFnICE9PSBDT05TVEFOVF9UQUcpIG9wdGltaXplZC5wdXNoKHRhZyk7XG5cbiAgICBub2RlID0gc2xpY2UubmV4dE5vZGUobm9kZSk7XG4gIH1cblxuICByZXR1cm4gX2NvbWJpbmUob3B0aW1pemVkKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbWJpbmUodGFnczogVGFnW10pOiBUYWcge1xuICBsZXQgb3B0aW1pemVkOiBUYWdbXSA9IFtdO1xuXG4gIGZvciAobGV0IGkgPSAwLCBsID0gdGFncy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBsZXQgdGFnID0gdGFnc1tpXTtcbiAgICBpZiAodGFnID09PSBDT05TVEFOVF9UQUcpIGNvbnRpbnVlO1xuICAgIG9wdGltaXplZC5wdXNoKHRhZyk7XG4gIH1cblxuICByZXR1cm4gX2NvbWJpbmUob3B0aW1pemVkKTtcbn1cblxuZnVuY3Rpb24gX2NvbWJpbmUodGFnczogVGFnW10pOiBUYWcge1xuICBzd2l0Y2ggKHRhZ3MubGVuZ3RoKSB7XG4gICAgY2FzZSAwOlxuICAgICAgcmV0dXJuIENPTlNUQU5UX1RBRztcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gdGFnc1swXTtcbiAgICBkZWZhdWx0OlxuICAgICAgbGV0IHRhZyA9IG5ldyBNb25vbW9ycGhpY1RhZ0ltcGwoTW9ub21vcnBoaWNUYWdUeXBlcy5Db21iaW5hdG9yKSBhcyBDb21iaW5hdG9yVGFnO1xuICAgICAgKHRhZyBhcyBhbnkpLnN1YnRhZ3MgPSB0YWdzO1xuICAgICAgcmV0dXJuIHRhZztcbiAgfVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==