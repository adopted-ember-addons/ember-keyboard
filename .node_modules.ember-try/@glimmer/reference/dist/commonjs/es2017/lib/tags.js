'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.dirtyTag = dirtyTag;
exports.tagFor = tagFor;
exports.updateTag = updateTag;

var _util = require('@glimmer/util');

var _validators = require('./validators');

const TRACKED_TAGS = new WeakMap();
function dirtyTag(obj, key) {
    if ((0, _util.isObject)(obj)) {
        let tag = tagFor(obj, key);
        if (tag === undefined) {
            updateTag(obj, key, (0, _validators.createUpdatableTag)());
        } else if ((0, _validators.isConstTag)(tag)) {
            throw new Error(`BUG: Can't update a constant tag`);
        } else {
            (0, _validators.dirty)(tag);
        }
    } else {
        throw new Error(`BUG: Can't update a tag for a primitive`);
    }
}
function tagFor(obj, key) {
    if ((0, _util.isObject)(obj)) {
        let tags = TRACKED_TAGS.get(obj);
        if (tags === undefined) {
            tags = new Map();
            TRACKED_TAGS.set(obj, tags);
        } else if (tags.has(key)) {
            return tags.get(key);
        }
        let tag = (0, _validators.createUpdatableTag)();
        tags.set(key, tag);
        return tag;
    } else {
        return _validators.CONSTANT_TAG;
    }
}
function updateTag(obj, key, newTag) {
    if ((0, _util.isObject)(obj)) {
        let tag = tagFor(obj, key);
        if ((0, _validators.isConstTag)(tag)) {
            throw new Error(`BUG: Can't update a constant tag`);
        } else {
            (0, _validators.update)(tag, newTag);
        }
        return tag;
    } else {
        throw new Error(`BUG: Can't update a tag for a primitive`);
    }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3JlZmVyZW5jZS9saWIvdGFncy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztRQWNNLFEsR0FBQSxRO1FBa0JBLE0sR0FBQSxNO1FBbUJBLFMsR0FBQSxTOzs7O0FBbEROOztBQVdBLE1BQU0sZUFBZSxJQUFyQixPQUFxQixFQUFyQjtBQUVNLFNBQUEsUUFBQSxDQUFBLEdBQUEsRUFBQSxHQUFBLEVBQTBDO0FBQzlDLFFBQUksb0JBQUosR0FBSSxDQUFKLEVBQW1CO0FBQ2pCLFlBQUksTUFBTSxPQUFBLEdBQUEsRUFBVixHQUFVLENBQVY7QUFFQSxZQUFJLFFBQUosU0FBQSxFQUF1QjtBQUNyQixzQkFBQSxHQUFBLEVBQUEsR0FBQSxFQUFBLHFDQUFBO0FBREYsU0FBQSxNQUVPLElBQUksNEJBQUosR0FBSSxDQUFKLEVBQXFCO0FBQzFCLGtCQUFNLElBQUEsS0FBQSxDQUFOLGtDQUFNLENBQU47QUFESyxTQUFBLE1BRUE7QUFDTCxtQ0FBQSxHQUFBO0FBQ0Q7QUFUSCxLQUFBLE1BVU87QUFDTCxjQUFNLElBQUEsS0FBQSxDQUFOLHlDQUFNLENBQU47QUFDRDtBQUNGO0FBSUssU0FBQSxNQUFBLENBQUEsR0FBQSxFQUFBLEdBQUEsRUFBd0M7QUFDNUMsUUFBSSxvQkFBSixHQUFJLENBQUosRUFBbUI7QUFDakIsWUFBSSxPQUFPLGFBQUEsR0FBQSxDQUFYLEdBQVcsQ0FBWDtBQUVBLFlBQUksU0FBSixTQUFBLEVBQXdCO0FBQ3RCLG1CQUFPLElBQVAsR0FBTyxFQUFQO0FBQ0EseUJBQUEsR0FBQSxDQUFBLEdBQUEsRUFBQSxJQUFBO0FBRkYsU0FBQSxNQUdPLElBQUksS0FBQSxHQUFBLENBQUosR0FBSSxDQUFKLEVBQW1CO0FBQ3hCLG1CQUFPLEtBQUEsR0FBQSxDQUFQLEdBQU8sQ0FBUDtBQUNEO0FBRUQsWUFBSSxNQUFKLHFDQUFBO0FBQ0EsYUFBQSxHQUFBLENBQUEsR0FBQSxFQUFBLEdBQUE7QUFDQSxlQUFBLEdBQUE7QUFaRixLQUFBLE1BYU87QUFDTCxlQUFBLHdCQUFBO0FBQ0Q7QUFDRjtBQUVLLFNBQUEsU0FBQSxDQUFBLEdBQUEsRUFBQSxHQUFBLEVBQUEsTUFBQSxFQUFpRTtBQUNyRSxRQUFJLG9CQUFKLEdBQUksQ0FBSixFQUFtQjtBQUNqQixZQUFJLE1BQU0sT0FBQSxHQUFBLEVBQVYsR0FBVSxDQUFWO0FBRUEsWUFBSSw0QkFBSixHQUFJLENBQUosRUFBcUI7QUFDbkIsa0JBQU0sSUFBQSxLQUFBLENBQU4sa0NBQU0sQ0FBTjtBQURGLFNBQUEsTUFFTztBQUNMLG9DQUFBLEdBQUEsRUFBQSxNQUFBO0FBQ0Q7QUFFRCxlQUFBLEdBQUE7QUFURixLQUFBLE1BVU87QUFDTCxjQUFNLElBQUEsS0FBQSxDQUFOLHlDQUFNLENBQU47QUFDRDtBQUNGIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNPYmplY3QgfSBmcm9tICdAZ2xpbW1lci91dGlsJztcbmltcG9ydCB7XG4gIGRpcnR5LFxuICB1cGRhdGUsXG4gIGNyZWF0ZVVwZGF0YWJsZVRhZyxcbiAgVXBkYXRhYmxlVGFnLFxuICBDT05TVEFOVF9UQUcsXG4gIGlzQ29uc3RUYWcsXG4gIENvbnN0YW50VGFnLFxufSBmcm9tICcuL3ZhbGlkYXRvcnMnO1xuXG50eXBlIFRhZ3MgPSBNYXA8UHJvcGVydHlLZXksIFVwZGF0YWJsZVRhZz47XG5jb25zdCBUUkFDS0VEX1RBR1MgPSBuZXcgV2Vha01hcDxvYmplY3QsIFRhZ3M+KCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBkaXJ0eVRhZzxUPihvYmo6IFQsIGtleToga2V5b2YgVCk6IHZvaWQge1xuICBpZiAoaXNPYmplY3Qob2JqKSkge1xuICAgIGxldCB0YWcgPSB0YWdGb3Iob2JqLCBrZXkpO1xuXG4gICAgaWYgKHRhZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB1cGRhdGVUYWcob2JqLCBrZXksIGNyZWF0ZVVwZGF0YWJsZVRhZygpKTtcbiAgICB9IGVsc2UgaWYgKGlzQ29uc3RUYWcodGFnKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBCVUc6IENhbid0IHVwZGF0ZSBhIGNvbnN0YW50IHRhZ2ApO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaXJ0eSh0YWcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEJVRzogQ2FuJ3QgdXBkYXRlIGEgdGFnIGZvciBhIHByaW1pdGl2ZWApO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0YWdGb3I8VCBleHRlbmRzIG9iamVjdD4ob2JqOiBULCBrZXk6IGtleW9mIFQpOiBVcGRhdGFibGVUYWc7XG5leHBvcnQgZnVuY3Rpb24gdGFnRm9yPFQ+KG9iajogVCwga2V5OiBzdHJpbmcpOiBDb25zdGFudFRhZztcbmV4cG9ydCBmdW5jdGlvbiB0YWdGb3I8VD4ob2JqOiBULCBrZXk6IGtleW9mIFQpOiBVcGRhdGFibGVUYWcgfCBDb25zdGFudFRhZyB7XG4gIGlmIChpc09iamVjdChvYmopKSB7XG4gICAgbGV0IHRhZ3MgPSBUUkFDS0VEX1RBR1MuZ2V0KG9iaik7XG5cbiAgICBpZiAodGFncyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0YWdzID0gbmV3IE1hcCgpO1xuICAgICAgVFJBQ0tFRF9UQUdTLnNldChvYmosIHRhZ3MpO1xuICAgIH0gZWxzZSBpZiAodGFncy5oYXMoa2V5KSkge1xuICAgICAgcmV0dXJuIHRhZ3MuZ2V0KGtleSkhO1xuICAgIH1cblxuICAgIGxldCB0YWcgPSBjcmVhdGVVcGRhdGFibGVUYWcoKTtcbiAgICB0YWdzLnNldChrZXksIHRhZyk7XG4gICAgcmV0dXJuIHRhZztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gQ09OU1RBTlRfVEFHO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVUYWc8VD4ob2JqOiBULCBrZXk6IGtleW9mIFQsIG5ld1RhZzogVXBkYXRhYmxlVGFnKTogVXBkYXRhYmxlVGFnIHtcbiAgaWYgKGlzT2JqZWN0KG9iaikpIHtcbiAgICBsZXQgdGFnID0gdGFnRm9yKG9iaiwga2V5KTtcblxuICAgIGlmIChpc0NvbnN0VGFnKHRhZykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQlVHOiBDYW4ndCB1cGRhdGUgYSBjb25zdGFudCB0YWdgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdXBkYXRlKHRhZywgbmV3VGFnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFnO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihgQlVHOiBDYW4ndCB1cGRhdGUgYSB0YWcgZm9yIGEgcHJpbWl0aXZlYCk7XG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=