import { dict, isDict } from '@glimmer/util';
import { CONSTANT_TAG, isConst, combine, createUpdatableTag, validate, value, dirty, update } from './validators';
import { pushTrackFrame, popTrackFrame } from './autotrack';
import { tagFor } from './tags';
export class RootReference {
    constructor(inner) {
        this.inner = inner;
        this.children = dict();
        this.tag = CONSTANT_TAG;
    }
    value() {
        return this.inner;
    }
    get(propertyKey) {
        let ref = this.children[propertyKey];
        if (!ref) {
            ref = this.children[propertyKey] = new RootPropertyReference(this.inner, propertyKey);
        }
        return ref;
    }
}
export class ImmutableRootReference {
    constructor(inner) {
        this.inner = inner;
        this.children = dict();
        this.tag = CONSTANT_TAG;
    }
    value() {
        return this.inner;
    }
    get(propertyKey) {
        let ref = this.children[propertyKey];
        if (!ref) {
            ref = this.children[propertyKey] = new RootPropertyReference(this.inner, propertyKey);
        }
        return ref;
    }
}
export class PrimitiveReference {
    constructor(inner) {
        this.inner = inner;
        this.tag = CONSTANT_TAG;
    }
    value() {
        return this.inner;
    }
    get(_key) {
        return UNDEFINED_REFERENCE;
    }
}
export const UNDEFINED_REFERENCE = new PrimitiveReference(undefined);
export function cached(inner) {
    return new Cached(inner);
}
export class Cached {
    constructor(inner) {
        this.inner = inner;
        this._lastRevision = null;
        this._lastValue = null;
        this.tag = CONSTANT_TAG;
    }
    value() {
        let { tag, _lastRevision, _lastValue } = this;
        if (!_lastRevision || !validate(tag, _lastRevision)) {
            _lastValue = this._lastValue = this.inner.value();
            this._lastRevision = value(tag);
        }
        return _lastValue;
    }
    get(key) {
        return property(this, key);
    }
}
export function data(value) {
    if (isDict(value)) {
        return new RootReference(value);
    } else {
        return new PrimitiveReference(value);
    }
}
export function property(parentReference, propertyKey) {
    if (isConst(parentReference)) {
        return new RootPropertyReference(parentReference.value(), propertyKey);
    } else {
        return new NestedPropertyReference(parentReference, propertyKey);
    }
}
// function isMutable(value: unknown): boolean {
//   return value !== null && typeof value === 'object' && !Object.isFrozen(value);
// }
// function child(value: unknown, key: string): VersionedPathReference {}
export class RootPropertyReference {
    constructor(_parentValue, _propertyKey) {
        this._parentValue = _parentValue;
        this._propertyKey = _propertyKey;
        this.tag = createUpdatableTag();
    }
    value() {
        let { _parentValue } = this;
        if (isDict(_parentValue)) {
            let old = pushTrackFrame();
            let ret = _parentValue[this._propertyKey];
            let tag = popTrackFrame(old);
            update(this.tag, tag);
            return ret;
        } else {
            return undefined;
        }
    }
    get(key) {
        return new NestedPropertyReference(this, key);
    }
}
export class NestedPropertyReference {
    constructor(_parentReference, _propertyKey) {
        this._parentReference = _parentReference;
        this._propertyKey = _propertyKey;
        let parentObjectTag = this._parentObjectTag = createUpdatableTag();
        let parentReferenceTag = _parentReference.tag;
        this.tag = combine([parentReferenceTag, parentObjectTag]);
    }
    value() {
        let { _parentReference, _parentObjectTag, _propertyKey } = this;
        let parentValue = _parentReference.value();
        update(_parentObjectTag, tagFor(parentValue, _propertyKey));
        if (isDict(parentValue)) {
            let old = pushTrackFrame();
            let ret = parentValue[_propertyKey];
            let tag = popTrackFrame(old);
            update(_parentObjectTag, tag);
            return ret;
        } else {
            return undefined;
        }
    }
    get(key) {
        return new NestedPropertyReference(this, key);
    }
}
export class UpdatableReference {
    constructor(_value) {
        this._value = _value;
        this.tag = createUpdatableTag();
    }
    value() {
        return this._value;
    }
    update(value) {
        let { _value } = this;
        if (value !== _value) {
            dirty(this.tag);
            this._value = value;
        }
    }
    forceUpdate(value) {
        dirty(this.tag);
        this._value = value;
    }
    dirty() {
        dirty(this.tag);
    }
    get(key) {
        return new NestedPropertyReference(this, key);
    }
}
export function State(data) {
    return new UpdatableReference(data);
}
const STABLE_STATE = new WeakMap();
export function StableState(data) {
    if (STABLE_STATE.has(data)) {
        return STABLE_STATE.get(data);
    } else {
        let ref = new UpdatableReference(data);
        STABLE_STATE.set(data, ref);
        return ref;
    }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3JlZmVyZW5jZS9saWIvcHJvcGVydHkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsU0FBUyxJQUFULEVBQWUsTUFBZixRQUE2QixlQUE3QjtBQUNBLFNBQ0UsWUFERixFQUVFLE9BRkYsRUFJRSxPQUpGLEVBS0Usa0JBTEYsRUFPRSxRQVBGLEVBUUUsS0FSRixFQVNFLEtBVEYsRUFVRSxNQVZGLFFBV08sY0FYUDtBQWFBLFNBQVMsY0FBVCxFQUF5QixhQUF6QixRQUE4QyxhQUE5QztBQUNBLFNBQVMsTUFBVCxRQUF1QixRQUF2QjtBQUVBLE9BQU0sTUFBTyxhQUFQLENBQW9CO0FBS3hCLGdCQUFvQixLQUFwQixFQUE0QjtBQUFSLGFBQUEsS0FBQSxHQUFBLEtBQUE7QUFKWixhQUFBLFFBQUEsR0FBVyxNQUFYO0FBRVIsYUFBQSxHQUFBLEdBQU0sWUFBTjtBQUVnQztBQUVoQyxZQUFLO0FBQ0gsZUFBTyxLQUFLLEtBQVo7QUFDRDtBQUVELFFBQUksV0FBSixFQUF1QjtBQUNyQixZQUFJLE1BQU0sS0FBSyxRQUFMLENBQWMsV0FBZCxDQUFWO0FBRUEsWUFBSSxDQUFDLEdBQUwsRUFBVTtBQUNSLGtCQUFNLEtBQUssUUFBTCxDQUFjLFdBQWQsSUFBNkIsSUFBSSxxQkFBSixDQUEwQixLQUFLLEtBQS9CLEVBQXNDLFdBQXRDLENBQW5DO0FBQ0Q7QUFFRCxlQUFPLEdBQVA7QUFDRDtBQW5CdUI7QUFzQjFCLE9BQU0sTUFBTyxzQkFBUCxDQUE2QjtBQUtqQyxnQkFBb0IsS0FBcEIsRUFBNEI7QUFBUixhQUFBLEtBQUEsR0FBQSxLQUFBO0FBSlosYUFBQSxRQUFBLEdBQVcsTUFBWDtBQUVSLGFBQUEsR0FBQSxHQUFNLFlBQU47QUFFZ0M7QUFFaEMsWUFBSztBQUNILGVBQU8sS0FBSyxLQUFaO0FBQ0Q7QUFFRCxRQUFJLFdBQUosRUFBdUI7QUFDckIsWUFBSSxNQUFNLEtBQUssUUFBTCxDQUFjLFdB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QWU7QUFDYixZQUFJLEVBQUUsTUFBRixLQUFhLElBQWpCO0FBRUEsWUFBSSxVQUFVLE1BQWQsRUFBc0I7QUFDcEIsa0JBQU0sS0FBSyxHQUFYO0FBQ0EsaUJBQUssTUFBTCxHQUFjLEtBQWQ7QUFDRDtBQUNGO0FBRUQsZ0JBQVksS0FBWixFQUFvQjtBQUNsQixjQUFNLEtBQUssR0FBWDtBQUNBLGFBQUssTUFBTCxHQUFjLEtBQWQ7QUFDRDtBQUVELFlBQUs7QUFDSCxjQUFNLEtBQUssR0FBWDtBQUNEO0FBRUQsUUFBSSxHQUFKLEVBQWU7QUFDYixlQUFPLElBQUksdUJBQUosQ0FBNEIsSUFBNUIsRUFBa0MsR0FBbEMsQ0FBUDtBQUNEO0FBN0I0QjtBQWdDL0IsT0FBTSxTQUFVLEtBQVYsQ0FBbUIsSUFBbkIsRUFBMEI7QUFDOUIsV0FBTyxJQUFJLGtCQUFKLENBQXVCLElBQXZCLENBQVA7QUFDRDtBQUVELE1BQU0sZUFBZSxJQUFJLE9BQUosRUFBckI7QUFFQSxPQUFNLFNBQVUsV0FBVixDQUF3QyxJQUF4QyxFQUErQztBQUNuRCxRQUFJLGFBQWEsR0FBYixDQUFpQixJQUFqQixDQUFKLEVBQTRCO0FBQzFCLGVBQU8sYUFBYSxHQUFiLENBQWlCLElBQWpCLENBQVA7QUFDRCxLQUZELE1BRU87QUFDTCxZQUFJLE1BQU0sSUFBSSxrQkFBSixDQUF1QixJQUF2QixDQUFWO0FBQ0EscUJBQWEsR0FBYixDQUFpQixJQUFqQixFQUF1QixHQUF2QjtBQUNBLGVBQU8sR0FBUDtBQUNEO0FBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkaWN0LCBpc0RpY3QgfSBmcm9tICdAZ2xpbW1lci91dGlsJztcbmltcG9ydCB7XG4gIENPTlNUQU5UX1RBRyxcbiAgaXNDb25zdCxcbiAgVGFnLFxuICBjb21iaW5lLFxuICBjcmVhdGVVcGRhdGFibGVUYWcsXG4gIFVwZGF0YWJsZVRhZyxcbiAgdmFsaWRhdGUsXG4gIHZhbHVlLFxuICBkaXJ0eSxcbiAgdXBkYXRlLFxufSBmcm9tICcuL3ZhbGlkYXRvcnMnO1xuaW1wb3J0IHsgVmVyc2lvbmVkUGF0aFJlZmVyZW5jZSB9IGZyb20gJy4vcmVmZXJlbmNlJztcbmltcG9ydCB7IHB1c2hUcmFja0ZyYW1lLCBwb3BUcmFja0ZyYW1lIH0gZnJvbSAnLi9hdXRvdHJhY2snO1xuaW1wb3J0IHsgdGFnRm9yIH0gZnJvbSAnLi90YWdzJztcblxuZXhwb3J0IGNsYXNzIFJvb3RSZWZlcmVuY2U8VD4gaW1wbGVtZW50cyBWZXJzaW9uZWRQYXRoUmVmZXJlbmNlPFQ+IHtcbiAgcHJpdmF0ZSBjaGlsZHJlbiA9IGRpY3Q8Um9vdFByb3BlcnR5UmVmZXJlbmNlPigpO1xuXG4gIHRhZyA9IENPTlNUQU5UX1RBRztcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGlubmVyOiBUKSB7fVxuXG4gIHZhbHVlKCk6IFQge1xuICAgIHJldHVybiB0aGlzLmlubmVyO1xuICB9XG5cbiAgZ2V0KHByb3BlcnR5S2V5OiBzdHJpbmcpOiBSb290UHJvcGVydHlSZWZlcmVuY2Uge1xuICAgIGxldCByZWYgPSB0aGlzLmNoaWxkcmVuW3Byb3BlcnR5S2V5XTtcblxuICAgIGlmICghcmVmKSB7XG4gICAgICByZWYgPSB0aGlzLmNoaWxkcmVuW3Byb3BlcnR5S2V5XSA9IG5ldyBSb290UHJvcGVydHlSZWZlcmVuY2UodGhpcy5pbm5lciwgcHJvcGVydHlLZXkpO1xuICAgIH1cblxuICAgIHJldHVybiByZWY7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEltbXV0YWJsZVJvb3RSZWZlcmVuY2U8VD4gaW1wbGVtZW50cyBWZXJzaW9uZWRQYXRoUmVmZXJlbmNlPFQ+IHtcbiAgcHJpdmF0ZSBjaGlsZHJlbiA9IGRpY3Q8Um9vdFByb3BlcnR5UmVmZXJlbmNlPigpO1xuXG4gIHRhZyA9IENPTlNUQU5UX1RBRztcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGlubmVyOiBUKSB7fVxuXG4gIHZhbHVlKCk6IFQge1xuICAgIHJldHVybiB0aGlzLmlubmVyO1xuICB9XG5cbiAgZ2V0KHByb3BlcnR5S2V5OiBzdHJpbmcpOiBSb290UHJvcGVydHlSZWZlcmVuY2Uge1xuICAgIGxldCByZWYgPSB0aGlzLmNoaWxkcmVuW3Byb3BlcnR5S2V5XTtcblxuICAgIGlmICghcmVmKSB7XG4gICAgICByZWYgPSB0aGlzLmNoaWxkcmVuW3Byb3BlcnR5S2V5XSA9IG5ldyBSb290UHJvcGVydHlSZWZlcmVuY2UodGhpcy5pbm5lciwgcHJvcGVydHlLZXkpO1xuICAgIH1cblxuICAgIHJldHVybiByZWY7XG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgUHJpbWl0aXZlID0gdW5kZWZpbmVkIHwgbnVsbCB8IGJvb2xlYW4gfCBudW1iZXIgfCBzdHJpbmc7XG5cbmV4cG9ydCBjbGFzcyBQcmltaXRpdmVSZWZlcmVuY2U8VCBleHRlbmRzIFByaW1pdGl2ZT4gaW1wbGVtZW50cyBWZXJzaW9uZWRQYXRoUmVmZXJlbmNlPFQ+IHtcbiAgcmVhZG9ubHkgdGFnID0gQ09OU1RBTlRfVEFHO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgaW5uZXI6IFQpIHt9XG5cbiAgdmFsdWUoKTogVCB7XG4gICAgcmV0dXJuIHRoaXMuaW5uZXI7XG4gIH1cblxuICBnZXQoX2tleTogc3RyaW5nKTogUHJpbWl0aXZlUmVmZXJlbmNlPFByaW1pdGl2ZT4ge1xuICAgIHJldHVybiBVTkRFRklORURfUkVGRVJFTkNFO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBVTkRFRklORURfUkVGRVJFTkNFOiBQcmltaXRpdmVSZWZlcmVuY2U8dW5kZWZpbmVkPiA9IG5ldyBQcmltaXRpdmVSZWZlcmVuY2UodW5kZWZpbmVkKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGNhY2hlZDxUPihpbm5lcjogVmVyc2lvbmVkUGF0aFJlZmVyZW5jZTxUPik6IFZlcnNpb25lZFBhdGhSZWZlcmVuY2U8VD4ge1xuICByZXR1cm4gbmV3IENhY2hlZChpbm5lcik7XG59XG5cbmV4cG9ydCBjbGFzcyBDYWNoZWQ8VCA9IHVua25vd24+IGltcGxlbWVudHMgVmVyc2lvbmVkUGF0aFJlZmVyZW5jZTxUPiB7XG4gIHByaXZhdGUgX2xhc3RSZXZpc2lvbjogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgX2xhc3RWYWx1ZTogYW55ID0gbnVsbDtcblxuICB0YWc6IFRhZyA9IENPTlNUQU5UX1RBRztcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGlubmVyOiBWZXJzaW9uZWRQYXRoUmVmZXJlbmNlPFQ+KSB7fVxuXG4gIHZhbHVlKCkge1xuICAgIGxldCB7IHRhZywgX2xhc3RSZXZpc2lvbiwgX2xhc3RWYWx1ZSB9ID0gdGhpcztcblxuICAgIGlmICghX2xhc3RSZXZpc2lvbiB8fCAhdmFsaWRhdGUodGFnLCBfbGFzdFJldmlzaW9uKSkge1xuICAgICAgX2xhc3RWYWx1ZSA9IHRoaXMuX2xhc3RWYWx1ZSA9IHRoaXMuaW5uZXIudmFsdWUoKTtcbiAgICAgIHRoaXMuX2xhc3RSZXZpc2lvbiA9IHZhbHVlKHRhZyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9sYXN0VmFsdWU7XG4gIH1cblxuICBnZXQoa2V5OiBzdHJpbmcpOiBWZXJzaW9uZWRQYXRoUmVmZXJlbmNlIHtcbiAgICByZXR1cm4gcHJvcGVydHkodGhpcywga2V5KTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGF0YSh2YWx1ZTogdW5rbm93bik6IFZlcnNpb25lZFBhdGhSZWZlcmVuY2Uge1xuICBpZiAoaXNEaWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBuZXcgUm9vdFJlZmVyZW5jZSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBQcmltaXRpdmVSZWZlcmVuY2UodmFsdWUgYXMgbnVsbCB8IHVuZGVmaW5lZCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByb3BlcnR5KHBhcmVudFJlZmVyZW5jZTogVmVyc2lvbmVkUGF0aFJlZmVyZW5jZSwgcHJvcGVydHlLZXk6IHN0cmluZykge1xuICBpZiAoaXNDb25zdChwYXJlbnRSZWZlcmVuY2UpKSB7XG4gICAgcmV0dXJuIG5ldyBSb290UHJvcGVydHlSZWZlcmVuY2UocGFyZW50UmVmZXJlbmNlLnZhbHVlKCksIHByb3BlcnR5S2V5KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IE5lc3RlZFByb3BlcnR5UmVmZXJlbmNlKHBhcmVudFJlZmVyZW5jZSwgcHJvcGVydHlLZXkpO1xuICB9XG59XG5cbi8vIGZ1bmN0aW9uIGlzTXV0YWJsZSh2YWx1ZTogdW5rbm93bik6IGJvb2xlYW4ge1xuLy8gICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiAhT2JqZWN0LmlzRnJvemVuKHZhbHVlKTtcbi8vIH1cblxuLy8gZnVuY3Rpb24gY2hpbGQodmFsdWU6IHVua25vd24sIGtleTogc3RyaW5nKTogVmVyc2lvbmVkUGF0aFJlZmVyZW5jZSB7fVxuXG5leHBvcnQgY2xhc3MgUm9vdFByb3BlcnR5UmVmZXJlbmNlIGltcGxlbWVudHMgVmVyc2lvbmVkUGF0aFJlZmVyZW5jZSB7XG4gIHRhZyA9IGNyZWF0ZVVwZGF0YWJsZVRhZygpO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgX3BhcmVudFZhbHVlOiB1bmtub3duLCBwcml2YXRlIF9wcm9wZXJ0eUtleTogc3RyaW5nKSB7fVxuXG4gIHZhbHVlKCk6IHVua25vd24ge1xuICAgIGxldCB7IF9wYXJlbnRWYWx1ZSB9ID0gdGhpcztcbiAgICBpZiAoaXNEaWN0KF9wYXJlbnRWYWx1ZSkpIHtcbiAgICAgIGxldCBvbGQgPSBwdXNoVHJhY2tGcmFtZSgpO1xuICAgICAgbGV0IHJldCA9IF9wYXJlbnRWYWx1ZVt0aGlzLl9wcm9wZXJ0eUtleV07XG4gICAgICBsZXQgdGFnID0gcG9wVHJhY2tGcmFtZShvbGQpO1xuICAgICAgdXBkYXRlKHRoaXMudGFnLCB0YWcpO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICBnZXQoa2V5OiBzdHJpbmcpOiBWZXJzaW9uZWRQYXRoUmVmZXJlbmNlIHtcbiAgICByZXR1cm4gbmV3IE5lc3RlZFByb3BlcnR5UmVmZXJlbmNlKHRoaXMsIGtleSk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIE5lc3RlZFByb3BlcnR5UmVmZXJlbmNlIGltcGxlbWVudHMgVmVyc2lvbmVkUGF0aFJlZmVyZW5jZSB7XG4gIHB1YmxpYyB0YWc6IFRhZztcbiAgcHJpdmF0ZSBfcGFyZW50T2JqZWN0VGFnOiBVcGRhdGFibGVUYWc7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfcGFyZW50UmVmZXJlbmNlOiBWZXJzaW9uZWRQYXRoUmVmZXJlbmNlLCBwcml2YXRlIF9wcm9wZXJ0eUtleTogc3RyaW5nKSB7XG4gICAgbGV0IHBhcmVudE9iamVjdFRhZyA9ICh0aGlzLl9wYXJlbnRPYmplY3RUYWcgPSBjcmVhdGVVcGRhdGFibGVUYWcoKSk7XG4gICAgbGV0IHBhcmVudFJlZmVyZW5jZVRhZyA9IF9wYXJlbnRSZWZlcmVuY2UudGFnO1xuXG4gICAgdGhpcy50YWcgPSBjb21iaW5lKFtwYXJlbnRSZWZlcmVuY2VUYWcsIHBhcmVudE9iamVjdFRhZ10pO1xuICB9XG5cbiAgdmFsdWUoKSB7XG4gICAgbGV0IHsgX3BhcmVudFJlZmVyZW5jZSwgX3BhcmVudE9iamVjdFRhZywgX3Byb3BlcnR5S2V5IH0gPSB0aGlzO1xuXG4gICAgbGV0IHBhcmVudFZhbHVlID0gX3BhcmVudFJlZmVyZW5jZS52YWx1ZSgpO1xuXG4gICAgdXBkYXRlKF9wYXJlbnRPYmplY3RUYWcsIHRhZ0ZvcihwYXJlbnRWYWx1ZSwgX3Byb3BlcnR5S2V5KSk7XG5cbiAgICBpZiAoaXNEaWN0KHBhcmVudFZhbHVlKSkge1xuICAgICAgbGV0IG9sZCA9IHB1c2hUcmFja0ZyYW1lKCk7XG4gICAgICBsZXQgcmV0ID0gcGFyZW50VmFsdWVbX3Byb3BlcnR5S2V5XTtcbiAgICAgIGxldCB0YWcgPSBwb3BUcmFja0ZyYW1lKG9sZCk7XG4gICAgICB1cGRhdGUoX3BhcmVudE9iamVjdFRhZywgdGFnKTtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgZ2V0KGtleTogc3RyaW5nKTogVmVyc2lvbmVkUGF0aFJlZmVyZW5jZSB7XG4gICAgcmV0dXJuIG5ldyBOZXN0ZWRQcm9wZXJ0eVJlZmVyZW5jZSh0aGlzLCBrZXkpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBVcGRhdGFibGVSZWZlcmVuY2U8VCA9IHVua25vd24+IGltcGxlbWVudHMgVmVyc2lvbmVkUGF0aFJlZmVyZW5jZTxUPiB7XG4gIHB1YmxpYyB0YWcgPSBjcmVhdGVVcGRhdGFibGVUYWcoKTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF92YWx1ZTogVCkge31cblxuICB2YWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gIH1cblxuICB1cGRhdGUodmFsdWU6IFQpIHtcbiAgICBsZXQgeyBfdmFsdWUgfSA9IHRoaXM7XG5cbiAgICBpZiAodmFsdWUgIT09IF92YWx1ZSkge1xuICAgICAgZGlydHkodGhpcy50YWcpO1xuICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICBmb3JjZVVwZGF0ZSh2YWx1ZTogVCkge1xuICAgIGRpcnR5KHRoaXMudGFnKTtcbiAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICB9XG5cbiAgZGlydHkoKSB7XG4gICAgZGlydHkodGhpcy50YWcpO1xuICB9XG5cbiAgZ2V0KGtleTogc3RyaW5nKTogVmVyc2lvbmVkUGF0aFJlZmVyZW5jZSB7XG4gICAgcmV0dXJuIG5ldyBOZXN0ZWRQcm9wZXJ0eVJlZmVyZW5jZSh0aGlzLCBrZXkpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBTdGF0ZTxUPihkYXRhOiBUKTogVXBkYXRhYmxlUmVmZXJlbmNlPFQ+IHtcbiAgcmV0dXJuIG5ldyBVcGRhdGFibGVSZWZlcmVuY2UoZGF0YSk7XG59XG5cbmNvbnN0IFNUQUJMRV9TVEFURSA9IG5ldyBXZWFrTWFwKCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBTdGFibGVTdGF0ZTxUIGV4dGVuZHMgb2JqZWN0PihkYXRhOiBUKTogVXBkYXRhYmxlUmVmZXJlbmNlPFQ+IHtcbiAgaWYgKFNUQUJMRV9TVEFURS5oYXMoZGF0YSkpIHtcbiAgICByZXR1cm4gU1RBQkxFX1NUQVRFLmdldChkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgcmVmID0gbmV3IFVwZGF0YWJsZVJlZmVyZW5jZShkYXRhKTtcbiAgICBTVEFCTEVfU1RBVEUuc2V0KGRhdGEsIHJlZik7XG4gICAgcmV0dXJuIHJlZjtcbiAgfVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==