import { isObject } from '@glimmer/util';
import { dirty, update, createUpdatableTag, CONSTANT_TAG, isConstTag } from './validators';
const TRACKED_TAGS = new WeakMap();
export function dirtyTag(obj, key) {
    if (isObject(obj)) {
        let tag = tagFor(obj, key);
        if (tag === undefined) {
            updateTag(obj, key, createUpdatableTag());
        } else if (isConstTag(tag)) {
            throw new Error(`BUG: Can't update a constant tag`);
        } else {
            dirty(tag);
        }
    } else {
        throw new Error(`BUG: Can't update a tag for a primitive`);
    }
}
export function tagFor(obj, key) {
    if (isObject(obj)) {
        let tags = TRACKED_TAGS.get(obj);
        if (tags === undefined) {
            tags = new Map();
            TRACKED_TAGS.set(obj, tags);
        } else if (tags.has(key)) {
            return tags.get(key);
        }
        let tag = createUpdatableTag();
        tags.set(key, tag);
        return tag;
    } else {
        return CONSTANT_TAG;
    }
}
export function updateTag(obj, key, newTag) {
    if (isObject(obj)) {
        let tag = tagFor(obj, key);
        if (isConstTag(tag)) {
            throw new Error(`BUG: Can't update a constant tag`);
        } else {
            update(tag, newTag);
        }
        return tag;
    } else {
        throw new Error(`BUG: Can't update a tag for a primitive`);
    }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3JlZmVyZW5jZS9saWIvdGFncy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxTQUFTLFFBQVQsUUFBeUIsZUFBekI7QUFDQSxTQUNFLEtBREYsRUFFRSxNQUZGLEVBR0Usa0JBSEYsRUFLRSxZQUxGLEVBTUUsVUFORixRQVFPLGNBUlA7QUFXQSxNQUFNLGVBQWUsSUFBSSxPQUFKLEVBQXJCO0FBRUEsT0FBTSxTQUFVLFFBQVYsQ0FBc0IsR0FBdEIsRUFBOEIsR0FBOUIsRUFBMEM7QUFDOUMsUUFBSSxTQUFTLEdBQVQsQ0FBSixFQUFtQjtBQUNqQixZQUFJLE1BQU0sT0FBTyxHQUFQLEVBQVksR0FBWixDQUFWO0FBRUEsWUFBSSxRQUFRLFNBQVosRUFBdUI7QUFDckIsc0JBQVUsR0FBVixFQUFlLEdBQWYsRUFBb0Isb0JBQXBCO0FBQ0QsU0FGRCxNQUVPLElBQUksV0FBVyxHQUFYLENBQUosRUFBcUI7QUFDMUIsa0JBQU0sSUFBSSxLQUFKLENBQVUsa0NBQVYsQ0FBTjtBQUNELFNBRk0sTUFFQTtBQUNMLGtCQUFNLEdBQU47QUFDRDtBQUNGLEtBVkQsTUFVTztBQUNMLGNBQU0sSUFBSSxLQUFKLENBQVUseUNBQVYsQ0FBTjtBQUNEO0FBQ0Y7QUFJRCxPQUFNLFNBQVUsTUFBVixDQUFvQixHQUFwQixFQUE0QixHQUE1QixFQUF3QztBQUM1QyxRQUFJLFNBQVMsR0FBVCxDQUFKLEVBQW1CO0FBQ2pCLFlBQUksT0FBTyxhQUFhLEdBQWIsQ0FBaUIsR0FBakIsQ0FBWDtBQUVBLFlBQUksU0FBUyxTQUFiLEVBQXdCO0FBQ3RCLG1CQUFPLElBQUksR0FBSixFQUFQO0FBQ0EseUJBQWEsR0FBYixDQUFpQixHQUFqQixFQUFzQixJQUF0QjtBQUNELFNBSEQsTUFHTyxJQUFJLEtBQUssR0FBTCxDQUFTLEdBQVQsQ0FBSixFQUFtQjtBQUN4QixtQkFBTyxLQUFLLEdBQUwsQ0FBUyxHQUFULENBQVA7QUFDRDtBQUVELFlBQUksTUFBTSxvQkFBVjtBQUNBLGFBQUssR0FBTCxDQUFTLEdBQVQsRUFBYyxHQUFkO0FBQ0EsZUFBTyxHQUFQO0FBQ0QsS0FiRCxNQWFPO0FBQ0wsZUFBTyxZQUFQO0FBQ0Q7QUFDRjtBQUVELE9BQU0sU0FBVSxTQUFWLENBQXVCLEdBQXZCLEVBQStCLEdBQS9CLEVBQTZDLE1BQTdDLEVBQWlFO0FBQ3JFLFFBQUksU0FBUyxHQUFULENBQUosRUFBbUI7QUFDakIsWUFBSSxNQUFNLE9BQU8sR0FBUCxFQUFZLEdBQVosQ0FBVjtBQUVBLFlBQUksV0FBVyxHQUFYLENBQUosRUFBcUI7QUFDbkIsa0JBQU0sSUFBSSxLQUFKLENBQVUsa0NBQVYsQ0FBTjtBQUNELFNBRkQsTUFFTztBQUNMLG1CQUFPLEdBQVAsRUFBWSxNQUFaO0FBQ0Q7QUFFRCxlQUFPLEdBQVA7QUFDRCxLQVZELE1BVU87QUFDTCxjQUFNLElBQUksS0FBSixDQUFVLHlDQUFWLENBQU47QUFDRDtBQUNGIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNPYmplY3QgfSBmcm9tICdAZ2xpbW1lci91dGlsJztcbmltcG9ydCB7XG4gIGRpcnR5LFxuICB1cGRhdGUsXG4gIGNyZWF0ZVVwZGF0YWJsZVRhZyxcbiAgVXBkYXRhYmxlVGFnLFxuICBDT05TVEFOVF9UQUcsXG4gIGlzQ29uc3RUYWcsXG4gIENvbnN0YW50VGFnLFxufSBmcm9tICcuL3ZhbGlkYXRvcnMnO1xuXG50eXBlIFRhZ3MgPSBNYXA8UHJvcGVydHlLZXksIFVwZGF0YWJsZVRhZz47XG5jb25zdCBUUkFDS0VEX1RBR1MgPSBuZXcgV2Vha01hcDxvYmplY3QsIFRhZ3M+KCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBkaXJ0eVRhZzxUPihvYmo6IFQsIGtleToga2V5b2YgVCk6IHZvaWQge1xuICBpZiAoaXNPYmplY3Qob2JqKSkge1xuICAgIGxldCB0YWcgPSB0YWdGb3Iob2JqLCBrZXkpO1xuXG4gICAgaWYgKHRhZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB1cGRhdGVUYWcob2JqLCBrZXksIGNyZWF0ZVVwZGF0YWJsZVRhZygpKTtcbiAgICB9IGVsc2UgaWYgKGlzQ29uc3RUYWcodGFnKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBCVUc6IENhbid0IHVwZGF0ZSBhIGNvbnN0YW50IHRhZ2ApO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaXJ0eSh0YWcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEJVRzogQ2FuJ3QgdXBkYXRlIGEgdGFnIGZvciBhIHByaW1pdGl2ZWApO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0YWdGb3I8VCBleHRlbmRzIG9iamVjdD4ob2JqOiBULCBrZXk6IGtleW9mIFQpOiBVcGRhdGFibGVUYWc7XG5leHBvcnQgZnVuY3Rpb24gdGFnRm9yPFQ+KG9iajogVCwga2V5OiBzdHJpbmcpOiBDb25zdGFudFRhZztcbmV4cG9ydCBmdW5jdGlvbiB0YWdGb3I8VD4ob2JqOiBULCBrZXk6IGtleW9mIFQpOiBVcGRhdGFibGVUYWcgfCBDb25zdGFudFRhZyB7XG4gIGlmIChpc09iamVjdChvYmopKSB7XG4gICAgbGV0IHRhZ3MgPSBUUkFDS0VEX1RBR1MuZ2V0KG9iaik7XG5cbiAgICBpZiAodGFncyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0YWdzID0gbmV3IE1hcCgpO1xuICAgICAgVFJBQ0tFRF9UQUdTLnNldChvYmosIHRhZ3MpO1xuICAgIH0gZWxzZSBpZiAodGFncy5oYXMoa2V5KSkge1xuICAgICAgcmV0dXJuIHRhZ3MuZ2V0KGtleSkhO1xuICAgIH1cblxuICAgIGxldCB0YWcgPSBjcmVhdGVVcGRhdGFibGVUYWcoKTtcbiAgICB0YWdzLnNldChrZXksIHRhZyk7XG4gICAgcmV0dXJuIHRhZztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gQ09OU1RBTlRfVEFHO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVUYWc8VD4ob2JqOiBULCBrZXk6IGtleW9mIFQsIG5ld1RhZzogVXBkYXRhYmxlVGFnKTogVXBkYXRhYmxlVGFnIHtcbiAgaWYgKGlzT2JqZWN0KG9iaikpIHtcbiAgICBsZXQgdGFnID0gdGFnRm9yKG9iaiwga2V5KTtcblxuICAgIGlmIChpc0NvbnN0VGFnKHRhZykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQlVHOiBDYW4ndCB1cGRhdGUgYSBjb25zdGFudCB0YWdgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdXBkYXRlKHRhZywgbmV3VGFnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFnO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihgQlVHOiBDYW4ndCB1cGRhdGUgYSB0YWcgZm9yIGEgcHJpbWl0aXZlYCk7XG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=