
import { capabilityFlagsFrom } from './capabilities';
import { hasStaticLayoutCapability } from './compiled/opcodes/component';
import { resolveComponent } from './component/resolve';
import { ARGS } from './symbols';
import { AotVM, JitVM } from './vm/append';
import { NewElementBuilder } from './vm/element-builder';
import { DefaultDynamicScope } from './dynamic-scope';
import { UNDEFINED_REFERENCE } from './references';
class TemplateIteratorImpl {
    constructor(vm) {
        this.vm = vm;
    }
    next() {
        return this.vm.next();
    }
    sync() {
        return renderSync(this.vm.runtime.env, this);
    }
}
export function renderSync(env, iterator) {
    env.begin();
    let iteratorResult;
    do {
        iteratorResult = iterator.next();
    } while (!iteratorResult.done);
    let result = iteratorResult.value;
    env.commit();
    return result;
}
export function renderAotMain(runtime, self, treeBuilder, handle, dynamicScope = new DefaultDynamicScope()) {
    let vm = AotVM.initial(runtime, { self, dynamicScope, treeBuilder, handle });
    return new TemplateIteratorImpl(vm);
}
export function renderAot(runtime, handle, cursor, self = UNDEFINED_REFERENCE) {
    let treeBuilder = NewElementBuilder.forInitialRender(runtime.env, cursor);
    let dynamicScope = new DefaultDynamicScope();
    let vm = AotVM.initial(runtime, { self, dynamicScope, treeBuilder, handle });
    return new TemplateIteratorImpl(vm);
}
export function renderJitMain(runtime, context, self, treeBuilder, handle, dynamicScope = new DefaultDynamicScope()) {
    let vm = JitVM.initial(runtime, context, { self, dynamicScope, treeBuilder, handle });
    return new TemplateIteratorImpl(vm);
}
function renderInvocation(vm, invocation, definition, args) {
    // Get a list of tuples of argument names and references, like
    // [['title', reference], ['name', reference]]
    const argList = Object.keys(args).map(key => [key, args[key]]);
    const blockNames = ['main', 'else', 'attrs'];
    // Prefix argument names with `@` symbol
    const argNames = argList.map(([name]) => `@${name}`);
    vm.pushFrame();
    // Push blocks on to the stack, three stack values per block
    for (let i = 0; i < 3 * blockNames.length; i++) {
        vm.stack.push(null);
    }
    vm.stack.push(null);
    // For each argument, push its backing reference on to the stack
    argList.forEach(([, reference]) => {
        vm.stack.push(reference);
    });
    // Configure VM based on blocks and args just pushed on to the stack.
    vm[ARGS].setup(vm.stack, argNames, blockNames, 0, true);
    // Needed for the Op.Main opcode: arguments, component invocation object, and
    // component definition.
    vm.stack.push(vm[ARGS]);
    vm.stack.push(invocation);
    vm.stack.push(definition);
    return new TemplateIteratorImpl(vm);
}
export function renderAotComponent(runtime, treeBuilder, main, name, args = {}, dynamicScope = new DefaultDynamicScope()) {
    let vm = AotVM.empty(runtime, { treeBuilder, handle: main, dynamicScope });
    const definition = resolveComponent(vm.runtime.resolver, name);
    const { manager, state } = definition;
    const capabilities = capabilityFlagsFrom(manager.getCapabilities(state));
    let invocation;
    if (hasStaticLayoutCapability(capabilities, manager)) {
        invocation = manager.getAotStaticLayout(state, vm.runtime.resolver);
    } else {
        throw new Error('Cannot invoke components with dynamic layouts as a root component.');
    }
    return renderInvocation(vm, invocation, definition, args);
}
export function renderJitComponent(runtime, treeBuilder, context, main, name, args = {}, dynamicScope = new DefaultDynamicScope()) {
    let vm = JitVM.empty(runtime, { treeBuilder, handle: main, dynamicScope }, context);
    const definition = resolveComponent(vm.runtime.resolver, name);
    const { manager, state } = definition;
    const capabilities = capabilityFlagsFrom(manager.getCapabilities(state));
    let invocation;
    if (hasStaticLayoutCapability(capabilities, manager)) {
        let layout = manager.getJitStaticLayout(state, vm.runtime.resolver);
        invocation = { handle: layout.compile(context), symbolTable: layout.symbolTable };
    } else {
        throw new Error('Cannot invoke components with dynamic layouts as a root component.');
    }
    return renderInvocation(vm, invocation, definition, args);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3J1bnRpbWUvbGliL3JlbmRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBb0JBLFNBQVMsbUJBQVQsUUFBb0MsZ0JBQXBDO0FBQ0EsU0FBUyx5QkFBVCxRQUEwQyw4QkFBMUM7QUFDQSxTQUFTLGdCQUFULFFBQWlDLHFCQUFqQztBQUNBLFNBQVMsSUFBVCxRQUFxQixXQUFyQjtBQUNBLFNBQVMsS0FBVCxFQUE0QixLQUE1QixRQUF5QyxhQUF6QztBQUNBLFNBQVMsaUJBQVQsUUFBa0Msc0JBQWxDO0FBQ0EsU0FBUyxtQkFBVCxRQUFvQyxpQkFBcEM7QUFDQSxTQUFTLG1CQUFULFFBQW9DLGNBQXBDO0FBRUEsTUFBTSxvQkFBTixDQUEwQjtBQUN4QixnQkFBb0IsRUFBcEIsRUFBcUM7QUFBakIsYUFBQSxFQUFBLEdBQUEsRUFBQTtBQUFxQjtBQUN6QyxXQUFJO0FBQ0YsZUFBTyxLQUFLLEVBQUwsQ0FBUSxJQUFSLEVBQVA7QUFDRDtBQUVELFdBQUk7QUFDRixlQUFPLFdBQVcsS0FBSyxFQUFMLENBQVEsT0FBUixDQUFnQixHQUEzQixFQUFnQyxJQUFoQyxDQUFQO0FBQ0Q7QUFSdUI7QUFXMUIsT0FBTSxTQUFVLFVBQVYsQ0FBcUIsR0FBckIsRUFBdUMsUUFBdkMsRUFBaUU7QUFDckUsUUFBSSxLQUFKO0FBRUEsUUFBSSxjQUFKO0FBRUEsT0FBRztBQUNELHlCQUFpQixTQUFTLElBQVQsRUFBakI7QUFDRCxLQUZELFFBRVMsQ0FBQyxlQUFlLElBRnpCO0FBSUEsUUFBSSxTQUFTLGVBQWUsS0FBNUI7QUFFQSxRQUFJLE1BQUo7QUFFQSxXQUFPLE1BQVA7QUFDRDtBQUVELE9BQU0sU0FBVSxhQUFWLENBQ0osT0FESSxFQUVKLElBRkksRUFHSixXQUhJLEVBSUosTUFKSSxFQUtKLGVBQTZCLElBQUksbUJBQUosRUFMekIsRUFLa0Q7QUFFdEQsUUFBSSxLQUFLLE1BQU0sT0FBTixDQUFjLE9BQWQs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QUF2RCxFQUFiO0FBQ0QsS0FIRCxNQUdPO0FBQ0wsY0FBTSxJQUFJLEtBQUosQ0FBVSxvRUFBVixDQUFOO0FBQ0Q7QUFFRCxXQUFPLGlCQUFpQixFQUFqQixFQUFxQixVQUFyQixFQUFpQyxVQUFqQyxFQUE2QyxJQUE3QyxDQUFQO0FBQ0QiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBEaWN0LFxuICBEeW5hbWljU2NvcGUsXG4gIEVudmlyb25tZW50LFxuICBJbnZvY2F0aW9uLFxuICBKaXRPckFvdEJsb2NrLFxuICBSZW5kZXJSZXN1bHQsXG4gIFJpY2hJdGVyYXRvclJlc3VsdCxcbiAgU3ludGF4Q29tcGlsYXRpb25Db250ZXh0LFxuICBXaXRoQW90U3RhdGljTGF5b3V0LFxuICBXaXRoSml0U3RhdGljTGF5b3V0LFxuICBUZW1wbGF0ZUl0ZXJhdG9yLFxuICBDdXJzb3IsXG4gIENvbXBvbmVudERlZmluaXRpb24sXG4gIEppdFJ1bnRpbWVDb250ZXh0LFxuICBBb3RSdW50aW1lQ29udGV4dCxcbiAgRWxlbWVudEJ1aWxkZXIsXG59IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgUGF0aFJlZmVyZW5jZSB9IGZyb20gJ0BnbGltbWVyL3JlZmVyZW5jZSc7XG5pbXBvcnQgeyBleHBlY3QgfSBmcm9tICdAZ2xpbW1lci91dGlsJztcbmltcG9ydCB7IGNhcGFiaWxpdHlGbGFnc0Zyb20gfSBmcm9tICcuL2NhcGFiaWxpdGllcyc7XG5pbXBvcnQgeyBoYXNTdGF0aWNMYXlvdXRDYXBhYmlsaXR5IH0gZnJvbSAnLi9jb21waWxlZC9vcGNvZGVzL2NvbXBvbmVudCc7XG5pbXBvcnQgeyByZXNvbHZlQ29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnQvcmVzb2x2ZSc7XG5pbXBvcnQgeyBBUkdTIH0gZnJvbSAnLi9zeW1ib2xzJztcbmltcG9ydCB7IEFvdFZNLCBJbnRlcm5hbFZNLCBKaXRWTSB9IGZyb20gJy4vdm0vYXBwZW5kJztcbmltcG9ydCB7IE5ld0VsZW1lbnRCdWlsZGVyIH0gZnJvbSAnLi92bS9lbGVtZW50LWJ1aWxkZXInO1xuaW1wb3J0IHsgRGVmYXVsdER5bmFtaWNTY29wZSB9IGZyb20gJy4vZHluYW1pYy1zY29wZSc7XG5pbXBvcnQgeyBVTkRFRklORURfUkVGRVJFTkNFIH0gZnJvbSAnLi9yZWZlcmVuY2VzJztcblxuY2xhc3MgVGVtcGxhdGVJdGVyYXRvckltcGw8QyBleHRlbmRzIEppdE9yQW90QmxvY2s+IGltcGxlbWVudHMgVGVtcGxhdGVJdGVyYXRvciB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgdm06IEludGVybmFsVk08Qz4pIHt9XG4gIG5leHQoKTogUmljaEl0ZXJhdG9yUmVzdWx0PG51bGwsIFJlbmRlclJlc3VsdD4ge1xuICAgIHJldHVybiB0aGlzLnZtLm5leHQoKTtcbiAgfVxuXG4gIHN5bmMoKTogUmVuZGVyUmVzdWx0IHtcbiAgICByZXR1cm4gcmVuZGVyU3luYyh0aGlzLnZtLnJ1bnRpbWUuZW52LCB0aGlzKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyU3luYyhlbnY6IEVudmlyb25tZW50LCBpdGVyYXRvcjogVGVtcGxhdGVJdGVyYXRvcik6IFJlbmRlclJlc3VsdCB7XG4gIGVudi5iZWdpbigpO1xuXG4gIGxldCBpdGVyYXRvclJlc3VsdDogSXRlcmF0b3JSZXN1bHQ8UmVuZGVyUmVzdWx0PjtcblxuICBkbyB7XG4gICAgaXRlcmF0b3JSZXN1bHQgPSBpdGVyYXRvci5uZXh0KCkgYXMgSXRlcmF0b3JSZXN1bHQ8UmVuZGVyUmVzdWx0PjtcbiAgfSB3aGlsZSAoIWl0ZXJhdG9yUmVzdWx0LmRvbmUpO1xuXG4gIGxldCByZXN1bHQgPSBpdGVyYXRvclJlc3VsdC52YWx1ZTtcblxuICBlbnYuY29tbWl0KCk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlckFvdE1haW4oXG4gIHJ1bnRpbWU6IEFvdFJ1bnRpbWVDb250ZXh0LFxuICBzZWxmOiBQYXRoUmVmZXJlbmNlLFxuICB0cmVlQnVpbGRlcjogRWxlbWVudEJ1aWxkZXIsXG4gIGhhbmRsZTogbnVtYmVyLFxuICBkeW5hbWljU2NvcGU6IER5bmFtaWNTY29wZSA9IG5ldyBEZWZhdWx0RHluYW1pY1Njb3BlKClcbik6IFRlbXBsYXRlSXRlcmF0b3Ige1xuICBsZXQgdm0gPSBBb3RWTS5pbml0aWFsKHJ1bnRpbWUsIHsgc2VsZiwgZHluYW1pY1Njb3BlLCB0cmVlQnVpbGRlciwgaGFuZGxlIH0pO1xuICByZXR1cm4gbmV3IFRlbXBsYXRlSXRlcmF0b3JJbXBsKHZtKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlckFvdChcbiAgcnVudGltZTogQW90UnVudGltZUNvbnRleHQsXG4gIGhhbmRsZTogbnVtYmVyLFxuICBjdXJzb3I6IEN1cnNvcixcbiAgc2VsZjogUGF0aFJlZmVyZW5jZSA9IFVOREVGSU5FRF9SRUZFUkVOQ0Vcbik6IFRlbXBsYXRlSXRlcmF0b3Ige1xuICBsZXQgdHJlZUJ1aWxkZXIgPSBOZXdFbGVtZW50QnVpbGRlci5mb3JJbml0aWFsUmVuZGVyKHJ1bnRpbWUuZW52LCBjdXJzb3IpO1xuICBsZXQgZHluYW1pY1Njb3BlID0gbmV3IERlZmF1bHREeW5hbWljU2NvcGUoKTtcbiAgbGV0IHZtID0gQW90Vk0uaW5pdGlhbChydW50aW1lLCB7IHNlbGYsIGR5bmFtaWNTY29wZSwgdHJlZUJ1aWxkZXIsIGhhbmRsZSB9KTtcbiAgcmV0dXJuIG5ldyBUZW1wbGF0ZUl0ZXJhdG9ySW1wbCh2bSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJKaXRNYWluKFxuICBydW50aW1lOiBKaXRSdW50aW1lQ29udGV4dCxcbiAgY29udGV4dDogU3ludGF4Q29tcGlsYXRpb25Db250ZXh0LFxuICBzZWxmOiBQYXRoUmVmZXJlbmNlLFxuICB0cmVlQnVpbGRlcjogRWxlbWVudEJ1aWxkZXIsXG4gIGhhbmRsZTogbnVtYmVyLFxuICBkeW5hbWljU2NvcGU6IER5bmFtaWNTY29wZSA9IG5ldyBEZWZhdWx0RHluYW1pY1Njb3BlKClcbik6IFRlbXBsYXRlSXRlcmF0b3Ige1xuICBsZXQgdm0gPSBKaXRWTS5pbml0aWFsKHJ1bnRpbWUsIGNvbnRleHQsIHsgc2VsZiwgZHluYW1pY1Njb3BlLCB0cmVlQnVpbGRlciwgaGFuZGxlIH0pO1xuICByZXR1cm4gbmV3IFRlbXBsYXRlSXRlcmF0b3JJbXBsKHZtKTtcbn1cblxuZXhwb3J0IHR5cGUgUmVuZGVyQ29tcG9uZW50QXJncyA9IERpY3Q8UGF0aFJlZmVyZW5jZT47XG5cbmZ1bmN0aW9uIHJlbmRlckludm9jYXRpb248QyBleHRlbmRzIEppdE9yQW90QmxvY2s+KFxuICB2bTogSW50ZXJuYWxWTTxDPixcbiAgaW52b2NhdGlvbjogSW52b2NhdGlvbixcbiAgZGVmaW5pdGlvbjogQ29tcG9uZW50RGVmaW5pdGlvbixcbiAgYXJnczogUmVuZGVyQ29tcG9uZW50QXJnc1xuKTogVGVtcGxhdGVJdGVyYXRvciB7XG4gIC8vIEdldCBhIGxpc3Qgb2YgdHVwbGVzIG9mIGFyZ3VtZW50IG5hbWVzIGFuZCByZWZlcmVuY2VzLCBsaWtlXG4gIC8vIFtbJ3RpdGxlJywgcmVmZXJlbmNlXSwgWyduYW1lJywgcmVmZXJlbmNlXV1cbiAgY29uc3QgYXJnTGlzdCA9IE9iamVjdC5rZXlzKGFyZ3MpLm1hcChrZXkgPT4gW2tleSwgYXJnc1trZXldXSk7XG5cbiAgY29uc3QgYmxvY2tOYW1lcyA9IFsnbWFpbicsICdlbHNlJywgJ2F0dHJzJ107XG4gIC8vIFByZWZpeCBhcmd1bWVudCBuYW1lcyB3aXRoIGBAYCBzeW1ib2xcbiAgY29uc3QgYXJnTmFtZXMgPSBhcmdMaXN0Lm1hcCgoW25hbWVdKSA9PiBgQCR7bmFtZX1gKTtcblxuICB2bS5wdXNoRnJhbWUoKTtcblxuICAvLyBQdXNoIGJsb2NrcyBvbiB0byB0aGUgc3RhY2ssIHRocmVlIHN0YWNrIHZhbHVlcyBwZXIgYmxvY2tcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAzICogYmxvY2tOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIHZtLnN0YWNrLnB1c2gobnVsbCk7XG4gIH1cblxuICB2bS5zdGFjay5wdXNoKG51bGwpO1xuXG4gIC8vIEZvciBlYWNoIGFyZ3VtZW50LCBwdXNoIGl0cyBiYWNraW5nIHJlZmVyZW5jZSBvbiB0byB0aGUgc3RhY2tcbiAgYXJnTGlzdC5mb3JFYWNoKChbLCByZWZlcmVuY2VdKSA9PiB7XG4gICAgdm0uc3RhY2sucHVzaChyZWZlcmVuY2UpO1xuICB9KTtcblxuICAvLyBDb25maWd1cmUgVk0gYmFzZWQgb24gYmxvY2tzIGFuZCBhcmdzIGp1c3QgcHVzaGVkIG9uIHRvIHRoZSBzdGFjay5cbiAgdm1bQVJHU10uc2V0dXAodm0uc3RhY2ssIGFyZ05hbWVzLCBibG9ja05hbWVzLCAwLCB0cnVlKTtcblxuICAvLyBOZWVkZWQgZm9yIHRoZSBPcC5NYWluIG9wY29kZTogYXJndW1lbnRzLCBjb21wb25lbnQgaW52b2NhdGlvbiBvYmplY3QsIGFuZFxuICAvLyBjb21wb25lbnQgZGVmaW5pdGlvbi5cbiAgdm0uc3RhY2sucHVzaCh2bVtBUkdTXSk7XG4gIHZtLnN0YWNrLnB1c2goaW52b2NhdGlvbik7XG4gIHZtLnN0YWNrLnB1c2goZGVmaW5pdGlvbik7XG5cbiAgcmV0dXJuIG5ldyBUZW1wbGF0ZUl0ZXJhdG9ySW1wbCh2bSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJBb3RDb21wb25lbnQ8Uj4oXG4gIHJ1bnRpbWU6IEFvdFJ1bnRpbWVDb250ZXh0PFI+LFxuICB0cmVlQnVpbGRlcjogRWxlbWVudEJ1aWxkZXIsXG4gIG1haW46IG51bWJlcixcbiAgbmFtZTogc3RyaW5nLFxuICBhcmdzOiBSZW5kZXJDb21wb25lbnRBcmdzID0ge30sXG4gIGR5bmFtaWNTY29wZTogRHluYW1pY1Njb3BlID0gbmV3IERlZmF1bHREeW5hbWljU2NvcGUoKVxuKTogVGVtcGxhdGVJdGVyYXRvciB7XG4gIGxldCB2bSA9IEFvdFZNLmVtcHR5KHJ1bnRpbWUsIHsgdHJlZUJ1aWxkZXIsIGhhbmRsZTogbWFpbiwgZHluYW1pY1Njb3BlIH0pO1xuXG4gIGNvbnN0IGRlZmluaXRpb24gPSBleHBlY3QoXG4gICAgcmVzb2x2ZUNvbXBvbmVudCh2bS5ydW50aW1lLnJlc29sdmVyLCBuYW1lKSxcbiAgICBgY291bGQgbm90IGZpbmQgY29tcG9uZW50IFwiJHtuYW1lfVwiYFxuICApO1xuXG4gIGNvbnN0IHsgbWFuYWdlciwgc3RhdGUgfSA9IGRlZmluaXRpb247XG5cbiAgY29uc3QgY2FwYWJpbGl0aWVzID0gY2FwYWJpbGl0eUZsYWdzRnJvbShtYW5hZ2VyLmdldENhcGFiaWxpdGllcyhzdGF0ZSkpO1xuXG4gIGxldCBpbnZvY2F0aW9uO1xuXG4gIGlmIChoYXNTdGF0aWNMYXlvdXRDYXBhYmlsaXR5KGNhcGFiaWxpdGllcywgbWFuYWdlcikpIHtcbiAgICBpbnZvY2F0aW9uID0gKG1hbmFnZXIgYXMgV2l0aEFvdFN0YXRpY0xheW91dCkuZ2V0QW90U3RhdGljTGF5b3V0KHN0YXRlLCB2bS5ydW50aW1lLnJlc29sdmVyKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZva2UgY29tcG9uZW50cyB3aXRoIGR5bmFtaWMgbGF5b3V0cyBhcyBhIHJvb3QgY29tcG9uZW50LicpO1xuICB9XG5cbiAgcmV0dXJuIHJlbmRlckludm9jYXRpb24odm0sIGludm9jYXRpb24sIGRlZmluaXRpb24sIGFyZ3MpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVySml0Q29tcG9uZW50KFxuICBydW50aW1lOiBKaXRSdW50aW1lQ29udGV4dCxcbiAgdHJlZUJ1aWxkZXI6IEVsZW1lbnRCdWlsZGVyLFxuICBjb250ZXh0OiBTeW50YXhDb21waWxhdGlvbkNvbnRleHQsXG4gIG1haW46IG51bWJlcixcbiAgbmFtZTogc3RyaW5nLFxuICBhcmdzOiBSZW5kZXJDb21wb25lbnRBcmdzID0ge30sXG4gIGR5bmFtaWNTY29wZTogRHluYW1pY1Njb3BlID0gbmV3IERlZmF1bHREeW5hbWljU2NvcGUoKVxuKTogVGVtcGxhdGVJdGVyYXRvciB7XG4gIGxldCB2bSA9IEppdFZNLmVtcHR5KHJ1bnRpbWUsIHsgdHJlZUJ1aWxkZXIsIGhhbmRsZTogbWFpbiwgZHluYW1pY1Njb3BlIH0sIGNvbnRleHQpO1xuXG4gIGNvbnN0IGRlZmluaXRpb24gPSBleHBlY3QoXG4gICAgcmVzb2x2ZUNvbXBvbmVudCh2bS5ydW50aW1lLnJlc29sdmVyLCBuYW1lKSxcbiAgICBgY291bGQgbm90IGZpbmQgY29tcG9uZW50IFwiJHtuYW1lfVwiYFxuICApO1xuXG4gIGNvbnN0IHsgbWFuYWdlciwgc3RhdGUgfSA9IGRlZmluaXRpb247XG5cbiAgY29uc3QgY2FwYWJpbGl0aWVzID0gY2FwYWJpbGl0eUZsYWdzRnJvbShtYW5hZ2VyLmdldENhcGFiaWxpdGllcyhzdGF0ZSkpO1xuXG4gIGxldCBpbnZvY2F0aW9uOiBJbnZvY2F0aW9uO1xuXG4gIGlmIChoYXNTdGF0aWNMYXlvdXRDYXBhYmlsaXR5KGNhcGFiaWxpdGllcywgbWFuYWdlcikpIHtcbiAgICBsZXQgbGF5b3V0ID0gKG1hbmFnZXIgYXMgV2l0aEppdFN0YXRpY0xheW91dCkuZ2V0Sml0U3RhdGljTGF5b3V0KHN0YXRlLCB2bS5ydW50aW1lLnJlc29sdmVyKTtcbiAgICBpbnZvY2F0aW9uID0geyBoYW5kbGU6IGxheW91dC5jb21waWxlKGNvbnRleHQpLCBzeW1ib2xUYWJsZTogbGF5b3V0LnN5bWJvbFRhYmxlIH07XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52b2tlIGNvbXBvbmVudHMgd2l0aCBkeW5hbWljIGxheW91dHMgYXMgYSByb290IGNvbXBvbmVudC4nKTtcbiAgfVxuXG4gIHJldHVybiByZW5kZXJJbnZvY2F0aW9uKHZtLCBpbnZvY2F0aW9uLCBkZWZpbml0aW9uLCBhcmdzKTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=