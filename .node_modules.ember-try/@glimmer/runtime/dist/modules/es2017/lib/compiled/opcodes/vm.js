import { CONSTANT_TAG, isConst, isModified, ReferenceCache, value, validate } from '@glimmer/reference';
import { initializeGuid, assert } from '@glimmer/util';

import { stackAssert } from './assert';
import { APPEND_OPCODES, UpdatingOpcode } from '../../opcodes';
import { PrimitiveReference } from '../../references';

import { CONSTANTS } from '../../symbols';
APPEND_OPCODES.add(38 /* ChildScope */, vm => vm.pushChildScope());
APPEND_OPCODES.add(39 /* PopScope */, vm => vm.popScope());
APPEND_OPCODES.add(58 /* PushDynamicScope */, vm => vm.pushDynamicScope());
APPEND_OPCODES.add(59 /* PopDynamicScope */, vm => vm.popDynamicScope());
APPEND_OPCODES.add(28 /* Constant */, (vm, { op1: other }) => {
    vm.stack.push(vm[CONSTANTS].getOther(other));
});
APPEND_OPCODES.add(29 /* Primitive */, (vm, { op1: primitive }) => {
    let stack = vm.stack;
    let flag = primitive & 7; // 111
    let value = primitive >> 3;
    switch (flag) {
        case 0 /* NUMBER */:
            stack.push(value);
            break;
        case 1 /* FLOAT */:
            stack.push(vm[CONSTANTS].getNumber(value));
            break;
        case 2 /* STRING */:
            stack.push(vm[CONSTANTS].getString(value));
            break;
        case 3 /* BOOLEAN_OR_VOID */:
            stack.pushRaw(primitive);
            break;
        case 4 /* NEGATIVE */:
            stack.push(vm[CONSTANTS].getNumber(value));
            break;
        case 5 /* BIG_NUM */:
            stack.push(vm[CONSTANTS].getNumber(value));
            break;
    }
});
APPEND_OPCODES.add(30 /* PrimitiveReference */, vm => {
    let stack = vm.stack;
    stack.push(PrimitiveReference.create(stack.pop()));
});
APPEND_OPCODES.add(31 /* ReifyU32 */, vm => {
    let stack = vm.stack;
    stack.push(stack.peek().value());
});
APPEND_OPCODES.add(32 /* Dup */, (vm, { op1: register, op2: offset }) => {
    let position = vm.fetchValue(register) - offset;
    vm.stack.dup(position);
});
APPEND_OPCODES.add(33 /* Pop */, (vm, { op1: count }) => {
    vm.stack.pop(count);
});
APPEND_OPCODES.add(34 /* Load */, (vm, { op1: register }) => {
    vm.load(register);
});
APPEND_OPCODES.add(35 /* Fetch */, (vm, { op1: register }) => {
    vm.fetch(register);
});
APPEND_OPCODES.add(57 /* BindDynamicScope */, (vm, { op1: _names }) => {
    let names = vm[CONSTANTS].getArray(_names);
    vm.bindDynamicScope(names);
});
APPEND_OPCODES.add(68 /* Enter */, (vm, { op1: args }) => {
    vm.enter(args);
});
APPEND_OPCODES.add(69 /* Exit */, vm => {
    vm.exit();
});
APPEND_OPCODES.add(62 /* PushSymbolTable */, (vm, { op1: _table }) => {
    let stack = vm.stack;
    stack.push(vm[CONSTANTS].getTemplateMeta(_table));
});
APPEND_OPCODES.add(61 /* PushBlockScope */, vm => {
    let stack = vm.stack;
    stack.push(vm.scope());
});
APPEND_OPCODES.add(60 /* CompileBlock */, vm => {
    let stack = vm.stack;
    let block = stack.pop();
    if (block) {
        stack.push(vm.compile(block));
    } else {
        stack.push(null);
    }
}, 'jit');
APPEND_OPCODES.add(63 /* InvokeYield */, vm => {
    let { stack } = vm;
    let handle = stack.pop();
    let scope = stack.pop();
    let table = stack.pop();
    (false && assert(table === null || table && typeof table === 'object' && Array.isArray(table.parameters), stackAssert('Option<BlockSymbolTable>', table)));

    let args = stack.pop();
    if (table === null) {
        // To balance the pop{Frame,Scope}
        vm.pushFrame();
        vm.pushScope(scope); // Could be null but it doesnt matter as it is immediatelly popped.
        return;
    }
    let invokingScope = scope;
    // If necessary, create a child scope
    {
        let locals = table.parameters;
        let localsCount = locals.length;
        if (localsCount > 0) {
            invokingScope = invokingScope.child();
            for (let i = 0; i < localsCount; i++) {
                invokingScope.bindSymbol(locals[i], args.at(i));
            }
        }
    }
    vm.pushFrame();
    vm.pushScope(invokingScope);
    vm.call(handle);
});
APPEND_OPCODES.add(64 /* JumpIf */, (vm, { op1: target }) => {
    let reference = vm.stack.pop();
    if (isConst(reference)) {
        if (reference.value()) {
            vm.goto(target);
        }
    } else {
        let cache = new ReferenceCache(reference);
        if (cache.peek()) {
            vm.goto(target);
        }
        vm.updateWith(new Assert(cache));
    }
});
APPEND_OPCODES.add(65 /* JumpUnless */, (vm, { op1: target }) => {
    let reference = vm.stack.pop();
    if (isConst(reference)) {
        if (!reference.value()) {
            vm.goto(target);
        }
    } else {
        let cache = new ReferenceCache(reference);
        if (!cache.peek()) {
            vm.goto(target);
        }
        vm.updateWith(new Assert(cache));
    }
});
APPEND_OPCODES.add(66 /* JumpEq */, (vm, { op1: target, op2: comparison }) => {
    let other = vm.stack.peek();
    if (other === comparison) {
        vm.goto(target);
    }
});
APPEND_OPCODES.add(67 /* AssertSame */, vm => {
    let reference = vm.stack.peek();
    if (!isConst(reference)) {
        vm.updateWith(Assert.initialize(new ReferenceCache(reference)));
    }
});
APPEND_OPCODES.add(70 /* ToBoolean */, vm => {
    let { env, stack } = vm;
    stack.push(env.toConditionalReference(stack.pop()));
});
export class Assert extends UpdatingOpcode {
    constructor(cache) {
        super();
        this.type = 'assert';
        this.tag = cache.tag;
        this.cache = cache;
    }
    static initialize(cache) {
        let assert = new Assert(cache);
        cache.peek();
        return assert;
    }
    evaluate(vm) {
        let { cache } = this;
        if (isModified(cache.revalidate())) {
            vm.throw();
        }
    }
}
export class JumpIfNotModifiedOpcode extends UpdatingOpcode {
    constructor(tag, target) {
        super();
        this.target = target;
        this.type = 'jump-if-not-modified';
        this.tag = tag;
        this.lastRevision = value(tag);
    }
    evaluate(vm) {
        let { tag, target, lastRevision } = this;
        if (!vm.alwaysRevalidate && validate(tag, lastRevision)) {
            vm.goto(target);
        }
    }
    didModify() {
        this.lastRevision = value(this.tag);
    }
}
export class DidModifyOpcode extends UpdatingOpcode {
    constructor(target) {
        super();
        this.target = target;
        this.type = 'did-modify';
        this.tag = CONSTANT_TAG;
    }
    evaluate() {
        this.target.didModify();
    }
}
export class LabelOpcode {
    constructor(label) {
        this.tag = CONSTANT_TAG;
        this.type = 'label';
        this.label = null;
        this.prev = null;
        this.next = null;
        initializeGuid(this);
        this.label = label;
    }
    evaluate() {}
    inspect() {
        return `${this.label} [${this._guid}]`;
    }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3J1bnRpbWUvbGliL2NvbXBpbGVkL29wY29kZXMvdm0udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0EsU0FDRSxZQURGLEVBRUUsT0FGRixFQUdFLFVBSEYsRUFJRSxjQUpGLEVBT0UsS0FQRixFQVFFLFFBUkYsUUFTTyxvQkFUUDtBQVVBLFNBQVMsY0FBVCxFQUF5QixNQUF6QixRQUF1QyxlQUF2Qzs7QUFVQSxTQUFTLFdBQVQsUUFBNEIsVUFBNUI7QUFDQSxTQUFTLGNBQVQsRUFBeUIsY0FBekIsUUFBK0MsZUFBL0M7QUFDQSxTQUFTLGtCQUFULFFBQW1DLGtCQUFuQzs7QUFJQSxTQUFTLFNBQVQsUUFBMEIsZUFBMUI7QUFHQSxlQUFlLEdBQWYsQ0FBa0IsRUFBbEIsQ0FBa0IsZ0JBQWxCLEVBQWtDLE1BQU0sR0FBRyxjQUFILEVBQXhDO0FBRUEsZUFBZSxHQUFmLENBQWtCLEVBQWxCLENBQWtCLGNBQWxCLEVBQWdDLE1BQU0sR0FBRyxRQUFILEVBQXRDO0FBRUEsZUFBZSxHQUFmLENBQWtCLEVBQWxCLENBQWtCLHNCQUFsQixFQUF3QyxNQUFNLEdBQUcsZ0JBQUgsRUFBOUM7QUFFQSxlQUFlLEdBQWYsQ0FBa0IsRUFBbEIsQ0FBa0IscUJBQWxCLEVBQXVDLE1BQU0sR0FBRyxlQUFILEVBQTdDO0FBRUEsZUFBZSxHQUFmLENBQWtCLEVBQWxCLENBQWtCLGNBQWxCLEVBQWdDLENBQUMsRUFBRCxFQUFLLEVBQUUsS0FBSyxLQUFQLEVBQUwsS0FBdUI7QUFDckQsT0FBRyxLQUFILENBQVMsSUFBVCxDQUFjLEdBQUcsU0FBSCxFQUFjLFFBQWQsQ0FBdUIsS0FBdkIsQ0FBZDtBQUNELENBRkQ7QUFJQSxlQUFlLEdBQWYsQ0FBa0IsRUFBbEIsQ0FBa0IsZUFBbEIsRUFBaUMsQ0FBQyxFQUFELEVBQUssRUFBRSxLQUFLLFNBQVAsRUFBTCxLQUEyQjtBQUMxRCxRQUFJLFFBQVEsR0FBRyxL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RCxPQUFNLE1BQU8sZUFBUCxTQUErQixjQUEvQixDQUE2QztBQUtqRCxnQkFBb0IsTUFBcEIsRUFBbUQ7QUFDakQ7QUFEa0IsYUFBQSxNQUFBLEdBQUEsTUFBQTtBQUpiLGFBQUEsSUFBQSxHQUFPLFlBQVA7QUFNTCxhQUFLLEdBQUwsR0FBVyxZQUFYO0FBQ0Q7QUFFRCxlQUFRO0FBQ04sYUFBSyxNQUFMLENBQVksU0FBWjtBQUNEO0FBWmdEO0FBZW5ELE9BQU0sTUFBTyxXQUFQLENBQWtCO0FBU3RCLGdCQUFZLEtBQVosRUFBeUI7QUFSbEIsYUFBQSxHQUFBLEdBQVcsWUFBWDtBQUNBLGFBQUEsSUFBQSxHQUFPLE9BQVA7QUFDQSxhQUFBLEtBQUEsR0FBd0IsSUFBeEI7QUFHUCxhQUFBLElBQUEsR0FBWSxJQUFaO0FBQ0EsYUFBQSxJQUFBLEdBQVksSUFBWjtBQUdFLHVCQUFlLElBQWY7QUFDQSxhQUFLLEtBQUwsR0FBYSxLQUFiO0FBQ0Q7QUFFRCxlQUFRLENBQUs7QUFFYixjQUFPO0FBQ0wsZUFBTyxHQUFHLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxHQUFuQztBQUNEO0FBbEJxQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFByaW1pdGl2ZVR5cGUsIENvbXBpbGFibGVUZW1wbGF0ZSwgT3B0aW9uLCBPcCB9IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHtcbiAgQ09OU1RBTlRfVEFHLFxuICBpc0NvbnN0LFxuICBpc01vZGlmaWVkLFxuICBSZWZlcmVuY2VDYWNoZSxcbiAgUmV2aXNpb24sXG4gIFRhZyxcbiAgdmFsdWUsXG4gIHZhbGlkYXRlLFxufSBmcm9tICdAZ2xpbW1lci9yZWZlcmVuY2UnO1xuaW1wb3J0IHsgaW5pdGlhbGl6ZUd1aWQsIGFzc2VydCB9IGZyb20gJ0BnbGltbWVyL3V0aWwnO1xuaW1wb3J0IHtcbiAgQ2hlY2tOdW1iZXIsXG4gIGNoZWNrLFxuICBDaGVja0luc3RhbmNlb2YsXG4gIENoZWNrT3B0aW9uLFxuICBDaGVja0Jsb2NrU3ltYm9sVGFibGUsXG4gIENoZWNrSGFuZGxlLFxuICBDaGVja1ByaW1pdGl2ZSxcbn0gZnJvbSAnQGdsaW1tZXIvZGVidWcnO1xuaW1wb3J0IHsgc3RhY2tBc3NlcnQgfSBmcm9tICcuL2Fzc2VydCc7XG5pbXBvcnQgeyBBUFBFTkRfT1BDT0RFUywgVXBkYXRpbmdPcGNvZGUgfSBmcm9tICcuLi8uLi9vcGNvZGVzJztcbmltcG9ydCB7IFByaW1pdGl2ZVJlZmVyZW5jZSB9IGZyb20gJy4uLy4uL3JlZmVyZW5jZXMnO1xuaW1wb3J0IHsgVXBkYXRpbmdWTSB9IGZyb20gJy4uLy4uL3ZtJztcbmltcG9ydCB7IFZNQXJndW1lbnRzSW1wbCB9IGZyb20gJy4uLy4uL3ZtL2FyZ3VtZW50cyc7XG5pbXBvcnQgeyBDaGVja1JlZmVyZW5jZSwgQ2hlY2tTY29wZSB9IGZyb20gJy4vLWRlYnVnLXN0cmlwJztcbmltcG9ydCB7IENPTlNUQU5UUyB9IGZyb20gJy4uLy4uL3N5bWJvbHMnO1xuaW1wb3J0IHsgSW50ZXJuYWxKaXRWTSB9IGZyb20gJy4uLy4uL3ZtL2FwcGVuZCc7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5DaGlsZFNjb3BlLCB2bSA9PiB2bS5wdXNoQ2hpbGRTY29wZSgpKTtcblxuQVBQRU5EX09QQ09ERVMuYWRkKE9wLlBvcFNjb3BlLCB2bSA9PiB2bS5wb3BTY29wZSgpKTtcblxuQVBQRU5EX09QQ09ERVMuYWRkKE9wLlB1c2hEeW5hbWljU2NvcGUsIHZtID0+IHZtLnB1c2hEeW5hbWljU2NvcGUoKSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5Qb3BEeW5hbWljU2NvcGUsIHZtID0+IHZtLnBvcER5bmFtaWNTY29wZSgpKTtcblxuQVBQRU5EX09QQ09ERVMuYWRkKE9wLkNvbnN0YW50LCAodm0sIHsgb3AxOiBvdGhlciB9KSA9PiB7XG4gIHZtLnN0YWNrLnB1c2godm1bQ09OU1RBTlRTXS5nZXRPdGhlcihvdGhlcikpO1xufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5QcmltaXRpdmUsICh2bSwgeyBvcDE6IHByaW1pdGl2ZSB9KSA9PiB7XG4gIGxldCBzdGFjayA9IHZtLnN0YWNrO1xuICBsZXQgZmxhZyA9IHByaW1pdGl2ZSAmIDc7IC8vIDExMVxuICBsZXQgdmFsdWUgPSBwcmltaXRpdmUgPj4gMztcblxuICBzd2l0Y2ggKGZsYWcpIHtcbiAgICBjYXNlIFByaW1pdGl2ZVR5cGUuTlVNQkVSOlxuICAgICAgc3RhY2sucHVzaCh2YWx1ZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFByaW1pdGl2ZVR5cGUuRkxPQVQ6XG4gICAgICBzdGFjay5wdXNoKHZtW0NPTlNUQU5UU10uZ2V0TnVtYmVyKHZhbHVlKSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFByaW1pdGl2ZVR5cGUuU1RSSU5HOlxuICAgICAgc3RhY2sucHVzaCh2bVtDT05TVEFOVFNdLmdldFN0cmluZyh2YWx1ZSkpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBQcmltaXRpdmVUeXBlLkJPT0xFQU5fT1JfVk9JRDpcbiAgICAgIHN0YWNrLnB1c2hSYXcocHJpbWl0aXZlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgUHJpbWl0aXZlVHlwZS5ORUdBVElWRTpcbiAgICAgIHN0YWNrLnB1c2godm1bQ09OU1RBTlRTXS5nZXROdW1iZXIodmFsdWUpKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgUHJpbWl0aXZlVHlwZS5CSUdfTlVNOlxuICAgICAgc3RhY2sucHVzaCh2bVtDT05TVEFOVFNdLmdldE51bWJlcih2YWx1ZSkpO1xuICAgICAgYnJlYWs7XG4gIH1cbn0pO1xuXG5BUFBFTkRfT1BDT0RFUy5hZGQoT3AuUHJpbWl0aXZlUmVmZXJlbmNlLCB2bSA9PiB7XG4gIGxldCBzdGFjayA9IHZtLnN0YWNrO1xuICBzdGFjay5wdXNoKFByaW1pdGl2ZVJlZmVyZW5jZS5jcmVhdGUoY2hlY2soc3RhY2sucG9wKCksIENoZWNrUHJpbWl0aXZlKSkpO1xufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5SZWlmeVUzMiwgdm0gPT4ge1xuICBsZXQgc3RhY2sgPSB2bS5zdGFjaztcbiAgc3RhY2sucHVzaChjaGVjayhzdGFjay5wZWVrKCksIENoZWNrUmVmZXJlbmNlKS52YWx1ZSgpKTtcbn0pO1xuXG5BUFBFTkRfT1BDT0RFUy5hZGQoT3AuRHVwLCAodm0sIHsgb3AxOiByZWdpc3Rlciwgb3AyOiBvZmZzZXQgfSkgPT4ge1xuICBsZXQgcG9zaXRpb24gPSBjaGVjayh2bS5mZXRjaFZhbHVlKHJlZ2lzdGVyKSwgQ2hlY2tOdW1iZXIpIC0gb2Zmc2V0O1xuICB2bS5zdGFjay5kdXAocG9zaXRpb24pO1xufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5Qb3AsICh2bSwgeyBvcDE6IGNvdW50IH0pID0+IHtcbiAgdm0uc3RhY2sucG9wKGNvdW50KTtcbn0pO1xuXG5BUFBFTkRfT1BDT0RFUy5hZGQoT3AuTG9hZCwgKHZtLCB7IG9wMTogcmVnaXN0ZXIgfSkgPT4ge1xuICB2bS5sb2FkKHJlZ2lzdGVyKTtcbn0pO1xuXG5BUFBFTkRfT1BDT0RFUy5hZGQoT3AuRmV0Y2gsICh2bSwgeyBvcDE6IHJlZ2lzdGVyIH0pID0+IHtcbiAgdm0uZmV0Y2gocmVnaXN0ZXIpO1xufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5CaW5kRHluYW1pY1Njb3BlLCAodm0sIHsgb3AxOiBfbmFtZXMgfSkgPT4ge1xuICBsZXQgbmFtZXMgPSB2bVtDT05TVEFOVFNdLmdldEFycmF5KF9uYW1lcyk7XG4gIHZtLmJpbmREeW5hbWljU2NvcGUobmFtZXMpO1xufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5FbnRlciwgKHZtLCB7IG9wMTogYXJncyB9KSA9PiB7XG4gIHZtLmVudGVyKGFyZ3MpO1xufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5FeGl0LCB2bSA9PiB7XG4gIHZtLmV4aXQoKTtcbn0pO1xuXG5BUFBFTkRfT1BDT0RFUy5hZGQoT3AuUHVzaFN5bWJvbFRhYmxlLCAodm0sIHsgb3AxOiBfdGFibGUgfSkgPT4ge1xuICBsZXQgc3RhY2sgPSB2bS5zdGFjaztcbiAgc3RhY2sucHVzaCh2bVtDT05TVEFOVFNdLmdldFRlbXBsYXRlTWV0YShfdGFibGUpKTtcbn0pO1xuXG5BUFBFTkRfT1BDT0RFUy5hZGQoT3AuUHVzaEJsb2NrU2NvcGUsIHZtID0+IHtcbiAgbGV0IHN0YWNrID0gdm0uc3RhY2s7XG4gIHN0YWNrLnB1c2godm0uc2NvcGUoKSk7XG59KTtcblxuQVBQRU5EX09QQ09ERVMuYWRkKFxuICBPcC5Db21waWxlQmxvY2ssXG4gICh2bTogSW50ZXJuYWxKaXRWTSkgPT4ge1xuICAgIGxldCBzdGFjayA9IHZtLnN0YWNrO1xuICAgIGxldCBibG9jayA9IHN0YWNrLnBvcDxPcHRpb248Q29tcGlsYWJsZVRlbXBsYXRlPiB8IDA+KCk7XG5cbiAgICBpZiAoYmxvY2spIHtcbiAgICAgIHN0YWNrLnB1c2godm0uY29tcGlsZShibG9jaykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFjay5wdXNoKG51bGwpO1xuICAgIH1cblxuICAgIGNoZWNrKHZtLnN0YWNrLnBlZWsoKSwgQ2hlY2tPcHRpb24oQ2hlY2tOdW1iZXIpKTtcbiAgfSxcbiAgJ2ppdCdcbik7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5JbnZva2VZaWVsZCwgdm0gPT4ge1xuICBsZXQgeyBzdGFjayB9ID0gdm07XG5cbiAgbGV0IGhhbmRsZSA9IGNoZWNrKHN0YWNrLnBvcCgpLCBDaGVja09wdGlvbihDaGVja0hhbmRsZSkpO1xuICBsZXQgc2NvcGUgPSBjaGVjayhzdGFjay5wb3AoKSwgQ2hlY2tPcHRpb24oQ2hlY2tTY29wZSkpO1xuICBsZXQgdGFibGUgPSBjaGVjayhzdGFjay5wb3AoKSwgQ2hlY2tPcHRpb24oQ2hlY2tCbG9ja1N5bWJvbFRhYmxlKSk7XG5cbiAgYXNzZXJ0KFxuICAgIHRhYmxlID09PSBudWxsIHx8ICh0YWJsZSAmJiB0eXBlb2YgdGFibGUgPT09ICdvYmplY3QnICYmIEFycmF5LmlzQXJyYXkodGFibGUucGFyYW1ldGVycykpLFxuICAgIHN0YWNrQXNzZXJ0KCdPcHRpb248QmxvY2tTeW1ib2xUYWJsZT4nLCB0YWJsZSlcbiAgKTtcblxuICBsZXQgYXJncyA9IGNoZWNrKHN0YWNrLnBvcCgpLCBDaGVja0luc3RhbmNlb2YoVk1Bcmd1bWVudHNJbXBsKSk7XG5cbiAgaWYgKHRhYmxlID09PSBudWxsKSB7XG4gICAgLy8gVG8gYmFsYW5jZSB0aGUgcG9we0ZyYW1lLFNjb3BlfVxuICAgIHZtLnB1c2hGcmFtZSgpO1xuICAgIHZtLnB1c2hTY29wZShzY29wZSEpOyAvLyBDb3VsZCBiZSBudWxsIGJ1dCBpdCBkb2VzbnQgbWF0dGVyIGFzIGl0IGlzIGltbWVkaWF0ZWxseSBwb3BwZWQuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbGV0IGludm9raW5nU2NvcGUgPSBzY29wZSE7XG5cbiAgLy8gSWYgbmVjZXNzYXJ5LCBjcmVhdGUgYSBjaGlsZCBzY29wZVxuICB7XG4gICAgbGV0IGxvY2FscyA9IHRhYmxlLnBhcmFtZXRlcnM7XG4gICAgbGV0IGxvY2Fsc0NvdW50ID0gbG9jYWxzLmxlbmd0aDtcblxuICAgIGlmIChsb2NhbHNDb3VudCA+IDApIHtcbiAgICAgIGludm9raW5nU2NvcGUgPSBpbnZva2luZ1Njb3BlLmNoaWxkKCk7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbG9jYWxzQ291bnQ7IGkrKykge1xuICAgICAgICBpbnZva2luZ1Njb3BlLmJpbmRTeW1ib2wobG9jYWxzIVtpXSwgYXJncy5hdChpKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdm0ucHVzaEZyYW1lKCk7XG4gIHZtLnB1c2hTY29wZShpbnZva2luZ1Njb3BlKTtcbiAgdm0uY2FsbChoYW5kbGUhKTtcbn0pO1xuXG5BUFBFTkRfT1BDT0RFUy5hZGQoT3AuSnVtcElmLCAodm0sIHsgb3AxOiB0YXJnZXQgfSkgPT4ge1xuICBsZXQgcmVmZXJlbmNlID0gY2hlY2sodm0uc3RhY2sucG9wKCksIENoZWNrUmVmZXJlbmNlKTtcblxuICBpZiAoaXNDb25zdChyZWZlcmVuY2UpKSB7XG4gICAgaWYgKHJlZmVyZW5jZS52YWx1ZSgpKSB7XG4gICAgICB2bS5nb3RvKHRhcmdldCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGxldCBjYWNoZSA9IG5ldyBSZWZlcmVuY2VDYWNoZShyZWZlcmVuY2UpO1xuXG4gICAgaWYgKGNhY2hlLnBlZWsoKSkge1xuICAgICAgdm0uZ290byh0YXJnZXQpO1xuICAgIH1cblxuICAgIHZtLnVwZGF0ZVdpdGgobmV3IEFzc2VydChjYWNoZSkpO1xuICB9XG59KTtcblxuQVBQRU5EX09QQ09ERVMuYWRkKE9wLkp1bXBVbmxlc3MsICh2bSwgeyBvcDE6IHRhcmdldCB9KSA9PiB7XG4gIGxldCByZWZlcmVuY2UgPSBjaGVjayh2bS5zdGFjay5wb3AoKSwgQ2hlY2tSZWZlcmVuY2UpO1xuXG4gIGlmIChpc0NvbnN0KHJlZmVyZW5jZSkpIHtcbiAgICBpZiAoIXJlZmVyZW5jZS52YWx1ZSgpKSB7XG4gICAgICB2bS5nb3RvKHRhcmdldCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGxldCBjYWNoZSA9IG5ldyBSZWZlcmVuY2VDYWNoZShyZWZlcmVuY2UpO1xuXG4gICAgaWYgKCFjYWNoZS5wZWVrKCkpIHtcbiAgICAgIHZtLmdvdG8odGFyZ2V0KTtcbiAgICB9XG5cbiAgICB2bS51cGRhdGVXaXRoKG5ldyBBc3NlcnQoY2FjaGUpKTtcbiAgfVxufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5KdW1wRXEsICh2bSwgeyBvcDE6IHRhcmdldCwgb3AyOiBjb21wYXJpc29uIH0pID0+IHtcbiAgbGV0IG90aGVyID0gY2hlY2sodm0uc3RhY2sucGVlaygpLCBDaGVja051bWJlcik7XG5cbiAgaWYgKG90aGVyID09PSBjb21wYXJpc29uKSB7XG4gICAgdm0uZ290byh0YXJnZXQpO1xuICB9XG59KTtcblxuQVBQRU5EX09QQ09ERVMuYWRkKE9wLkFzc2VydFNhbWUsIHZtID0+IHtcbiAgbGV0IHJlZmVyZW5jZSA9IGNoZWNrKHZtLnN0YWNrLnBlZWsoKSwgQ2hlY2tSZWZlcmVuY2UpO1xuXG4gIGlmICghaXNDb25zdChyZWZlcmVuY2UpKSB7XG4gICAgdm0udXBkYXRlV2l0aChBc3NlcnQuaW5pdGlhbGl6ZShuZXcgUmVmZXJlbmNlQ2FjaGUocmVmZXJlbmNlKSkpO1xuICB9XG59KTtcblxuQVBQRU5EX09QQ09ERVMuYWRkKE9wLlRvQm9vbGVhbiwgdm0gPT4ge1xuICBsZXQgeyBlbnYsIHN0YWNrIH0gPSB2bTtcbiAgc3RhY2sucHVzaChlbnYudG9Db25kaXRpb25hbFJlZmVyZW5jZShjaGVjayhzdGFjay5wb3AoKSwgQ2hlY2tSZWZlcmVuY2UpKSk7XG59KTtcblxuZXhwb3J0IGNsYXNzIEFzc2VydCBleHRlbmRzIFVwZGF0aW5nT3Bjb2RlIHtcbiAgc3RhdGljIGluaXRpYWxpemUoY2FjaGU6IFJlZmVyZW5jZUNhY2hlPHVua25vd24+KTogQXNzZXJ0IHtcbiAgICBsZXQgYXNzZXJ0ID0gbmV3IEFzc2VydChjYWNoZSk7XG4gICAgY2FjaGUucGVlaygpO1xuICAgIHJldHVybiBhc3NlcnQ7XG4gIH1cblxuICBwdWJsaWMgdHlwZSA9ICdhc3NlcnQnO1xuXG4gIHB1YmxpYyB0YWc6IFRhZztcblxuICBwcml2YXRlIGNhY2hlOiBSZWZlcmVuY2VDYWNoZTx1bmtub3duPjtcblxuICBjb25zdHJ1Y3RvcihjYWNoZTogUmVmZXJlbmNlQ2FjaGU8dW5rbm93bj4pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMudGFnID0gY2FjaGUudGFnO1xuICAgIHRoaXMuY2FjaGUgPSBjYWNoZTtcbiAgfVxuXG4gIGV2YWx1YXRlKHZtOiBVcGRhdGluZ1ZNKSB7XG4gICAgbGV0IHsgY2FjaGUgfSA9IHRoaXM7XG5cbiAgICBpZiAoaXNNb2RpZmllZChjYWNoZS5yZXZhbGlkYXRlKCkpKSB7XG4gICAgICB2bS50aHJvdygpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgSnVtcElmTm90TW9kaWZpZWRPcGNvZGUgZXh0ZW5kcyBVcGRhdGluZ09wY29kZSB7XG4gIHB1YmxpYyB0eXBlID0gJ2p1bXAtaWYtbm90LW1vZGlmaWVkJztcblxuICBwdWJsaWMgdGFnOiBUYWc7XG5cbiAgcHJpdmF0ZSBsYXN0UmV2aXNpb246IFJldmlzaW9uO1xuXG4gIGNvbnN0cnVjdG9yKHRhZzogVGFnLCBwcml2YXRlIHRhcmdldDogTGFiZWxPcGNvZGUpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMudGFnID0gdGFnO1xuICAgIHRoaXMubGFzdFJldmlzaW9uID0gdmFsdWUodGFnKTtcbiAgfVxuXG4gIGV2YWx1YXRlKHZtOiBVcGRhdGluZ1ZNKSB7XG4gICAgbGV0IHsgdGFnLCB0YXJnZXQsIGxhc3RSZXZpc2lvbiB9ID0gdGhpcztcblxuICAgIGlmICghdm0uYWx3YXlzUmV2YWxpZGF0ZSAmJiB2YWxpZGF0ZSh0YWcsIGxhc3RSZXZpc2lvbikpIHtcbiAgICAgIHZtLmdvdG8odGFyZ2V0KTtcbiAgICB9XG4gIH1cblxuICBkaWRNb2RpZnkoKSB7XG4gICAgdGhpcy5sYXN0UmV2aXNpb24gPSB2YWx1ZSh0aGlzLnRhZyk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIERpZE1vZGlmeU9wY29kZSBleHRlbmRzIFVwZGF0aW5nT3Bjb2RlIHtcbiAgcHVibGljIHR5cGUgPSAnZGlkLW1vZGlmeSc7XG5cbiAgcHVibGljIHRhZzogVGFnO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgdGFyZ2V0OiBKdW1wSWZOb3RNb2RpZmllZE9wY29kZSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy50YWcgPSBDT05TVEFOVF9UQUc7XG4gIH1cblxuICBldmFsdWF0ZSgpIHtcbiAgICB0aGlzLnRhcmdldC5kaWRNb2RpZnkoKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgTGFiZWxPcGNvZGUgaW1wbGVtZW50cyBVcGRhdGluZ09wY29kZSB7XG4gIHB1YmxpYyB0YWc6IFRhZyA9IENPTlNUQU5UX1RBRztcbiAgcHVibGljIHR5cGUgPSAnbGFiZWwnO1xuICBwdWJsaWMgbGFiZWw6IE9wdGlvbjxzdHJpbmc+ID0gbnVsbDtcbiAgcHVibGljIF9ndWlkITogbnVtYmVyOyAvLyBTZXQgYnkgaW5pdGlhbGl6ZUd1aWQoKSBpbiB0aGUgY29uc3RydWN0b3JcblxuICBwcmV2OiBhbnkgPSBudWxsO1xuICBuZXh0OiBhbnkgPSBudWxsO1xuXG4gIGNvbnN0cnVjdG9yKGxhYmVsOiBzdHJpbmcpIHtcbiAgICBpbml0aWFsaXplR3VpZCh0aGlzKTtcbiAgICB0aGlzLmxhYmVsID0gbGFiZWw7XG4gIH1cblxuICBldmFsdWF0ZSgpIHt9XG5cbiAgaW5zcGVjdCgpOiBzdHJpbmcge1xuICAgIHJldHVybiBgJHt0aGlzLmxhYmVsfSBbJHt0aGlzLl9ndWlkfV1gO1xuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9