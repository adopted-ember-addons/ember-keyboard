import { dict } from '@glimmer/util';
import { APPEND_OPCODES } from '../../opcodes';
import { CONSTANTS } from '../../symbols';
function debugCallback(context, get) {
    console.info('Use `context`, and `get(<path>)` to debug this template.');
    // for example...
    // eslint-disable-next-line no-unused-expressions
    context === get('this');
    // eslint-disable-next-line no-debugger
    debugger;
}
let callback = debugCallback;
// For testing purposes
export function setDebuggerCallback(cb) {
    callback = cb;
}
export function resetDebuggerCallback() {
    callback = debugCallback;
}
class ScopeInspector {
    constructor(scope, symbols, evalInfo) {
        this.scope = scope;
        this.locals = dict();
        for (let i = 0; i < evalInfo.length; i++) {
            let slot = evalInfo[i];
            let name = symbols[slot - 1];
            let ref = scope.getSymbol(slot);
            this.locals[name] = ref;
        }
    }
    get(path) {
        let { scope, locals } = this;
        let parts = path.split('.');
        let [head, ...tail] = path.split('.');
        let evalScope = scope.getEvalScope();
        let ref;
        if (head === 'this') {
            ref = scope.getSelf();
        } else if (locals[head]) {
            ref = locals[head];
        } else if (head.indexOf('@') === 0 && evalScope[head]) {
            ref = evalScope[head];
        } else {
            ref = this.scope.getSelf();
            tail = parts;
        }
        return tail.reduce((r, part) => r.get(part), ref);
    }
}
APPEND_OPCODES.add(105 /* Debugger */, (vm, { op1: _symbols, op2: _evalInfo }) => {
    let symbols = vm[CONSTANTS].getStringArray(_symbols);
    let evalInfo = vm[CONSTANTS].getArray(_evalInfo);
    let inspector = new ScopeInspector(vm.scope(), symbols, evalInfo);
    callback(vm.getSelf().value(), path => inspector.get(path).value());
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3J1bnRpbWUvbGliL2NvbXBpbGVkL29wY29kZXMvZGVidWdnZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBRUEsU0FBUyxJQUFULFFBQXFCLGVBQXJCO0FBQ0EsU0FBUyxjQUFULFFBQStCLGVBQS9CO0FBQ0EsU0FBUyxTQUFULFFBQTBCLGVBQTFCO0FBTUEsU0FBUyxhQUFULENBQXVCLE9BQXZCLEVBQXlDLEdBQXpDLEVBQXNEO0FBQ3BELFlBQVEsSUFBUixDQUFhLDBEQUFiO0FBRUE7QUFDQTtBQUNBLGdCQUFZLElBQUksTUFBSixDQUFaO0FBRUE7QUFDQTtBQUNEO0FBRUQsSUFBSSxXQUFXLGFBQWY7QUFFQTtBQUNBLE9BQU0sU0FBVSxtQkFBVixDQUE4QixFQUE5QixFQUErQztBQUNuRCxlQUFXLEVBQVg7QUFDRDtBQUVELE9BQU0sU0FBVSxxQkFBVixHQUErQjtBQUNuQyxlQUFXLGFBQVg7QUFDRDtBQUVELE1BQU0sY0FBTixDQUFvQjtBQUdsQixnQkFBb0IsS0FBcEIsRUFBcUMsT0FBckMsRUFBd0QsUUFBeEQsRUFBMEU7QUFBdEQsYUFBQSxLQUFBLEdBQUEsS0FBQTtBQUZaLGFBQUEsTUFBQSxHQUFTLE1BQVQ7QUFHTixhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksU0FBUyxNQUE3QixFQUFxQyxHQUFyQyxFQUEwQztBQUN4QyxnQkFBSSxPQUFPLFNBQVMsQ0FBVCxDQUFYO0FBQ0EsZ0JBQUksT0FBTyxRQUFRLE9BQU8sQ0FBZixDQUFYO0FBQ0EsZ0JBQUksTUFBTSxNQUFNLFNBQU4sQ0FBZ0IsSUFBaEIsQ0FBVjtBQUNBLGlCQUFLLE1BQUwsQ0FBWSxJQUFaLElBQW9CLEdBQXBCO0FBQ0Q7QUFDRjtBQUVELFFBQUksSUFBSixFQUFnQjtBQUNkLFlBQUksRUFBRSxLQUFGLEVBQVMsTUFBVCxLQUFvQixJQUF4QjtBQUNBLFlBQUksUUFBUSxLQUFLLEtBQUwsQ0FBVyxHQUFYLENBQVo7QUFDQSxZQUFJLENBQUMsSUFBRCxFQUFPLEdBQUcsSUFBVixJQUFrQixLQUFLLEtBQUwsQ0FBVyxHQUFYLENBQXRCO0FBRUEsWUFBSSxZQUFZLE1BQU0sWUFBTixFQUFoQjtBQUNBLFlBQUksR0FBSjtBQUVBLFlBQUksU0FBUyxNQUFiLEVBQXFCO0FBQ25CLGtCQUFNLE1BQU0sT0FBTixFQUFOO0FBQ0QsU0FGRCxNQUVPLElBQUksT0FBTyxJQUFQLENBQUosRUFBa0I7QUFDdkIsa0JBQU0sT0FBTyxJQUFQLENBQU47QUFDRCxTQUZNLE1BRUEsSUFBSSxLQUFLLE9BQUwsQ0FBYSxHQUFiLE1BQXNCLENBQXRCLElBQTJCLFVBQVUsSUFBVixDQUEvQixFQUFnRDtBQUNyRCxrQkFBTSxVQUFVLElBQVYsQ0FBTjtBQUNELFNBRk0sTUFFQTtBQUNMLGtCQUFNLEtBQUssS0FBTCxDQUFXLE9BQVgsRUFBTjtBQUNBLG1CQUFPLEtBQVA7QUFDRDtBQUVELGVBQU8sS0FBSyxNQUFMLENBQVksQ0FBQyxDQUFELEVBQUksSUFBSixLQUFhLEVBQUUsR0FBRixDQUFNLElBQU4sQ0FBekIsRUFBc0MsR0FBdEMsQ0FBUDtBQUNEO0FBaENpQjtBQW1DcEIsZUFBZSxHQUFmLENBQWtCLEdBQWxCLENBQWtCLGNBQWxCLEVBQWdDLENBQUMsRUFBRCxFQUFLLEVBQUUsS0FBSyxRQUFQLEVBQWlCLEtBQUssU0FBdEIsRUFBTCxLQUEwQztBQUN4RSxRQUFJLFVBQVUsR0FBRyxTQUFILEVBQWMsY0FBZCxDQUE2QixRQUE3QixDQUFkO0FBQ0EsUUFBSSxXQUFXLEdBQUcsU0FBSCxFQUFjLFFBQWQsQ0FBdUIsU0FBdkIsQ0FBZjtBQUNBLFFBQUksWUFBWSxJQUFJLGNBQUosQ0FBbUIsR0FBRyxLQUFILEVBQW5CLEVBQStCLE9BQS9CLEVBQXdDLFFBQXhDLENBQWhCO0FBQ0EsYUFBUyxHQUFHLE9BQUgsR0FBYSxLQUFiLEVBQVQsRUFBK0IsUUFBUSxVQUFVLEdBQVYsQ0FBYyxJQUFkLEVBQW9CLEtBQXBCLEVBQXZDO0FBQ0QsQ0FMRCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE9wLCBKaXRPckFvdEJsb2NrLCBTY29wZSB9IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgVmVyc2lvbmVkUGF0aFJlZmVyZW5jZSB9IGZyb20gJ0BnbGltbWVyL3JlZmVyZW5jZSc7XG5pbXBvcnQgeyBkaWN0IH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5pbXBvcnQgeyBBUFBFTkRfT1BDT0RFUyB9IGZyb20gJy4uLy4uL29wY29kZXMnO1xuaW1wb3J0IHsgQ09OU1RBTlRTIH0gZnJvbSAnLi4vLi4vc3ltYm9scyc7XG5cbmV4cG9ydCB0eXBlIERlYnVnR2V0ID0gKHBhdGg6IHN0cmluZykgPT4gdW5rbm93bjtcblxuZXhwb3J0IHR5cGUgRGVidWdDYWxsYmFjayA9IChjb250ZXh0OiB1bmtub3duLCBnZXQ6IERlYnVnR2V0KSA9PiB2b2lkO1xuXG5mdW5jdGlvbiBkZWJ1Z0NhbGxiYWNrKGNvbnRleHQ6IHVua25vd24sIGdldDogRGVidWdHZXQpOiB2b2lkIHtcbiAgY29uc29sZS5pbmZvKCdVc2UgYGNvbnRleHRgLCBhbmQgYGdldCg8cGF0aD4pYCB0byBkZWJ1ZyB0aGlzIHRlbXBsYXRlLicpO1xuXG4gIC8vIGZvciBleGFtcGxlLi4uXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcbiAgY29udGV4dCA9PT0gZ2V0KCd0aGlzJyk7XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWRlYnVnZ2VyXG4gIGRlYnVnZ2VyO1xufVxuXG5sZXQgY2FsbGJhY2sgPSBkZWJ1Z0NhbGxiYWNrO1xuXG4vLyBGb3IgdGVzdGluZyBwdXJwb3Nlc1xuZXhwb3J0IGZ1bmN0aW9uIHNldERlYnVnZ2VyQ2FsbGJhY2soY2I6IERlYnVnQ2FsbGJhY2spIHtcbiAgY2FsbGJhY2sgPSBjYjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlc2V0RGVidWdnZXJDYWxsYmFjaygpIHtcbiAgY2FsbGJhY2sgPSBkZWJ1Z0NhbGxiYWNrO1xufVxuXG5jbGFzcyBTY29wZUluc3BlY3RvcjxDIGV4dGVuZHMgSml0T3JBb3RCbG9jaz4ge1xuICBwcml2YXRlIGxvY2FscyA9IGRpY3Q8VmVyc2lvbmVkUGF0aFJlZmVyZW5jZTx1bmtub3duPj4oKTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHNjb3BlOiBTY29wZTxDPiwgc3ltYm9sczogc3RyaW5nW10sIGV2YWxJbmZvOiBudW1iZXJbXSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXZhbEluZm8ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBzbG90ID0gZXZhbEluZm9baV07XG4gICAgICBsZXQgbmFtZSA9IHN5bWJvbHNbc2xvdCAtIDFdO1xuICAgICAgbGV0IHJlZiA9IHNjb3BlLmdldFN5bWJvbChzbG90KTtcbiAgICAgIHRoaXMubG9jYWxzW25hbWVdID0gcmVmO1xuICAgIH1cbiAgfVxuXG4gIGdldChwYXRoOiBzdHJpbmcpOiBWZXJzaW9uZWRQYXRoUmVmZXJlbmNlPHVua25vd24+IHtcbiAgICBsZXQgeyBzY29wZSwgbG9jYWxzIH0gPSB0aGlzO1xuICAgIGxldCBwYXJ0cyA9IHBhdGguc3BsaXQoJy4nKTtcbiAgICBsZXQgW2hlYWQsIC4uLnRhaWxdID0gcGF0aC5zcGxpdCgnLicpO1xuXG4gICAgbGV0IGV2YWxTY29wZSA9IHNjb3BlLmdldEV2YWxTY29wZSgpITtcbiAgICBsZXQgcmVmOiBWZXJzaW9uZWRQYXRoUmVmZXJlbmNlPHVua25vd24+O1xuXG4gICAgaWYgKGhlYWQgPT09ICd0aGlzJykge1xuICAgICAgcmVmID0gc2NvcGUuZ2V0U2VsZigpO1xuICAgIH0gZWxzZSBpZiAobG9jYWxzW2hlYWRdKSB7XG4gICAgICByZWYgPSBsb2NhbHNbaGVhZF07XG4gICAgfSBlbHNlIGlmIChoZWFkLmluZGV4T2YoJ0AnKSA9PT0gMCAmJiBldmFsU2NvcGVbaGVhZF0pIHtcbiAgICAgIHJlZiA9IGV2YWxTY29wZVtoZWFkXSBhcyBWZXJzaW9uZWRQYXRoUmVmZXJlbmNlPHVua25vd24+O1xuICAgIH0gZWxzZSB7XG4gICAgICByZWYgPSB0aGlzLnNjb3BlLmdldFNlbGYoKTtcbiAgICAgIHRhaWwgPSBwYXJ0cztcbiAgICB9XG5cbiAgICByZXR1cm4gdGFpbC5yZWR1Y2UoKHIsIHBhcnQpID0+IHIuZ2V0KHBhcnQpLCByZWYpO1xuICB9XG59XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5EZWJ1Z2dlciwgKHZtLCB7IG9wMTogX3N5bWJvbHMsIG9wMjogX2V2YWxJbmZvIH0pID0+IHtcbiAgbGV0IHN5bWJvbHMgPSB2bVtDT05TVEFOVFNdLmdldFN0cmluZ0FycmF5KF9zeW1ib2xzKTtcbiAgbGV0IGV2YWxJbmZvID0gdm1bQ09OU1RBTlRTXS5nZXRBcnJheShfZXZhbEluZm8pO1xuICBsZXQgaW5zcGVjdG9yID0gbmV3IFNjb3BlSW5zcGVjdG9yKHZtLnNjb3BlKCksIHN5bWJvbHMsIGV2YWxJbmZvKTtcbiAgY2FsbGJhY2sodm0uZ2V0U2VsZigpLnZhbHVlKCksIHBhdGggPT4gaW5zcGVjdG9yLmdldChwYXRoKS52YWx1ZSgpKTtcbn0pO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==