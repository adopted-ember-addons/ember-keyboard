import { DEBUG } from '@glimmer/env';
import { CONSTANT_TAG, validateTag, valueForTag, isConstTag, combine as _combine } from './validators';
import { markTagAsConsumed, beginTrackingTransaction, endTrackingTransaction, resetTrackingTransaction } from './debug';
import { symbol, unwrap } from './utils';
/**
 * An object that that tracks @tracked properties that were consumed.
 */

var Tracker = /*#__PURE__*/function () {
  function Tracker() {
    this.tags = new Set();
    this.last = null;
  }

  var _proto = Tracker.prototype;

  _proto.add = function add(tag) {
    if (tag === CONSTANT_TAG) return;
    this.tags.add(tag);

    if (DEBUG) {
      unwrap(markTagAsConsumed)(tag);
    }

    this.last = tag;
  };

  _proto.combine = function combine() {
    var tags = this.tags;

    if (tags.size === 0) {
      return CONSTANT_TAG;
    } else if (tags.size === 1) {
      return this.last;
    } else {
      var tagsArr = [];
      tags.forEach(function (tag) {
        return tagsArr.push(tag);
      });
      return _combine(tagsArr);
    }
  };

  return Tracker;
}();
/**
 * Whenever a tracked computed property is entered, the current tracker is
 * saved off and a new tracker is replaced.
 *
 * Any tracked properties consumed are added to the current tracker.
 *
 * When a tracked computed property is exited, the tracker's tags are
 * combined and added to the parent tracker.
 *
 * The consequence is that each tracked computed property has a tag
 * that corresponds to the tracked properties consumed inside of
 * itself, including child tracked computed properties.
 */


var CURRENT_TRACKER = null;
var OPEN_TRACK_FRAMES = [];
export function beginTrackFrame(debuggingContext) {
  OPEN_TRACK_FRAMES.push(CURRENT_TRACKER);
  CURRENT_TRACKER = new Tracker();

  if (DEBUG) {
    unwrap(beginTrackingTransaction)(debuggingContext);
  }
}
export function endTrackFrame() {
  var current = CURRENT_TRACKER;

  if (DEBUG) {
    if (OPEN_TRACK_FRAMES.length === 0) {
      throw new Error('attempted to close a tracking frame, but one was not open');
    }

    unwrap(endTrackingTransaction)();
  }

  CURRENT_TRACKER = OPEN_TRACK_FRAMES.pop() || null;
  return unwrap(current).combine();
}
export function beginUntrackFrame() {
  OPEN_TRACK_FRAMES.push(CURRENT_TRACKER);
  CURRENT_TRACKER = null;
}
export function endUntrackFrame() {
  if (DEBUG && OPEN_TRACK_FRAMES.length === 0) {
    throw new Error('attempted to close a tracking frame, but one was not open');
  }

  CURRENT_TRACKER = OPEN_TRACK_FRAMES.pop() || null;
} // This function is only for handling errors and resetting to a valid state

export function resetTracking() {
  while (OPEN_TRACK_FRAMES.length > 0) {
    OPEN_TRACK_FRAMES.pop();
  }

  CURRENT_TRACKER = null;

  if (DEBUG) {
    return unwrap(resetTrackingTransaction)();
  }
}
export function isTracking() {
  return CURRENT_TRACKER !== null;
}
export function consumeTag(tag) {
  if (CURRENT_TRACKER !== null) {
    CURRENT_TRACKER.add(tag);
  }
} //////////

var CACHE_KEY = symbol('CACHE_KEY');
var FN = symbol('FN');
var LAST_VALUE = symbol('LAST_VALUE');
var TAG = symbol('TAG');
var SNAPSHOT = symbol('SNAPSHOT');
var DEBUG_LABEL = symbol('DEBUG_LABEL');
export function createCache(fn, debuggingLabel) {
  var _cache;

  if (DEBUG && !(typeof fn === 'function')) {
    throw new Error("createCache() must be passed a function as its first parameter. Called with: " + String(fn));
  }

  var cache = (_cache = {}, _cache[FN] = fn, _cache[LAST_VALUE] = undefined, _cache[TAG] = undefined, _cache[SNAPSHOT] = -1, _cache);

  if (DEBUG) {
    cache[DEBUG_LABEL] = debuggingLabel;
  }

  return cache;
}
export function getValue(cache) {
  assertCache(cache, 'getValue');
  var fn = cache[FN];
  var tag = cache[TAG];
  var snapshot = cache[SNAPSHOT];

  if (tag === undefined || !validateTag(tag, snapshot)) {
    beginTrackFrame();

    try {
      cache[LAST_VALUE] = fn();
    } finally {
      tag = endTrackFrame();
      cache[TAG] = tag;
      cache[SNAPSHOT] = valueForTag(tag);
      consumeTag(tag);
    }
  } else {
    consumeTag(tag);
  }

  return cache[LAST_VALUE];
}
export function isConst(cache) {
  assertCache(cache, 'isConst');
  var tag = cache[TAG];
  assertTag(tag, cache);
  return isConstTag(tag);
}

function assertCache(value, fnName) {
  if (DEBUG && !(typeof value === 'object' && value !== null && FN in value)) {
    throw new Error(fnName + "() can only be used on an instance of a cache created with createCache(). Called with: " + String(value));
  }
} // replace this with `expect` when we can


function assertTag(tag, cache) {
  if (DEBUG && tag === undefined) {
    throw new Error("isConst() can only be used on a cache once getValue() has been called at least once. Called with cache function:\n\n" + String(cache[FN]));
  }
} //////////
// Legacy tracking APIs
// track() shouldn't be necessary at all in the VM once the autotracking
// refactors are merged, and we should generally be moving away from it. It may
// be necessary in Ember for a while longer, but I think we'll be able to drop
// it in favor of cache sooner rather than later.


export function track(callback, debugLabel) {
  beginTrackFrame(debugLabel);
  var tag;

  try {
    callback();
  } finally {
    tag = endTrackFrame();
  }

  return tag;
} // untrack() is currently mainly used to handle places that were previously not
// tracked, and that tracking now would cause backtracking rerender assertions.
// I think once we move everyone forward onto modern APIs, we'll probably be
// able to remove it, but I'm not sure yet.

export function untrack(callback) {
  beginUntrackFrame();

  try {
    return callback();
  } finally {
    endUntrackFrame();
  }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3ZhbGlkYXRvci9saWIvdHJhY2tpbmcudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsU0FBQSxLQUFBLFFBQUEsY0FBQTtBQUNBLFNBQUEsWUFBQSxFQUFBLFdBQUEsRUFBQSxXQUFBLEVBQUEsVUFBQSxFQU9FLE9BUEYsSUFPRSxRQVBGLFFBQUEsY0FBQTtBQVVBLFNBQUEsaUJBQUEsRUFBQSx3QkFBQSxFQUFBLHNCQUFBLEVBQUEsd0JBQUEsUUFBQSxTQUFBO0FBTUEsU0FBQSxNQUFBLEVBQUEsTUFBQSxRQUFBLFNBQUE7QUFJQTs7OztJQUdBLE87QUFBQSxxQkFBQTtBQUNVLFNBQUEsSUFBQSxHQUFPLElBQVAsR0FBTyxFQUFQO0FBQ0EsU0FBQSxJQUFBLEdBQUEsSUFBQTtBQTJCVDs7OztTQXpCQyxHLEdBQUEsYUFBRyxHQUFILEVBQVk7QUFDVixRQUFJLEdBQUcsS0FBUCxZQUFBLEVBQTBCO0FBRTFCLFNBQUEsSUFBQSxDQUFBLEdBQUEsQ0FBQSxHQUFBOztBQUVBLFFBQUEsS0FBQSxFQUFXO0FBQ1QsTUFBQSxNQUFNLENBQU4saUJBQU0sQ0FBTixDQUFBLEdBQUE7QUFDRDs7QUFFRCxTQUFBLElBQUEsR0FBQSxHQUFBO0FBQ0QsRzs7U0FFRCxPLEdBQUEsbUJBQU87QUFBQSxRQUNDLElBREQsR0FDTCxJQURLLENBQ0MsSUFERDs7QUFHTCxRQUFJLElBQUksQ0FBSixJQUFBLEtBQUosQ0FBQSxFQUFxQjtBQUNuQixhQUFBLFlBQUE7QUFERixLQUFBLE1BRU8sSUFBSSxJQUFJLENBQUosSUFBQSxLQUFKLENBQUEsRUFBcUI7QUFDMUIsYUFBTyxLQUFQLElBQUE7QUFESyxLQUFBLE1BRUE7QUFDTCxVQUFJLE9BQU8sR0FBWCxFQUFBO0FBQ0EsTUFBQSxJQUFJLENBQUosT0FBQSxDQUFjLFVBQUEsR0FBRDtBQUFBLGVBQVMsT0FBTyxDQUFQLElBQUEsQ0FBdEIsR0FBc0IsQ0FBVDtBQUFB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QUVELFNBQUEsV0FBQSxDQUFBLEtBQUEsRUFBQSxNQUFBLEVBRWdCO0FBRWQsTUFBSSxLQUFLLElBQUksRUFBRSxPQUFBLEtBQUEsS0FBQSxRQUFBLElBQTZCLEtBQUssS0FBbEMsSUFBQSxJQUErQyxFQUFFLElBQWhFLEtBQWEsQ0FBYixFQUE0RTtBQUMxRSxVQUFNLElBQUEsS0FBQSxDQUNELE1BREMsK0ZBQytGLE1BQU0sQ0FEM0csS0FDMkcsQ0FEckcsQ0FBTjtBQUtEO0VBR0g7OztBQUNBLFNBQUEsU0FBQSxDQUFBLEdBQUEsRUFBQSxLQUFBLEVBQTZEO0FBQzNELE1BQUksS0FBSyxJQUFJLEdBQUcsS0FBaEIsU0FBQSxFQUFnQztBQUM5QixVQUFNLElBQUEsS0FBQSwwSEFDbUgsTUFBTSxDQUMzSCxLQUFLLENBRlQsRUFFUyxDQURzSCxDQUR6SCxDQUFOO0FBS0Q7RUFHSDtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLE9BQU0sU0FBQSxLQUFBLENBQUEsUUFBQSxFQUFBLFVBQUEsRUFBaUU7QUFDckUsRUFBQSxlQUFlLENBQWYsVUFBZSxDQUFmO0FBRUEsTUFBQSxHQUFBOztBQUVBLE1BQUk7QUFDRixJQUFBLFFBQVE7QUFEVixHQUFBLFNBRVU7QUFDUixJQUFBLEdBQUcsR0FBRyxhQUFOLEVBQUE7QUFDRDs7QUFFRCxTQUFBLEdBQUE7RUFHRjtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxPQUFNLFNBQUEsT0FBQSxDQUFBLFFBQUEsRUFBc0M7QUFDMUMsRUFBQSxpQkFBaUI7O0FBRWpCLE1BQUk7QUFDRixXQUFPLFFBQVAsRUFBQTtBQURGLEdBQUEsU0FFVTtBQUNSLElBQUEsZUFBZTtBQUNoQjtBQUNGIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgREVCVUcgfSBmcm9tICdAZ2xpbW1lci9lbnYnO1xuaW1wb3J0IHtcbiAgVGFnLFxuICBDT05TVEFOVF9UQUcsXG4gIHZhbGlkYXRlVGFnLFxuICBSZXZpc2lvbixcbiAgdmFsdWVGb3JUYWcsXG4gIGlzQ29uc3RUYWcsXG4gIGNvbWJpbmUsXG59IGZyb20gJy4vdmFsaWRhdG9ycyc7XG5cbmltcG9ydCB7XG4gIG1hcmtUYWdBc0NvbnN1bWVkLFxuICBiZWdpblRyYWNraW5nVHJhbnNhY3Rpb24sXG4gIGVuZFRyYWNraW5nVHJhbnNhY3Rpb24sXG4gIHJlc2V0VHJhY2tpbmdUcmFuc2FjdGlvbixcbn0gZnJvbSAnLi9kZWJ1Zyc7XG5pbXBvcnQgeyBzeW1ib2wsIHVud3JhcCB9IGZyb20gJy4vdXRpbHMnO1xuXG50eXBlIE9wdGlvbjxUPiA9IFQgfCBudWxsO1xuXG4vKipcbiAqIEFuIG9iamVjdCB0aGF0IHRoYXQgdHJhY2tzIEB0cmFja2VkIHByb3BlcnRpZXMgdGhhdCB3ZXJlIGNvbnN1bWVkLlxuICovXG5jbGFzcyBUcmFja2VyIHtcbiAgcHJpdmF0ZSB0YWdzID0gbmV3IFNldDxUYWc+KCk7XG4gIHByaXZhdGUgbGFzdDogT3B0aW9uPFRhZz4gPSBudWxsO1xuXG4gIGFkZCh0YWc6IFRhZykge1xuICAgIGlmICh0YWcgPT09IENPTlNUQU5UX1RBRykgcmV0dXJuO1xuXG4gICAgdGhpcy50YWdzLmFkZCh0YWcpO1xuXG4gICAgaWYgKERFQlVHKSB7XG4gICAgICB1bndyYXAobWFya1RhZ0FzQ29uc3VtZWQpKHRhZyk7XG4gICAgfVxuXG4gICAgdGhpcy5sYXN0ID0gdGFnO1xuICB9XG5cbiAgY29tYmluZSgpOiBUYWcge1xuICAgIGxldCB7IHRhZ3MgfSA9IHRoaXM7XG5cbiAgICBpZiAodGFncy5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gQ09OU1RBTlRfVEFHO1xuICAgIH0gZWxzZSBpZiAodGFncy5zaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gdGhpcy5sYXN0IGFzIFRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHRhZ3NBcnI6IFRhZ1tdID0gW107XG4gICAgICB0YWdzLmZvckVhY2goKHRhZykgPT4gdGFnc0Fyci5wdXNoKHRhZykpO1xuICAgICAgcmV0dXJuIGNvbWJpbmUodGFnc0Fycik7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogV2hlbmV2ZXIgYSB0cmFja2VkIGNvbXB1dGVkIHByb3BlcnR5IGlzIGVudGVyZWQsIHRoZSBjdXJyZW50IHRyYWNrZXIgaXNcbiAqIHNhdmVkIG9mZiBhbmQgYSBuZXcgdHJhY2tlciBpcyByZXBsYWNlZC5cbiAqXG4gKiBBbnkgdHJhY2tlZCBwcm9wZXJ0aWVzIGNvbnN1bWVkIGFyZSBhZGRlZCB0byB0aGUgY3VycmVudCB0cmFja2VyLlxuICpcbiAqIFdoZW4gYSB0cmFja2VkIGNvbXB1dGVkIHByb3BlcnR5IGlzIGV4aXRlZCwgdGhlIHRyYWNrZXIncyB0YWdzIGFyZVxuICogY29tYmluZWQgYW5kIGFkZGVkIHRvIHRoZSBwYXJlbnQgdHJhY2tlci5cbiAqXG4gKiBUaGUgY29uc2VxdWVuY2UgaXMgdGhhdCBlYWNoIHRyYWNrZWQgY29tcHV0ZWQgcHJvcGVydHkgaGFzIGEgdGFnXG4gKiB0aGF0IGNvcnJlc3BvbmRzIHRvIHRoZSB0cmFja2VkIHByb3BlcnRpZXMgY29uc3VtZWQgaW5zaWRlIG9mXG4gKiBpdHNlbGYsIGluY2x1ZGluZyBjaGlsZCB0cmFja2VkIGNvbXB1dGVkIHByb3BlcnRpZXMuXG4gKi9cbmxldCBDVVJSRU5UX1RSQUNLRVI6IE9wdGlvbjxUcmFja2VyPiA9IG51bGw7XG5cbmNvbnN0IE9QRU5fVFJBQ0tfRlJBTUVTOiBPcHRpb248VHJhY2tlcj5bXSA9IFtdO1xuXG5leHBvcnQgZnVuY3Rpb24gYmVnaW5UcmFja0ZyYW1lKGRlYnVnZ2luZ0NvbnRleHQ/OiBzdHJpbmcgfCBmYWxzZSk6IHZvaWQge1xuICBPUEVOX1RSQUNLX0ZSQU1FUy5wdXNoKENVUlJFTlRfVFJBQ0tFUik7XG5cbiAgQ1VSUkVOVF9UUkFDS0VSID0gbmV3IFRyYWNrZXIoKTtcblxuICBpZiAoREVCVUcpIHtcbiAgICB1bndyYXAoYmVnaW5UcmFja2luZ1RyYW5zYWN0aW9uKShkZWJ1Z2dpbmdDb250ZXh0KTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZW5kVHJhY2tGcmFtZSgpOiBUYWcge1xuICBsZXQgY3VycmVudCA9IENVUlJFTlRfVFJBQ0tFUjtcblxuICBpZiAoREVCVUcpIHtcbiAgICBpZiAoT1BFTl9UUkFDS19GUkFNRVMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2F0dGVtcHRlZCB0byBjbG9zZSBhIHRyYWNraW5nIGZyYW1lLCBidXQgb25lIHdhcyBub3Qgb3BlbicpO1xuICAgIH1cblxuICAgIHVud3JhcChlbmRUcmFja2luZ1RyYW5zYWN0aW9uKSgpO1xuICB9XG5cbiAgQ1VSUkVOVF9UUkFDS0VSID0gT1BFTl9UUkFDS19GUkFNRVMucG9wKCkgfHwgbnVsbDtcblxuICByZXR1cm4gdW53cmFwKGN1cnJlbnQpLmNvbWJpbmUoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJlZ2luVW50cmFja0ZyYW1lKCk6IHZvaWQge1xuICBPUEVOX1RSQUNLX0ZSQU1FUy5wdXNoKENVUlJFTlRfVFJBQ0tFUik7XG4gIENVUlJFTlRfVFJBQ0tFUiA9IG51bGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlbmRVbnRyYWNrRnJhbWUoKTogdm9pZCB7XG4gIGlmIChERUJVRyAmJiBPUEVOX1RSQUNLX0ZSQU1FUy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2F0dGVtcHRlZCB0byBjbG9zZSBhIHRyYWNraW5nIGZyYW1lLCBidXQgb25lIHdhcyBub3Qgb3BlbicpO1xuICB9XG5cbiAgQ1VSUkVOVF9UUkFDS0VSID0gT1BFTl9UUkFDS19GUkFNRVMucG9wKCkgfHwgbnVsbDtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBpcyBvbmx5IGZvciBoYW5kbGluZyBlcnJvcnMgYW5kIHJlc2V0dGluZyB0byBhIHZhbGlkIHN0YXRlXG5leHBvcnQgZnVuY3Rpb24gcmVzZXRUcmFja2luZygpOiBzdHJpbmcgfCB2b2lkIHtcbiAgd2hpbGUgKE9QRU5fVFJBQ0tfRlJBTUVTLmxlbmd0aCA+IDApIHtcbiAgICBPUEVOX1RSQUNLX0ZSQU1FUy5wb3AoKTtcbiAgfVxuXG4gIENVUlJFTlRfVFJBQ0tFUiA9IG51bGw7XG5cbiAgaWYgKERFQlVHKSB7XG4gICAgcmV0dXJuIHVud3JhcChyZXNldFRyYWNraW5nVHJhbnNhY3Rpb24pKCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzVHJhY2tpbmcoKTogYm9vbGVhbiB7XG4gIHJldHVybiBDVVJSRU5UX1RSQUNLRVIgIT09IG51bGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb25zdW1lVGFnKHRhZzogVGFnKTogdm9pZCB7XG4gIGlmIChDVVJSRU5UX1RSQUNLRVIgIT09IG51bGwpIHtcbiAgICBDVVJSRU5UX1RSQUNLRVIuYWRkKHRhZyk7XG4gIH1cbn1cblxuLy8vLy8vLy8vL1xuXG5jb25zdCBDQUNIRV9LRVk6IHVuaXF1ZSBzeW1ib2wgPSBzeW1ib2woJ0NBQ0hFX0tFWScpO1xuXG4vLyBwdWJsaWMgaW50ZXJmYWNlXG5leHBvcnQgaW50ZXJmYWNlIENhY2hlPFQgPSB1bmtub3duPiB7XG4gIFtDQUNIRV9LRVldOiBUO1xufVxuXG5jb25zdCBGTjogdW5pcXVlIHN5bWJvbCA9IHN5bWJvbCgnRk4nKTtcbmNvbnN0IExBU1RfVkFMVUU6IHVuaXF1ZSBzeW1ib2wgPSBzeW1ib2woJ0xBU1RfVkFMVUUnKTtcbmNvbnN0IFRBRzogdW5pcXVlIHN5bWJvbCA9IHN5bWJvbCgnVEFHJyk7XG5jb25zdCBTTkFQU0hPVDogdW5pcXVlIHN5bWJvbCA9IHN5bWJvbCgnU05BUFNIT1QnKTtcbmNvbnN0IERFQlVHX0xBQkVMOiB1bmlxdWUgc3ltYm9sID0gc3ltYm9sKCdERUJVR19MQUJFTCcpO1xuXG5pbnRlcmZhY2UgSW50ZXJuYWxDYWNoZTxUID0gdW5rbm93bj4ge1xuICBbRk5dOiAoLi4uYXJnczogdW5rbm93bltdKSA9PiBUO1xuICBbTEFTVF9WQUxVRV06IFQgfCB1bmRlZmluZWQ7XG4gIFtUQUddOiBUYWcgfCB1bmRlZmluZWQ7XG4gIFtTTkFQU0hPVF06IFJldmlzaW9uO1xuICBbREVCVUdfTEFCRUxdPzogc3RyaW5nIHwgZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDYWNoZTxUPihmbjogKCkgPT4gVCwgZGVidWdnaW5nTGFiZWw/OiBzdHJpbmcgfCBmYWxzZSk6IENhY2hlPFQ+IHtcbiAgaWYgKERFQlVHICYmICEodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBjcmVhdGVDYWNoZSgpIG11c3QgYmUgcGFzc2VkIGEgZnVuY3Rpb24gYXMgaXRzIGZpcnN0IHBhcmFtZXRlci4gQ2FsbGVkIHdpdGg6ICR7U3RyaW5nKGZuKX1gXG4gICAgKTtcbiAgfVxuXG4gIGxldCBjYWNoZTogSW50ZXJuYWxDYWNoZTxUPiA9IHtcbiAgICBbRk5dOiBmbixcbiAgICBbTEFTVF9WQUxVRV06IHVuZGVmaW5lZCxcbiAgICBbVEFHXTogdW5kZWZpbmVkLFxuICAgIFtTTkFQU0hPVF06IC0xLFxuICB9O1xuXG4gIGlmIChERUJVRykge1xuICAgIGNhY2hlW0RFQlVHX0xBQkVMXSA9IGRlYnVnZ2luZ0xhYmVsO1xuICB9XG5cbiAgcmV0dXJuIChjYWNoZSBhcyB1bmtub3duKSBhcyBDYWNoZTxUPjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFZhbHVlPFQ+KGNhY2hlOiBDYWNoZTxUPik6IFQgfCB1bmRlZmluZWQge1xuICBhc3NlcnRDYWNoZShjYWNoZSwgJ2dldFZhbHVlJyk7XG5cbiAgbGV0IGZuID0gY2FjaGVbRk5dO1xuICBsZXQgdGFnID0gY2FjaGVbVEFHXTtcbiAgbGV0IHNuYXBzaG90ID0gY2FjaGVbU05BUFNIT1RdO1xuXG4gIGlmICh0YWcgPT09IHVuZGVmaW5lZCB8fCAhdmFsaWRhdGVUYWcodGFnLCBzbmFwc2hvdCkpIHtcbiAgICBiZWdpblRyYWNrRnJhbWUoKTtcblxuICAgIHRyeSB7XG4gICAgICBjYWNoZVtMQVNUX1ZBTFVFXSA9IGZuKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRhZyA9IGVuZFRyYWNrRnJhbWUoKTtcbiAgICAgIGNhY2hlW1RBR10gPSB0YWc7XG4gICAgICBjYWNoZVtTTkFQU0hPVF0gPSB2YWx1ZUZvclRhZyh0YWcpO1xuICAgICAgY29uc3VtZVRhZyh0YWcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdW1lVGFnKHRhZyk7XG4gIH1cblxuICByZXR1cm4gY2FjaGVbTEFTVF9WQUxVRV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0NvbnN0KGNhY2hlOiBDYWNoZSk6IGJvb2xlYW4ge1xuICBhc3NlcnRDYWNoZShjYWNoZSwgJ2lzQ29uc3QnKTtcblxuICBsZXQgdGFnID0gY2FjaGVbVEFHXTtcblxuICBhc3NlcnRUYWcodGFnLCBjYWNoZSk7XG5cbiAgcmV0dXJuIGlzQ29uc3RUYWcodGFnKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0Q2FjaGU8VD4oXG4gIHZhbHVlOiBDYWNoZTxUPiB8IEludGVybmFsQ2FjaGU8VD4sXG4gIGZuTmFtZTogc3RyaW5nXG4pOiBhc3NlcnRzIHZhbHVlIGlzIEludGVybmFsQ2FjaGU8VD4ge1xuICBpZiAoREVCVUcgJiYgISh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsICYmIEZOIGluIHZhbHVlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGAke2ZuTmFtZX0oKSBjYW4gb25seSBiZSB1c2VkIG9uIGFuIGluc3RhbmNlIG9mIGEgY2FjaGUgY3JlYXRlZCB3aXRoIGNyZWF0ZUNhY2hlKCkuIENhbGxlZCB3aXRoOiAke1N0cmluZyhcbiAgICAgICAgdmFsdWVcbiAgICAgICl9YFxuICAgICk7XG4gIH1cbn1cblxuLy8gcmVwbGFjZSB0aGlzIHdpdGggYGV4cGVjdGAgd2hlbiB3ZSBjYW5cbmZ1bmN0aW9uIGFzc2VydFRhZyh0YWc6IFRhZyB8IHVuZGVmaW5lZCwgY2FjaGU6IEludGVybmFsQ2FjaGUpOiBhc3NlcnRzIHRhZyBpcyBUYWcge1xuICBpZiAoREVCVUcgJiYgdGFnID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgaXNDb25zdCgpIGNhbiBvbmx5IGJlIHVzZWQgb24gYSBjYWNoZSBvbmNlIGdldFZhbHVlKCkgaGFzIGJlZW4gY2FsbGVkIGF0IGxlYXN0IG9uY2UuIENhbGxlZCB3aXRoIGNhY2hlIGZ1bmN0aW9uOlxcblxcbiR7U3RyaW5nKFxuICAgICAgICBjYWNoZVtGTl1cbiAgICAgICl9YFxuICAgICk7XG4gIH1cbn1cblxuLy8vLy8vLy8vL1xuXG4vLyBMZWdhY3kgdHJhY2tpbmcgQVBJc1xuXG4vLyB0cmFjaygpIHNob3VsZG4ndCBiZSBuZWNlc3NhcnkgYXQgYWxsIGluIHRoZSBWTSBvbmNlIHRoZSBhdXRvdHJhY2tpbmdcbi8vIHJlZmFjdG9ycyBhcmUgbWVyZ2VkLCBhbmQgd2Ugc2hvdWxkIGdlbmVyYWxseSBiZSBtb3ZpbmcgYXdheSBmcm9tIGl0LiBJdCBtYXlcbi8vIGJlIG5lY2Vzc2FyeSBpbiBFbWJlciBmb3IgYSB3aGlsZSBsb25nZXIsIGJ1dCBJIHRoaW5rIHdlJ2xsIGJlIGFibGUgdG8gZHJvcFxuLy8gaXQgaW4gZmF2b3Igb2YgY2FjaGUgc29vbmVyIHJhdGhlciB0aGFuIGxhdGVyLlxuZXhwb3J0IGZ1bmN0aW9uIHRyYWNrKGNhbGxiYWNrOiAoKSA9PiB2b2lkLCBkZWJ1Z0xhYmVsPzogc3RyaW5nIHwgZmFsc2UpOiBUYWcge1xuICBiZWdpblRyYWNrRnJhbWUoZGVidWdMYWJlbCk7XG5cbiAgbGV0IHRhZztcblxuICB0cnkge1xuICAgIGNhbGxiYWNrKCk7XG4gIH0gZmluYWxseSB7XG4gICAgdGFnID0gZW5kVHJhY2tGcmFtZSgpO1xuICB9XG5cbiAgcmV0dXJuIHRhZztcbn1cblxuLy8gdW50cmFjaygpIGlzIGN1cnJlbnRseSBtYWlubHkgdXNlZCB0byBoYW5kbGUgcGxhY2VzIHRoYXQgd2VyZSBwcmV2aW91c2x5IG5vdFxuLy8gdHJhY2tlZCwgYW5kIHRoYXQgdHJhY2tpbmcgbm93IHdvdWxkIGNhdXNlIGJhY2t0cmFja2luZyByZXJlbmRlciBhc3NlcnRpb25zLlxuLy8gSSB0aGluayBvbmNlIHdlIG1vdmUgZXZlcnlvbmUgZm9yd2FyZCBvbnRvIG1vZGVybiBBUElzLCB3ZSdsbCBwcm9iYWJseSBiZVxuLy8gYWJsZSB0byByZW1vdmUgaXQsIGJ1dCBJJ20gbm90IHN1cmUgeWV0LlxuZXhwb3J0IGZ1bmN0aW9uIHVudHJhY2s8VD4oY2FsbGJhY2s6ICgpID0+IFQpOiBUIHtcbiAgYmVnaW5VbnRyYWNrRnJhbWUoKTtcblxuICB0cnkge1xuICAgIHJldHVybiBjYWxsYmFjaygpO1xuICB9IGZpbmFsbHkge1xuICAgIGVuZFVudHJhY2tGcmFtZSgpO1xuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9