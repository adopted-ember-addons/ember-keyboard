import { DEBUG } from '@glimmer/env';
import { scheduleRevalidate } from '@glimmer/global-context';
import { symbol, unwrap } from './utils';
import { assertTagNotConsumed } from './debug';
export var CONSTANT = 0;
export var INITIAL = 1;
export var VOLATILE = NaN;
var $REVISION = INITIAL;
export function bump() {
  $REVISION++;
} //////////

export var COMPUTE = symbol('TAG_COMPUTE'); //////////

/**
 * `value` receives a tag and returns an opaque Revision based on that tag. This
 * snapshot can then later be passed to `validate` with the same tag to
 * determine if the tag has changed at all since the time that `value` was
 * called.
 *
 * @param tag
 */

export function valueForTag(tag) {
  return tag[COMPUTE]();
}
/**
 * `validate` receives a tag and a snapshot from a previous call to `value` with
 * the same tag, and determines if the tag is still valid compared to the
 * snapshot. If the tag's state has changed at all since then, `validate` will
 * return false, otherwise it will return true. This is used to determine if a
 * calculation related to the tags should be rerun.
 *
 * @param tag
 * @param snapshot
 */

export function validateTag(tag, snapshot) {
  return snapshot >= tag[COMPUTE]();
}
var TYPE = symbol('TAG_TYPE'); // this is basically a const
// eslint-disable-next-line @typescript-eslint/naming-convention

export var ALLOW_CYCLES;

if (DEBUG) {
  ALLOW_CYCLES = new WeakMap();
}

function allowsCycles(tag) {
  if (ALLOW_CYCLES === undefined) {
    return true;
  } else {
    return ALLOW_CYCLES.has(tag);
  }
}

var MonomorphicTagImpl = /*#__PURE__*/function () {
  function MonomorphicTagImpl(type) {
    this.revision = INITIAL;
    this.lastChecked = INITIAL;
    this.lastValue = INITIAL;
    this.isUpdating = false;
    this.subtag = null;
    this.subtagBufferCache = null;
    this[TYPE] = type;
  }

  MonomorphicTagImpl.combine = function combine(tags) {
    switch (tags.length) {
      case 0:
        return CONSTANT_TAG;

      case 1:
        return tags[0];

      default:
        var tag = new MonomorphicTagImpl(2
        /* Combinator */
        );
        tag.subtag = tags;
        return tag;
    }
  };

  var _proto = MonomorphicTagImpl.prototype;

  _proto[COMPUTE] = function () {
    var lastChecked = this.lastChecked;

    if (this.isUpdating === true) {
      if (DEBUG && !allowsCycles(this)) {
        throw new Error('Cycles in tags are not allowed');
      }

      this.lastChecked = ++$REVISION;
    } else if (lastChecked !== $REVISION) {
      this.isUpdating = true;
      this.lastChecked = $REVISION;

      try {
        var subtag = this.subtag,
            revision = this.revision;

        if (subtag !== null) {
          if (Array.isArray(subtag)) {
            for (var i = 0; i < subtag.length; i++) {
              var value = subtag[i][COMPUTE]();
              revision = Math.max(value, revision);
            }
          } else {
            var subtagValue = subtag[COMPUTE]();

            if (subtagValue === this.subtagBufferCache) {
              revision = Math.max(revision, this.lastValue);
            } else {
              // Clear the temporary buffer cache
              this.subtagBufferCache = null;
              revision = Math.max(revision, subtagValue);
            }
          }
        }

        this.lastValue = revision;
      } finally {
        this.isUpdating = false;
      }
    }

    return this.lastValue;
  };

  MonomorphicTagImpl.updateTag = function updateTag(_tag, _subtag) {
    if (DEBUG && _tag[TYPE] !== 1
    /* Updatable */
    ) {
        throw new Error('Attempted to update a tag that was not updatable');
      } // TODO: TS 3.7 should allow us to do this via assertion


    var tag = _tag;
    var subtag = _subtag;

    if (subtag === CONSTANT_TAG) {
      tag.subtag = null;
    } else {
      // There are two different possibilities when updating a subtag:
      //
      // 1. subtag[COMPUTE]() <= tag[COMPUTE]();
      // 2. subtag[COMPUTE]() > tag[COMPUTE]();
      //
      // The first possibility is completely fine within our caching model, but
      // the second possibility presents a problem. If the parent tag has
      // already been read, then it's value is cached and will not update to
      // reflect the subtag's greater value. Next time the cache is busted, the
      // subtag's value _will_ be read, and it's value will be _greater_ than
      // the saved snapshot of the parent, causing the resulting calculation to
      // be rerun erroneously.
      //
      // In order to prevent this, when we first update to a new subtag we store
      // its computed value, and then check against that computed value on
      // subsequent updates. If its value hasn't changed, then we return the
      // parent's previous value. Once the subtag changes for the first time,
      // we clear the cache and everything is finally in sync with the parent.
      tag.subtagBufferCache = subtag[COMPUTE]();
      tag.subtag = subtag;
    }
  };

  MonomorphicTagImpl.dirtyTag = function dirtyTag(tag, disableConsumptionAssertion) {
    if (DEBUG && !(tag[TYPE] === 1
    /* Updatable */
    || tag[TYPE] === 0
    /* Dirtyable */
    )) {
      throw new Error('Attempted to dirty a tag that was not dirtyable');
    }

    if (DEBUG && disableConsumptionAssertion !== true) {
      // Usually by this point, we've already asserted with better error information,
      // but this is our last line of defense.
      unwrap(assertTagNotConsumed)(tag);
    }

    tag.revision = ++$REVISION;
    scheduleRevalidate();
  };

  return MonomorphicTagImpl;
}();

export var DIRTY_TAG = MonomorphicTagImpl.dirtyTag;
export var UPDATE_TAG = MonomorphicTagImpl.updateTag; //////////

export function createTag() {
  return new MonomorphicTagImpl(0
  /* Dirtyable */
  );
}
export function createUpdatableTag() {
  return new MonomorphicTagImpl(1
  /* Updatable */
  );
} //////////

export var CONSTANT_TAG = new MonomorphicTagImpl(3
/* Constant */
);
export function isConstTag(tag) {
  return tag === CONSTANT_TAG;
} //////////

export var VolatileTag = /*#__PURE__*/function () {
  function VolatileTag() {}

  var _proto2 = VolatileTag.prototype;

  _proto2[COMPUTE] = function () {
    return VOLATILE;
  };

  return VolatileTag;
}();
export var VOLATILE_TAG = new VolatileTag(); //////////

export var CurrentTag = /*#__PURE__*/function () {
  function CurrentTag() {}

  var _proto3 = CurrentTag.prototype;

  _proto3[COMPUTE] = function () {
    return $REVISION;
  };

  return CurrentTag;
}();
export var CURRENT_TAG = new CurrentTag(); //////////

export var combine = MonomorphicTagImpl.combine; // Warm

var tag1 = createUpdatableTag();
var tag2 = createUpdatableTag();
var tag3 = createUpdatableTag();
valueForTag(tag1);
DIRTY_TAG(tag1);
valueForTag(tag1);
UPDATE_TAG(tag1, combine([tag2, tag3]));
valueForTag(tag1);
DIRTY_TAG(tag2);
valueForTag(tag1);
DIRTY_TAG(tag3);
valueForTag(tag1);
UPDATE_TAG(tag1, tag3);
valueForTag(tag1);
DIRTY_TAG(tag3);
valueForTag(tag1);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3ZhbGlkYXRvci9saWIvdmFsaWRhdG9ycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxTQUFBLEtBQUEsUUFBQSxjQUFBO0FBQ0EsU0FBQSxrQkFBQSxRQUFBLHlCQUFBO0FBQ0EsU0FBQSxNQUFBLEVBQUEsTUFBQSxRQUFBLFNBQUE7QUFDQSxTQUFBLG9CQUFBLFFBQUEsU0FBQTtBQU1BLE9BQU8sSUFBTSxRQUFRLEdBQWQsQ0FBQTtBQUNQLE9BQU8sSUFBTSxPQUFPLEdBQWIsQ0FBQTtBQUNQLE9BQU8sSUFBTSxRQUFRLEdBQWQsR0FBQTtBQUVQLElBQUksU0FBUyxHQUFiLE9BQUE7QUFFQSxPQUFNLFNBQUEsSUFBQSxHQUFjO0FBQ2xCLEVBQUEsU0FBUztFQUdYOztBQUVBLE9BQU8sSUFBTSxPQUFPLEdBQWtCLE1BQU0sQ0FBckMsYUFBcUMsQ0FBckMsQyxDQVFQOztBQUVBOzs7Ozs7Ozs7QUFRQSxPQUFNLFNBQUEsV0FBQSxDQUFBLEdBQUEsRUFBOEI7QUFDbEMsU0FBTyxHQUFHLENBQVYsT0FBVSxDQUFILEVBQVA7QUFDRDtBQUVEOzs7Ozs7Ozs7OztBQVVBLE9BQU0sU0FBQSxXQUFBLENBQUEsR0FBQSxFQUFBLFFBQUEsRUFBa0Q7QUFDdEQsU0FBTyxRQUFRLElBQUksR0FBRyxDQUF0QixPQUFzQixDQUFILEVBQW5CO0FBQ0Q7QUFpQkQsSUFBTSxJQUFJLEdBQWtCLE1BQU0sQ0FBbEMsVUFBa0MsQ0FBbEMsQyxDQUVBO0FBQ0E7O0FBQ0EsT0FBTyxJQUFBLFlBQUE7O0FBRVAsSUFBQSxLQUFBLEVBQVc7QUFDVCxFQUFBLFlBQVksR0FBRyxJQUFmLE9BQWUsRUFBZjtBQUNEOztBQUVELFNBQUEsWUFBQSxDQUFBLEdBQUEsRUFBOEI7QUFDNUIsTUFBSSxZQUFZLEtBQWhCLFNBQUEsRUFBZ0M7QUFDOUIsV0FBQSxJQUFBO0FBREYsR0FBQSxNQUVPO0FBQ0wsV0FBTyxZQUFZLENBQVos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Q0EsV0FBVyxDQUFYLElBQVcsQ0FBWCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERFQlVHIH0gZnJvbSAnQGdsaW1tZXIvZW52JztcbmltcG9ydCB7IHNjaGVkdWxlUmV2YWxpZGF0ZSB9IGZyb20gJ0BnbGltbWVyL2dsb2JhbC1jb250ZXh0JztcbmltcG9ydCB7IHN5bWJvbCwgdW53cmFwIH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgeyBhc3NlcnRUYWdOb3RDb25zdW1lZCB9IGZyb20gJy4vZGVidWcnO1xuXG4vLy8vLy8vLy8vXG5cbmV4cG9ydCB0eXBlIFJldmlzaW9uID0gbnVtYmVyO1xuXG5leHBvcnQgY29uc3QgQ09OU1RBTlQ6IFJldmlzaW9uID0gMDtcbmV4cG9ydCBjb25zdCBJTklUSUFMOiBSZXZpc2lvbiA9IDE7XG5leHBvcnQgY29uc3QgVk9MQVRJTEU6IFJldmlzaW9uID0gTmFOO1xuXG5sZXQgJFJFVklTSU9OID0gSU5JVElBTDtcblxuZXhwb3J0IGZ1bmN0aW9uIGJ1bXAoKTogdm9pZCB7XG4gICRSRVZJU0lPTisrO1xufVxuXG4vLy8vLy8vLy8vXG5cbmV4cG9ydCBjb25zdCBDT01QVVRFOiB1bmlxdWUgc3ltYm9sID0gc3ltYm9sKCdUQUdfQ09NUFVURScpO1xuXG5leHBvcnQgaW50ZXJmYWNlIEVudGl0eVRhZzxUPiB7XG4gIFtDT01QVVRFXSgpOiBUO1xufVxuXG5leHBvcnQgdHlwZSBUYWcgPSBFbnRpdHlUYWc8UmV2aXNpb24+O1xuXG4vLy8vLy8vLy8vXG5cbi8qKlxuICogYHZhbHVlYCByZWNlaXZlcyBhIHRhZyBhbmQgcmV0dXJucyBhbiBvcGFxdWUgUmV2aXNpb24gYmFzZWQgb24gdGhhdCB0YWcuIFRoaXNcbiAqIHNuYXBzaG90IGNhbiB0aGVuIGxhdGVyIGJlIHBhc3NlZCB0byBgdmFsaWRhdGVgIHdpdGggdGhlIHNhbWUgdGFnIHRvXG4gKiBkZXRlcm1pbmUgaWYgdGhlIHRhZyBoYXMgY2hhbmdlZCBhdCBhbGwgc2luY2UgdGhlIHRpbWUgdGhhdCBgdmFsdWVgIHdhc1xuICogY2FsbGVkLlxuICpcbiAqIEBwYXJhbSB0YWdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbHVlRm9yVGFnKHRhZzogVGFnKTogUmV2aXNpb24ge1xuICByZXR1cm4gdGFnW0NPTVBVVEVdKCk7XG59XG5cbi8qKlxuICogYHZhbGlkYXRlYCByZWNlaXZlcyBhIHRhZyBhbmQgYSBzbmFwc2hvdCBmcm9tIGEgcHJldmlvdXMgY2FsbCB0byBgdmFsdWVgIHdpdGhcbiAqIHRoZSBzYW1lIHRhZywgYW5kIGRldGVybWluZXMgaWYgdGhlIHRhZyBpcyBzdGlsbCB2YWxpZCBjb21wYXJlZCB0byB0aGVcbiAqIHNuYXBzaG90LiBJZiB0aGUgdGFnJ3Mgc3RhdGUgaGFzIGNoYW5nZWQgYXQgYWxsIHNpbmNlIHRoZW4sIGB2YWxpZGF0ZWAgd2lsbFxuICogcmV0dXJuIGZhbHNlLCBvdGhlcndpc2UgaXQgd2lsbCByZXR1cm4gdHJ1ZS4gVGhpcyBpcyB1c2VkIHRvIGRldGVybWluZSBpZiBhXG4gKiBjYWxjdWxhdGlvbiByZWxhdGVkIHRvIHRoZSB0YWdzIHNob3VsZCBiZSByZXJ1bi5cbiAqXG4gKiBAcGFyYW0gdGFnXG4gKiBAcGFyYW0gc25hcHNob3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlVGFnKHRhZzogVGFnLCBzbmFwc2hvdDogUmV2aXNpb24pOiBib29sZWFuIHtcbiAgcmV0dXJuIHNuYXBzaG90ID49IHRhZ1tDT01QVVRFXSgpO1xufVxuXG4vLy8vLy8vLy8vXG5cbi8qKlxuICogVGhpcyBlbnVtIHJlcHJlc2VudHMgYWxsIG9mIHRoZSBwb3NzaWJsZSB0YWcgdHlwZXMgZm9yIHRoZSBtb25vbW9ycGhpYyB0YWcgY2xhc3MuXG4gKiBPdGhlciBjdXN0b20gdGFnIGNsYXNzZXMgY2FuIGV4aXN0LCBzdWNoIGFzIEN1cnJlbnRUYWcgYW5kIFZvbGF0aWxlVGFnLCBidXQgZm9yXG4gKiBwZXJmb3JtYW5jZSByZWFzb25zLCBhbnkgdHlwZSBvZiB0YWcgdGhhdCBpcyBtZWFudCB0byBiZSB1c2VkIGZyZXF1ZW50bHkgc2hvdWxkXG4gKiBiZSBhZGRlZCB0byB0aGUgbW9ub21vcnBoaWMgdGFnLlxuICovXG5jb25zdCBlbnVtIE1vbm9tb3JwaGljVGFnVHlwZXMge1xuICBEaXJ0eWFibGUsXG4gIFVwZGF0YWJsZSxcbiAgQ29tYmluYXRvcixcbiAgQ29uc3RhbnQsXG59XG5cbmNvbnN0IFRZUEU6IHVuaXF1ZSBzeW1ib2wgPSBzeW1ib2woJ1RBR19UWVBFJyk7XG5cbi8vIHRoaXMgaXMgYmFzaWNhbGx5IGEgY29uc3Rcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbmV4cG9ydCBsZXQgQUxMT1dfQ1lDTEVTOiBXZWFrTWFwPFRhZywgYm9vbGVhbj4gfCB1bmRlZmluZWQ7XG5cbmlmIChERUJVRykge1xuICBBTExPV19DWUNMRVMgPSBuZXcgV2Vha01hcCgpO1xufVxuXG5mdW5jdGlvbiBhbGxvd3NDeWNsZXModGFnOiBUYWcpOiBib29sZWFuIHtcbiAgaWYgKEFMTE9XX0NZQ0xFUyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIEFMTE9XX0NZQ0xFUy5oYXModGFnKTtcbiAgfVxufVxuXG5pbnRlcmZhY2UgTW9ub21vcnBoaWNUYWdCYXNlPFQgZXh0ZW5kcyBNb25vbW9ycGhpY1RhZ1R5cGVzPiBleHRlbmRzIFRhZyB7XG4gIFtUWVBFXTogVDtcbn1cblxuZXhwb3J0IHR5cGUgRGlydHlhYmxlVGFnID0gTW9ub21vcnBoaWNUYWdCYXNlPE1vbm9tb3JwaGljVGFnVHlwZXMuRGlydHlhYmxlPjtcbmV4cG9ydCB0eXBlIFVwZGF0YWJsZVRhZyA9IE1vbm9tb3JwaGljVGFnQmFzZTxNb25vbW9ycGhpY1RhZ1R5cGVzLlVwZGF0YWJsZT47XG5leHBvcnQgdHlwZSBDb21iaW5hdG9yVGFnID0gTW9ub21vcnBoaWNUYWdCYXNlPE1vbm9tb3JwaGljVGFnVHlwZXMuQ29tYmluYXRvcj47XG5leHBvcnQgdHlwZSBDb25zdGFudFRhZyA9IE1vbm9tb3JwaGljVGFnQmFzZTxNb25vbW9ycGhpY1RhZ1R5cGVzLkNvbnN0YW50PjtcblxuY2xhc3MgTW9ub21vcnBoaWNUYWdJbXBsPFQgZXh0ZW5kcyBNb25vbW9ycGhpY1RhZ1R5cGVzID0gTW9ub21vcnBoaWNUYWdUeXBlcz4ge1xuICBzdGF0aWMgY29tYmluZSh0YWdzOiBUYWdbXSk6IFRhZyB7XG4gICAgc3dpdGNoICh0YWdzLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gQ09OU1RBTlRfVEFHO1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gdGFnc1swXTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGxldCB0YWc6IE1vbm9tb3JwaGljVGFnSW1wbCA9IG5ldyBNb25vbW9ycGhpY1RhZ0ltcGwoTW9ub21vcnBoaWNUYWdUeXBlcy5Db21iaW5hdG9yKTtcbiAgICAgICAgdGFnLnN1YnRhZyA9IHRhZ3M7XG4gICAgICAgIHJldHVybiB0YWc7XG4gICAgfVxuICB9XG4gIHByaXZhdGUgcmV2aXNpb24gPSBJTklUSUFMO1xuICBwcml2YXRlIGxhc3RDaGVja2VkID0gSU5JVElBTDtcbiAgcHJpdmF0ZSBsYXN0VmFsdWUgPSBJTklUSUFMO1xuXG4gIHByaXZhdGUgaXNVcGRhdGluZyA9IGZhbHNlO1xuICBwcml2YXRlIHN1YnRhZzogVGFnIHwgVGFnW10gfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBzdWJ0YWdCdWZmZXJDYWNoZTogUmV2aXNpb24gfCBudWxsID0gbnVsbDtcblxuICBbVFlQRV06IFQ7XG5cbiAgY29uc3RydWN0b3IodHlwZTogVCkge1xuICAgIHRoaXNbVFlQRV0gPSB0eXBlO1xuICB9XG5cbiAgW0NPTVBVVEVdKCk6IFJldmlzaW9uIHtcbiAgICBsZXQgeyBsYXN0Q2hlY2tlZCB9ID0gdGhpcztcblxuICAgIGlmICh0aGlzLmlzVXBkYXRpbmcgPT09IHRydWUpIHtcbiAgICAgIGlmIChERUJVRyAmJiAhYWxsb3dzQ3ljbGVzKHRoaXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ3ljbGVzIGluIHRhZ3MgYXJlIG5vdCBhbGxvd2VkJyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGFzdENoZWNrZWQgPSArKyRSRVZJU0lPTjtcbiAgICB9IGVsc2UgaWYgKGxhc3RDaGVja2VkICE9PSAkUkVWSVNJT04pIHtcbiAgICAgIHRoaXMuaXNVcGRhdGluZyA9IHRydWU7XG4gICAgICB0aGlzLmxhc3RDaGVja2VkID0gJFJFVklTSU9OO1xuXG4gICAgICB0cnkge1xuICAgICAgICBsZXQgeyBzdWJ0YWcsIHJldmlzaW9uIH0gPSB0aGlzO1xuXG4gICAgICAgIGlmIChzdWJ0YWcgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzdWJ0YWcpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN1YnRhZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBzdWJ0YWdbaV1bQ09NUFVURV0oKTtcbiAgICAgICAgICAgICAgcmV2aXNpb24gPSBNYXRoLm1heCh2YWx1ZSwgcmV2aXNpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgc3VidGFnVmFsdWUgPSBzdWJ0YWdbQ09NUFVURV0oKTtcblxuICAgICAgICAgICAgaWYgKHN1YnRhZ1ZhbHVlID09PSB0aGlzLnN1YnRhZ0J1ZmZlckNhY2hlKSB7XG4gICAgICAgICAgICAgIHJldmlzaW9uID0gTWF0aC5tYXgocmV2aXNpb24sIHRoaXMubGFzdFZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIENsZWFyIHRoZSB0ZW1wb3JhcnkgYnVmZmVyIGNhY2hlXG4gICAgICAgICAgICAgIHRoaXMuc3VidGFnQnVmZmVyQ2FjaGUgPSBudWxsO1xuICAgICAgICAgICAgICByZXZpc2lvbiA9IE1hdGgubWF4KHJldmlzaW9uLCBzdWJ0YWdWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5sYXN0VmFsdWUgPSByZXZpc2lvbjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRoaXMuaXNVcGRhdGluZyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmxhc3RWYWx1ZTtcbiAgfVxuXG4gIHN0YXRpYyB1cGRhdGVUYWcoX3RhZzogVXBkYXRhYmxlVGFnLCBfc3VidGFnOiBUYWcpIHtcbiAgICBpZiAoREVCVUcgJiYgX3RhZ1tUWVBFXSAhPT0gTW9ub21vcnBoaWNUYWdUeXBlcy5VcGRhdGFibGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGVkIHRvIHVwZGF0ZSBhIHRhZyB0aGF0IHdhcyBub3QgdXBkYXRhYmxlJyk7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogVFMgMy43IHNob3VsZCBhbGxvdyB1cyB0byBkbyB0aGlzIHZpYSBhc3NlcnRpb25cbiAgICBsZXQgdGFnID0gX3RhZyBhcyBNb25vbW9ycGhpY1RhZ0ltcGw7XG4gICAgbGV0IHN1YnRhZyA9IF9zdWJ0YWcgYXMgTW9ub21vcnBoaWNUYWdJbXBsO1xuXG4gICAgaWYgKHN1YnRhZyA9PT0gQ09OU1RBTlRfVEFHKSB7XG4gICAgICB0YWcuc3VidGFnID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlcmUgYXJlIHR3byBkaWZmZXJlbnQgcG9zc2liaWxpdGllcyB3aGVuIHVwZGF0aW5nIGEgc3VidGFnOlxuICAgICAgLy9cbiAgICAgIC8vIDEuIHN1YnRhZ1tDT01QVVRFXSgpIDw9IHRhZ1tDT01QVVRFXSgpO1xuICAgICAgLy8gMi4gc3VidGFnW0NPTVBVVEVdKCkgPiB0YWdbQ09NUFVURV0oKTtcbiAgICAgIC8vXG4gICAgICAvLyBUaGUgZmlyc3QgcG9zc2liaWxpdHkgaXMgY29tcGxldGVseSBmaW5lIHdpdGhpbiBvdXIgY2FjaGluZyBtb2RlbCwgYnV0XG4gICAgICAvLyB0aGUgc2Vjb25kIHBvc3NpYmlsaXR5IHByZXNlbnRzIGEgcHJvYmxlbS4gSWYgdGhlIHBhcmVudCB0YWcgaGFzXG4gICAgICAvLyBhbHJlYWR5IGJlZW4gcmVhZCwgdGhlbiBpdCdzIHZhbHVlIGlzIGNhY2hlZCBhbmQgd2lsbCBub3QgdXBkYXRlIHRvXG4gICAgICAvLyByZWZsZWN0IHRoZSBzdWJ0YWcncyBncmVhdGVyIHZhbHVlLiBOZXh0IHRpbWUgdGhlIGNhY2hlIGlzIGJ1c3RlZCwgdGhlXG4gICAgICAvLyBzdWJ0YWcncyB2YWx1ZSBfd2lsbF8gYmUgcmVhZCwgYW5kIGl0J3MgdmFsdWUgd2lsbCBiZSBfZ3JlYXRlcl8gdGhhblxuICAgICAgLy8gdGhlIHNhdmVkIHNuYXBzaG90IG9mIHRoZSBwYXJlbnQsIGNhdXNpbmcgdGhlIHJlc3VsdGluZyBjYWxjdWxhdGlvbiB0b1xuICAgICAgLy8gYmUgcmVydW4gZXJyb25lb3VzbHkuXG4gICAgICAvL1xuICAgICAgLy8gSW4gb3JkZXIgdG8gcHJldmVudCB0aGlzLCB3aGVuIHdlIGZpcnN0IHVwZGF0ZSB0byBhIG5ldyBzdWJ0YWcgd2Ugc3RvcmVcbiAgICAgIC8vIGl0cyBjb21wdXRlZCB2YWx1ZSwgYW5kIHRoZW4gY2hlY2sgYWdhaW5zdCB0aGF0IGNvbXB1dGVkIHZhbHVlIG9uXG4gICAgICAvLyBzdWJzZXF1ZW50IHVwZGF0ZXMuIElmIGl0cyB2YWx1ZSBoYXNuJ3QgY2hhbmdlZCwgdGhlbiB3ZSByZXR1cm4gdGhlXG4gICAgICAvLyBwYXJlbnQncyBwcmV2aW91cyB2YWx1ZS4gT25jZSB0aGUgc3VidGFnIGNoYW5nZXMgZm9yIHRoZSBmaXJzdCB0aW1lLFxuICAgICAgLy8gd2UgY2xlYXIgdGhlIGNhY2hlIGFuZCBldmVyeXRoaW5nIGlzIGZpbmFsbHkgaW4gc3luYyB3aXRoIHRoZSBwYXJlbnQuXG4gICAgICB0YWcuc3VidGFnQnVmZmVyQ2FjaGUgPSBzdWJ0YWdbQ09NUFVURV0oKTtcbiAgICAgIHRhZy5zdWJ0YWcgPSBzdWJ0YWc7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGRpcnR5VGFnKHRhZzogRGlydHlhYmxlVGFnIHwgVXBkYXRhYmxlVGFnLCBkaXNhYmxlQ29uc3VtcHRpb25Bc3NlcnRpb24/OiBib29sZWFuKSB7XG4gICAgaWYgKFxuICAgICAgREVCVUcgJiZcbiAgICAgICEodGFnW1RZUEVdID09PSBNb25vbW9ycGhpY1RhZ1R5cGVzLlVwZGF0YWJsZSB8fCB0YWdbVFlQRV0gPT09IE1vbm9tb3JwaGljVGFnVHlwZXMuRGlydHlhYmxlKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdHRlbXB0ZWQgdG8gZGlydHkgYSB0YWcgdGhhdCB3YXMgbm90IGRpcnR5YWJsZScpO1xuICAgIH1cblxuICAgIGlmIChERUJVRyAmJiBkaXNhYmxlQ29uc3VtcHRpb25Bc3NlcnRpb24gIT09IHRydWUpIHtcbiAgICAgIC8vIFVzdWFsbHkgYnkgdGhpcyBwb2ludCwgd2UndmUgYWxyZWFkeSBhc3NlcnRlZCB3aXRoIGJldHRlciBlcnJvciBpbmZvcm1hdGlvbixcbiAgICAgIC8vIGJ1dCB0aGlzIGlzIG91ciBsYXN0IGxpbmUgb2YgZGVmZW5zZS5cbiAgICAgIHVud3JhcChhc3NlcnRUYWdOb3RDb25zdW1lZCkodGFnKTtcbiAgICB9XG5cbiAgICAodGFnIGFzIE1vbm9tb3JwaGljVGFnSW1wbCkucmV2aXNpb24gPSArKyRSRVZJU0lPTjtcblxuICAgIHNjaGVkdWxlUmV2YWxpZGF0ZSgpO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBESVJUWV9UQUcgPSBNb25vbW9ycGhpY1RhZ0ltcGwuZGlydHlUYWc7XG5leHBvcnQgY29uc3QgVVBEQVRFX1RBRyA9IE1vbm9tb3JwaGljVGFnSW1wbC51cGRhdGVUYWc7XG5cbi8vLy8vLy8vLy9cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVRhZygpOiBEaXJ0eWFibGVUYWcge1xuICByZXR1cm4gbmV3IE1vbm9tb3JwaGljVGFnSW1wbChNb25vbW9ycGhpY1RhZ1R5cGVzLkRpcnR5YWJsZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVVcGRhdGFibGVUYWcoKTogVXBkYXRhYmxlVGFnIHtcbiAgcmV0dXJuIG5ldyBNb25vbW9ycGhpY1RhZ0ltcGwoTW9ub21vcnBoaWNUYWdUeXBlcy5VcGRhdGFibGUpO1xufVxuXG4vLy8vLy8vLy8vXG5cbmV4cG9ydCBjb25zdCBDT05TVEFOVF9UQUc6IENvbnN0YW50VGFnID0gbmV3IE1vbm9tb3JwaGljVGFnSW1wbChNb25vbW9ycGhpY1RhZ1R5cGVzLkNvbnN0YW50KTtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzQ29uc3RUYWcodGFnOiBUYWcpOiB0YWcgaXMgQ29uc3RhbnRUYWcge1xuICByZXR1cm4gdGFnID09PSBDT05TVEFOVF9UQUc7XG59XG5cbi8vLy8vLy8vLy9cblxuZXhwb3J0IGNsYXNzIFZvbGF0aWxlVGFnIGltcGxlbWVudHMgVGFnIHtcbiAgW0NPTVBVVEVdKCk6IFJldmlzaW9uIHtcbiAgICByZXR1cm4gVk9MQVRJTEU7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IFZPTEFUSUxFX1RBRyA9IG5ldyBWb2xhdGlsZVRhZygpO1xuXG4vLy8vLy8vLy8vXG5cbmV4cG9ydCBjbGFzcyBDdXJyZW50VGFnIGltcGxlbWVudHMgQ3VycmVudFRhZyB7XG4gIFtDT01QVVRFXSgpOiBSZXZpc2lvbiB7XG4gICAgcmV0dXJuICRSRVZJU0lPTjtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgQ1VSUkVOVF9UQUcgPSBuZXcgQ3VycmVudFRhZygpO1xuXG4vLy8vLy8vLy8vXG5cbmV4cG9ydCBjb25zdCBjb21iaW5lID0gTW9ub21vcnBoaWNUYWdJbXBsLmNvbWJpbmU7XG5cbi8vIFdhcm1cblxubGV0IHRhZzEgPSBjcmVhdGVVcGRhdGFibGVUYWcoKTtcbmxldCB0YWcyID0gY3JlYXRlVXBkYXRhYmxlVGFnKCk7XG5sZXQgdGFnMyA9IGNyZWF0ZVVwZGF0YWJsZVRhZygpO1xuXG52YWx1ZUZvclRhZyh0YWcxKTtcbkRJUlRZX1RBRyh0YWcxKTtcbnZhbHVlRm9yVGFnKHRhZzEpO1xuVVBEQVRFX1RBRyh0YWcxLCBjb21iaW5lKFt0YWcyLCB0YWczXSkpO1xudmFsdWVGb3JUYWcodGFnMSk7XG5ESVJUWV9UQUcodGFnMik7XG52YWx1ZUZvclRhZyh0YWcxKTtcbkRJUlRZX1RBRyh0YWczKTtcbnZhbHVlRm9yVGFnKHRhZzEpO1xuVVBEQVRFX1RBRyh0YWcxLCB0YWczKTtcbnZhbHVlRm9yVGFnKHRhZzEpO1xuRElSVFlfVEFHKHRhZzMpO1xudmFsdWVGb3JUYWcodGFnMSk7XG4iXSwic291cmNlUm9vdCI6IiJ9