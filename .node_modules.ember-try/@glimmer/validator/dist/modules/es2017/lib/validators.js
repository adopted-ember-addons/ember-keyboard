import { DEBUG } from '@glimmer/env';
import { scheduleRevalidate } from '@glimmer/global-context';
import { symbol, unwrap } from './utils';
import { assertTagNotConsumed } from './debug';
export const CONSTANT = 0;
export const INITIAL = 1;
export const VOLATILE = NaN;
let $REVISION = INITIAL;
export function bump() {
  $REVISION++;
} //////////

export const COMPUTE = symbol('TAG_COMPUTE'); //////////

/**
 * `value` receives a tag and returns an opaque Revision based on that tag. This
 * snapshot can then later be passed to `validate` with the same tag to
 * determine if the tag has changed at all since the time that `value` was
 * called.
 *
 * @param tag
 */

export function valueForTag(tag) {
  return tag[COMPUTE]();
}
/**
 * `validate` receives a tag and a snapshot from a previous call to `value` with
 * the same tag, and determines if the tag is still valid compared to the
 * snapshot. If the tag's state has changed at all since then, `validate` will
 * return false, otherwise it will return true. This is used to determine if a
 * calculation related to the tags should be rerun.
 *
 * @param tag
 * @param snapshot
 */

export function validateTag(tag, snapshot) {
  return snapshot >= tag[COMPUTE]();
}
const TYPE = symbol('TAG_TYPE'); // this is basically a const
// eslint-disable-next-line @typescript-eslint/naming-convention

export let ALLOW_CYCLES;

if (DEBUG) {
  ALLOW_CYCLES = new WeakMap();
}

function allowsCycles(tag) {
  if (ALLOW_CYCLES === undefined) {
    return true;
  } else {
    return ALLOW_CYCLES.has(tag);
  }
}

class MonomorphicTagImpl {
  constructor(type) {
    this.revision = INITIAL;
    this.lastChecked = INITIAL;
    this.lastValue = INITIAL;
    this.isUpdating = false;
    this.subtag = null;
    this.subtagBufferCache = null;
    this[TYPE] = type;
  }

  static combine(tags) {
    switch (tags.length) {
      case 0:
        return CONSTANT_TAG;

      case 1:
        return tags[0];

      default:
        let tag = new MonomorphicTagImpl(2
        /* Combinator */
        );
        tag.subtag = tags;
        return tag;
    }
  }

  [COMPUTE]() {
    let {
      lastChecked
    } = this;

    if (this.isUpdating === true) {
      if (DEBUG && !allowsCycles(this)) {
        throw new Error('Cycles in tags are not allowed');
      }

      this.lastChecked = ++$REVISION;
    } else if (lastChecked !== $REVISION) {
      this.isUpdating = true;
      this.lastChecked = $REVISION;

      try {
        let {
          subtag,
          revision
        } = this;

        if (subtag !== null) {
          if (Array.isArray(subtag)) {
            for (let i = 0; i < subtag.length; i++) {
              let value = subtag[i][COMPUTE]();
              revision = Math.max(value, revision);
            }
          } else {
            let subtagValue = subtag[COMPUTE]();

            if (subtagValue === this.subtagBufferCache) {
              revision = Math.max(revision, this.lastValue);
            } else {
              // Clear the temporary buffer cache
              this.subtagBufferCache = null;
              revision = Math.max(revision, subtagValue);
            }
          }
        }

        this.lastValue = revision;
      } finally {
        this.isUpdating = false;
      }
    }

    return this.lastValue;
  }

  static updateTag(_tag, _subtag) {
    if (DEBUG && _tag[TYPE] !== 1
    /* Updatable */
    ) {
        throw new Error('Attempted to update a tag that was not updatable');
      } // TODO: TS 3.7 should allow us to do this via assertion


    let tag = _tag;
    let subtag = _subtag;

    if (subtag === CONSTANT_TAG) {
      tag.subtag = null;
    } else {
      // There are two different possibilities when updating a subtag:
      //
      // 1. subtag[COMPUTE]() <= tag[COMPUTE]();
      // 2. subtag[COMPUTE]() > tag[COMPUTE]();
      //
      // The first possibility is completely fine within our caching model, but
      // the second possibility presents a problem. If the parent tag has
      // already been read, then it's value is cached and will not update to
      // reflect the subtag's greater value. Next time the cache is busted, the
      // subtag's value _will_ be read, and it's value will be _greater_ than
      // the saved snapshot of the parent, causing the resulting calculation to
      // be rerun erroneously.
      //
      // In order to prevent this, when we first update to a new subtag we store
      // its computed value, and then check against that computed value on
      // subsequent updates. If its value hasn't changed, then we return the
      // parent's previous value. Once the subtag changes for the first time,
      // we clear the cache and everything is finally in sync with the parent.
      tag.subtagBufferCache = subtag[COMPUTE]();
      tag.subtag = subtag;
    }
  }

  static dirtyTag(tag, disableConsumptionAssertion) {
    if (DEBUG && !(tag[TYPE] === 1
    /* Updatable */
    || tag[TYPE] === 0
    /* Dirtyable */
    )) {
      throw new Error('Attempted to dirty a tag that was not dirtyable');
    }

    if (DEBUG && disableConsumptionAssertion !== true) {
      // Usually by this point, we've already asserted with better error information,
      // but this is our last line of defense.
      unwrap(assertTagNotConsumed)(tag);
    }

    tag.revision = ++$REVISION;
    scheduleRevalidate();
  }

}

export const DIRTY_TAG = MonomorphicTagImpl.dirtyTag;
export const UPDATE_TAG = MonomorphicTagImpl.updateTag; //////////

export function createTag() {
  return new MonomorphicTagImpl(0
  /* Dirtyable */
  );
}
export function createUpdatableTag() {
  return new MonomorphicTagImpl(1
  /* Updatable */
  );
} //////////

export const CONSTANT_TAG = new MonomorphicTagImpl(3
/* Constant */
);
export function isConstTag(tag) {
  return tag === CONSTANT_TAG;
} //////////

export class VolatileTag {
  [COMPUTE]() {
    return VOLATILE;
  }

}
export const VOLATILE_TAG = new VolatileTag(); //////////

export class CurrentTag {
  [COMPUTE]() {
    return $REVISION;
  }

}
export const CURRENT_TAG = new CurrentTag(); //////////

export const combine = MonomorphicTagImpl.combine; // Warm

let tag1 = createUpdatableTag();
let tag2 = createUpdatableTag();
let tag3 = createUpdatableTag();
valueForTag(tag1);
DIRTY_TAG(tag1);
valueForTag(tag1);
UPDATE_TAG(tag1, combine([tag2, tag3]));
valueForTag(tag1);
DIRTY_TAG(tag2);
valueForTag(tag1);
DIRTY_TAG(tag3);
valueForTag(tag1);
UPDATE_TAG(tag1, tag3);
valueForTag(tag1);
DIRTY_TAG(tag3);
valueForTag(tag1);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3ZhbGlkYXRvci9saWIvdmFsaWRhdG9ycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxTQUFTLEtBQVQsUUFBc0IsY0FBdEI7QUFDQSxTQUFTLGtCQUFULFFBQW1DLHlCQUFuQztBQUNBLFNBQVMsTUFBVCxFQUFpQixNQUFqQixRQUErQixTQUEvQjtBQUNBLFNBQVMsb0JBQVQsUUFBcUMsU0FBckM7QUFNQSxPQUFPLE1BQU0sUUFBUSxHQUFhLENBQTNCO0FBQ1AsT0FBTyxNQUFNLE9BQU8sR0FBYSxDQUExQjtBQUNQLE9BQU8sTUFBTSxRQUFRLEdBQWEsR0FBM0I7QUFFUCxJQUFJLFNBQVMsR0FBRyxPQUFoQjtBQUVBLE9BQU0sU0FBVSxJQUFWLEdBQWM7QUFDbEIsRUFBQSxTQUFTO0FBQ1YsQyxDQUVEOztBQUVBLE9BQU8sTUFBTSxPQUFPLEdBQWtCLE1BQU0sQ0FBQyxhQUFELENBQXJDLEMsQ0FRUDs7QUFFQTs7Ozs7Ozs7O0FBUUEsT0FBTSxTQUFVLFdBQVYsQ0FBc0IsR0FBdEIsRUFBOEI7QUFDbEMsU0FBTyxHQUFHLENBQUMsT0FBRCxDQUFILEVBQVA7QUFDRDtBQUVEOzs7Ozs7Ozs7OztBQVVBLE9BQU0sU0FBVSxXQUFWLENBQXNCLEdBQXRCLEVBQWdDLFFBQWhDLEVBQWtEO0FBQ3RELFNBQU8sUUFBUSxJQUFJLEdBQUcsQ0FBQyxPQUFELENBQUgsRUFBbkI7QUFDRDtBQWlCRCxNQUFNLElBQUksR0FBa0IsTUFBTSxDQUFDLFVBQUQsQ0FBbEMsQyxDQUVBO0FBQ0E7O0FBQ0EsT0FBTyxJQUFJLFlBQUo7O0FBRVAsSUFBSSxLQUFKLEVBQVc7QUFDVCxFQUFBLFlBQVksR0FBRyxJQUFJLE9BQUosRUFBZjtBQUNEOztBQUVELFNBQVMsWUFBVCxDQUFzQixHQUF0QixFQUE4QjtBQUM1QixNQUFJLFlBQVksS0FBSyxTQUFyQixFQUFnQztBQUM5QixXQUFPLElBQVA7QUFDRCxHQUZELE1B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QUNBLFdBQVcsQ0FBQyxJQUFELENBQVg7QUFDQSxTQUFTLENBQUMsSUFBRCxDQUFUO0FBQ0EsV0FBVyxDQUFDLElBQUQsQ0FBWCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERFQlVHIH0gZnJvbSAnQGdsaW1tZXIvZW52JztcbmltcG9ydCB7IHNjaGVkdWxlUmV2YWxpZGF0ZSB9IGZyb20gJ0BnbGltbWVyL2dsb2JhbC1jb250ZXh0JztcbmltcG9ydCB7IHN5bWJvbCwgdW53cmFwIH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgeyBhc3NlcnRUYWdOb3RDb25zdW1lZCB9IGZyb20gJy4vZGVidWcnO1xuXG4vLy8vLy8vLy8vXG5cbmV4cG9ydCB0eXBlIFJldmlzaW9uID0gbnVtYmVyO1xuXG5leHBvcnQgY29uc3QgQ09OU1RBTlQ6IFJldmlzaW9uID0gMDtcbmV4cG9ydCBjb25zdCBJTklUSUFMOiBSZXZpc2lvbiA9IDE7XG5leHBvcnQgY29uc3QgVk9MQVRJTEU6IFJldmlzaW9uID0gTmFOO1xuXG5sZXQgJFJFVklTSU9OID0gSU5JVElBTDtcblxuZXhwb3J0IGZ1bmN0aW9uIGJ1bXAoKTogdm9pZCB7XG4gICRSRVZJU0lPTisrO1xufVxuXG4vLy8vLy8vLy8vXG5cbmV4cG9ydCBjb25zdCBDT01QVVRFOiB1bmlxdWUgc3ltYm9sID0gc3ltYm9sKCdUQUdfQ09NUFVURScpO1xuXG5leHBvcnQgaW50ZXJmYWNlIEVudGl0eVRhZzxUPiB7XG4gIFtDT01QVVRFXSgpOiBUO1xufVxuXG5leHBvcnQgdHlwZSBUYWcgPSBFbnRpdHlUYWc8UmV2aXNpb24+O1xuXG4vLy8vLy8vLy8vXG5cbi8qKlxuICogYHZhbHVlYCByZWNlaXZlcyBhIHRhZyBhbmQgcmV0dXJucyBhbiBvcGFxdWUgUmV2aXNpb24gYmFzZWQgb24gdGhhdCB0YWcuIFRoaXNcbiAqIHNuYXBzaG90IGNhbiB0aGVuIGxhdGVyIGJlIHBhc3NlZCB0byBgdmFsaWRhdGVgIHdpdGggdGhlIHNhbWUgdGFnIHRvXG4gKiBkZXRlcm1pbmUgaWYgdGhlIHRhZyBoYXMgY2hhbmdlZCBhdCBhbGwgc2luY2UgdGhlIHRpbWUgdGhhdCBgdmFsdWVgIHdhc1xuICogY2FsbGVkLlxuICpcbiAqIEBwYXJhbSB0YWdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbHVlRm9yVGFnKHRhZzogVGFnKTogUmV2aXNpb24ge1xuICByZXR1cm4gdGFnW0NPTVBVVEVdKCk7XG59XG5cbi8qKlxuICogYHZhbGlkYXRlYCByZWNlaXZlcyBhIHRhZyBhbmQgYSBzbmFwc2hvdCBmcm9tIGEgcHJldmlvdXMgY2FsbCB0byBgdmFsdWVgIHdpdGhcbiAqIHRoZSBzYW1lIHRhZywgYW5kIGRldGVybWluZXMgaWYgdGhlIHRhZyBpcyBzdGlsbCB2YWxpZCBjb21wYXJlZCB0byB0aGVcbiAqIHNuYXBzaG90LiBJZiB0aGUgdGFnJ3Mgc3RhdGUgaGFzIGNoYW5nZWQgYXQgYWxsIHNpbmNlIHRoZW4sIGB2YWxpZGF0ZWAgd2lsbFxuICogcmV0dXJuIGZhbHNlLCBvdGhlcndpc2UgaXQgd2lsbCByZXR1cm4gdHJ1ZS4gVGhpcyBpcyB1c2VkIHRvIGRldGVybWluZSBpZiBhXG4gKiBjYWxjdWxhdGlvbiByZWxhdGVkIHRvIHRoZSB0YWdzIHNob3VsZCBiZSByZXJ1bi5cbiAqXG4gKiBAcGFyYW0gdGFnXG4gKiBAcGFyYW0gc25hcHNob3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlVGFnKHRhZzogVGFnLCBzbmFwc2hvdDogUmV2aXNpb24pOiBib29sZWFuIHtcbiAgcmV0dXJuIHNuYXBzaG90ID49IHRhZ1tDT01QVVRFXSgpO1xufVxuXG4vLy8vLy8vLy8vXG5cbi8qKlxuICogVGhpcyBlbnVtIHJlcHJlc2VudHMgYWxsIG9mIHRoZSBwb3NzaWJsZSB0YWcgdHlwZXMgZm9yIHRoZSBtb25vbW9ycGhpYyB0YWcgY2xhc3MuXG4gKiBPdGhlciBjdXN0b20gdGFnIGNsYXNzZXMgY2FuIGV4aXN0LCBzdWNoIGFzIEN1cnJlbnRUYWcgYW5kIFZvbGF0aWxlVGFnLCBidXQgZm9yXG4gKiBwZXJmb3JtYW5jZSByZWFzb25zLCBhbnkgdHlwZSBvZiB0YWcgdGhhdCBpcyBtZWFudCB0byBiZSB1c2VkIGZyZXF1ZW50bHkgc2hvdWxkXG4gKiBiZSBhZGRlZCB0byB0aGUgbW9ub21vcnBoaWMgdGFnLlxuICovXG5jb25zdCBlbnVtIE1vbm9tb3JwaGljVGFnVHlwZXMge1xuICBEaXJ0eWFibGUsXG4gIFVwZGF0YWJsZSxcbiAgQ29tYmluYXRvcixcbiAgQ29uc3RhbnQsXG59XG5cbmNvbnN0IFRZUEU6IHVuaXF1ZSBzeW1ib2wgPSBzeW1ib2woJ1RBR19UWVBFJyk7XG5cbi8vIHRoaXMgaXMgYmFzaWNhbGx5IGEgY29uc3Rcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbmV4cG9ydCBsZXQgQUxMT1dfQ1lDTEVTOiBXZWFrTWFwPFRhZywgYm9vbGVhbj4gfCB1bmRlZmluZWQ7XG5cbmlmIChERUJVRykge1xuICBBTExPV19DWUNMRVMgPSBuZXcgV2Vha01hcCgpO1xufVxuXG5mdW5jdGlvbiBhbGxvd3NDeWNsZXModGFnOiBUYWcpOiBib29sZWFuIHtcbiAgaWYgKEFMTE9XX0NZQ0xFUyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIEFMTE9XX0NZQ0xFUy5oYXModGFnKTtcbiAgfVxufVxuXG5pbnRlcmZhY2UgTW9ub21vcnBoaWNUYWdCYXNlPFQgZXh0ZW5kcyBNb25vbW9ycGhpY1RhZ1R5cGVzPiBleHRlbmRzIFRhZyB7XG4gIFtUWVBFXTogVDtcbn1cblxuZXhwb3J0IHR5cGUgRGlydHlhYmxlVGFnID0gTW9ub21vcnBoaWNUYWdCYXNlPE1vbm9tb3JwaGljVGFnVHlwZXMuRGlydHlhYmxlPjtcbmV4cG9ydCB0eXBlIFVwZGF0YWJsZVRhZyA9IE1vbm9tb3JwaGljVGFnQmFzZTxNb25vbW9ycGhpY1RhZ1R5cGVzLlVwZGF0YWJsZT47XG5leHBvcnQgdHlwZSBDb21iaW5hdG9yVGFnID0gTW9ub21vcnBoaWNUYWdCYXNlPE1vbm9tb3JwaGljVGFnVHlwZXMuQ29tYmluYXRvcj47XG5leHBvcnQgdHlwZSBDb25zdGFudFRhZyA9IE1vbm9tb3JwaGljVGFnQmFzZTxNb25vbW9ycGhpY1RhZ1R5cGVzLkNvbnN0YW50PjtcblxuY2xhc3MgTW9ub21vcnBoaWNUYWdJbXBsPFQgZXh0ZW5kcyBNb25vbW9ycGhpY1RhZ1R5cGVzID0gTW9ub21vcnBoaWNUYWdUeXBlcz4ge1xuICBzdGF0aWMgY29tYmluZSh0YWdzOiBUYWdbXSk6IFRhZyB7XG4gICAgc3dpdGNoICh0YWdzLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gQ09OU1RBTlRfVEFHO1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gdGFnc1swXTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGxldCB0YWc6IE1vbm9tb3JwaGljVGFnSW1wbCA9IG5ldyBNb25vbW9ycGhpY1RhZ0ltcGwoTW9ub21vcnBoaWNUYWdUeXBlcy5Db21iaW5hdG9yKTtcbiAgICAgICAgdGFnLnN1YnRhZyA9IHRhZ3M7XG4gICAgICAgIHJldHVybiB0YWc7XG4gICAgfVxuICB9XG4gIHByaXZhdGUgcmV2aXNpb24gPSBJTklUSUFMO1xuICBwcml2YXRlIGxhc3RDaGVja2VkID0gSU5JVElBTDtcbiAgcHJpdmF0ZSBsYXN0VmFsdWUgPSBJTklUSUFMO1xuXG4gIHByaXZhdGUgaXNVcGRhdGluZyA9IGZhbHNlO1xuICBwcml2YXRlIHN1YnRhZzogVGFnIHwgVGFnW10gfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBzdWJ0YWdCdWZmZXJDYWNoZTogUmV2aXNpb24gfCBudWxsID0gbnVsbDtcblxuICBbVFlQRV06IFQ7XG5cbiAgY29uc3RydWN0b3IodHlwZTogVCkge1xuICAgIHRoaXNbVFlQRV0gPSB0eXBlO1xuICB9XG5cbiAgW0NPTVBVVEVdKCk6IFJldmlzaW9uIHtcbiAgICBsZXQgeyBsYXN0Q2hlY2tlZCB9ID0gdGhpcztcblxuICAgIGlmICh0aGlzLmlzVXBkYXRpbmcgPT09IHRydWUpIHtcbiAgICAgIGlmIChERUJVRyAmJiAhYWxsb3dzQ3ljbGVzKHRoaXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ3ljbGVzIGluIHRhZ3MgYXJlIG5vdCBhbGxvd2VkJyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGFzdENoZWNrZWQgPSArKyRSRVZJU0lPTjtcbiAgICB9IGVsc2UgaWYgKGxhc3RDaGVja2VkICE9PSAkUkVWSVNJT04pIHtcbiAgICAgIHRoaXMuaXNVcGRhdGluZyA9IHRydWU7XG4gICAgICB0aGlzLmxhc3RDaGVja2VkID0gJFJFVklTSU9OO1xuXG4gICAgICB0cnkge1xuICAgICAgICBsZXQgeyBzdWJ0YWcsIHJldmlzaW9uIH0gPSB0aGlzO1xuXG4gICAgICAgIGlmIChzdWJ0YWcgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzdWJ0YWcpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN1YnRhZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBzdWJ0YWdbaV1bQ09NUFVURV0oKTtcbiAgICAgICAgICAgICAgcmV2aXNpb24gPSBNYXRoLm1heCh2YWx1ZSwgcmV2aXNpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgc3VidGFnVmFsdWUgPSBzdWJ0YWdbQ09NUFVURV0oKTtcblxuICAgICAgICAgICAgaWYgKHN1YnRhZ1ZhbHVlID09PSB0aGlzLnN1YnRhZ0J1ZmZlckNhY2hlKSB7XG4gICAgICAgICAgICAgIHJldmlzaW9uID0gTWF0aC5tYXgocmV2aXNpb24sIHRoaXMubGFzdFZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIENsZWFyIHRoZSB0ZW1wb3JhcnkgYnVmZmVyIGNhY2hlXG4gICAgICAgICAgICAgIHRoaXMuc3VidGFnQnVmZmVyQ2FjaGUgPSBudWxsO1xuICAgICAgICAgICAgICByZXZpc2lvbiA9IE1hdGgubWF4KHJldmlzaW9uLCBzdWJ0YWdWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5sYXN0VmFsdWUgPSByZXZpc2lvbjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRoaXMuaXNVcGRhdGluZyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmxhc3RWYWx1ZTtcbiAgfVxuXG4gIHN0YXRpYyB1cGRhdGVUYWcoX3RhZzogVXBkYXRhYmxlVGFnLCBfc3VidGFnOiBUYWcpIHtcbiAgICBpZiAoREVCVUcgJiYgX3RhZ1tUWVBFXSAhPT0gTW9ub21vcnBoaWNUYWdUeXBlcy5VcGRhdGFibGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGVkIHRvIHVwZGF0ZSBhIHRhZyB0aGF0IHdhcyBub3QgdXBkYXRhYmxlJyk7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogVFMgMy43IHNob3VsZCBhbGxvdyB1cyB0byBkbyB0aGlzIHZpYSBhc3NlcnRpb25cbiAgICBsZXQgdGFnID0gX3RhZyBhcyBNb25vbW9ycGhpY1RhZ0ltcGw7XG4gICAgbGV0IHN1YnRhZyA9IF9zdWJ0YWcgYXMgTW9ub21vcnBoaWNUYWdJbXBsO1xuXG4gICAgaWYgKHN1YnRhZyA9PT0gQ09OU1RBTlRfVEFHKSB7XG4gICAgICB0YWcuc3VidGFnID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlcmUgYXJlIHR3byBkaWZmZXJlbnQgcG9zc2liaWxpdGllcyB3aGVuIHVwZGF0aW5nIGEgc3VidGFnOlxuICAgICAgLy9cbiAgICAgIC8vIDEuIHN1YnRhZ1tDT01QVVRFXSgpIDw9IHRhZ1tDT01QVVRFXSgpO1xuICAgICAgLy8gMi4gc3VidGFnW0NPTVBVVEVdKCkgPiB0YWdbQ09NUFVURV0oKTtcbiAgICAgIC8vXG4gICAgICAvLyBUaGUgZmlyc3QgcG9zc2liaWxpdHkgaXMgY29tcGxldGVseSBmaW5lIHdpdGhpbiBvdXIgY2FjaGluZyBtb2RlbCwgYnV0XG4gICAgICAvLyB0aGUgc2Vjb25kIHBvc3NpYmlsaXR5IHByZXNlbnRzIGEgcHJvYmxlbS4gSWYgdGhlIHBhcmVudCB0YWcgaGFzXG4gICAgICAvLyBhbHJlYWR5IGJlZW4gcmVhZCwgdGhlbiBpdCdzIHZhbHVlIGlzIGNhY2hlZCBhbmQgd2lsbCBub3QgdXBkYXRlIHRvXG4gICAgICAvLyByZWZsZWN0IHRoZSBzdWJ0YWcncyBncmVhdGVyIHZhbHVlLiBOZXh0IHRpbWUgdGhlIGNhY2hlIGlzIGJ1c3RlZCwgdGhlXG4gICAgICAvLyBzdWJ0YWcncyB2YWx1ZSBfd2lsbF8gYmUgcmVhZCwgYW5kIGl0J3MgdmFsdWUgd2lsbCBiZSBfZ3JlYXRlcl8gdGhhblxuICAgICAgLy8gdGhlIHNhdmVkIHNuYXBzaG90IG9mIHRoZSBwYXJlbnQsIGNhdXNpbmcgdGhlIHJlc3VsdGluZyBjYWxjdWxhdGlvbiB0b1xuICAgICAgLy8gYmUgcmVydW4gZXJyb25lb3VzbHkuXG4gICAgICAvL1xuICAgICAgLy8gSW4gb3JkZXIgdG8gcHJldmVudCB0aGlzLCB3aGVuIHdlIGZpcnN0IHVwZGF0ZSB0byBhIG5ldyBzdWJ0YWcgd2Ugc3RvcmVcbiAgICAgIC8vIGl0cyBjb21wdXRlZCB2YWx1ZSwgYW5kIHRoZW4gY2hlY2sgYWdhaW5zdCB0aGF0IGNvbXB1dGVkIHZhbHVlIG9uXG4gICAgICAvLyBzdWJzZXF1ZW50IHVwZGF0ZXMuIElmIGl0cyB2YWx1ZSBoYXNuJ3QgY2hhbmdlZCwgdGhlbiB3ZSByZXR1cm4gdGhlXG4gICAgICAvLyBwYXJlbnQncyBwcmV2aW91cyB2YWx1ZS4gT25jZSB0aGUgc3VidGFnIGNoYW5nZXMgZm9yIHRoZSBmaXJzdCB0aW1lLFxuICAgICAgLy8gd2UgY2xlYXIgdGhlIGNhY2hlIGFuZCBldmVyeXRoaW5nIGlzIGZpbmFsbHkgaW4gc3luYyB3aXRoIHRoZSBwYXJlbnQuXG4gICAgICB0YWcuc3VidGFnQnVmZmVyQ2FjaGUgPSBzdWJ0YWdbQ09NUFVURV0oKTtcbiAgICAgIHRhZy5zdWJ0YWcgPSBzdWJ0YWc7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGRpcnR5VGFnKHRhZzogRGlydHlhYmxlVGFnIHwgVXBkYXRhYmxlVGFnLCBkaXNhYmxlQ29uc3VtcHRpb25Bc3NlcnRpb24/OiBib29sZWFuKSB7XG4gICAgaWYgKFxuICAgICAgREVCVUcgJiZcbiAgICAgICEodGFnW1RZUEVdID09PSBNb25vbW9ycGhpY1RhZ1R5cGVzLlVwZGF0YWJsZSB8fCB0YWdbVFlQRV0gPT09IE1vbm9tb3JwaGljVGFnVHlwZXMuRGlydHlhYmxlKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdHRlbXB0ZWQgdG8gZGlydHkgYSB0YWcgdGhhdCB3YXMgbm90IGRpcnR5YWJsZScpO1xuICAgIH1cblxuICAgIGlmIChERUJVRyAmJiBkaXNhYmxlQ29uc3VtcHRpb25Bc3NlcnRpb24gIT09IHRydWUpIHtcbiAgICAgIC8vIFVzdWFsbHkgYnkgdGhpcyBwb2ludCwgd2UndmUgYWxyZWFkeSBhc3NlcnRlZCB3aXRoIGJldHRlciBlcnJvciBpbmZvcm1hdGlvbixcbiAgICAgIC8vIGJ1dCB0aGlzIGlzIG91ciBsYXN0IGxpbmUgb2YgZGVmZW5zZS5cbiAgICAgIHVud3JhcChhc3NlcnRUYWdOb3RDb25zdW1lZCkodGFnKTtcbiAgICB9XG5cbiAgICAodGFnIGFzIE1vbm9tb3JwaGljVGFnSW1wbCkucmV2aXNpb24gPSArKyRSRVZJU0lPTjtcblxuICAgIHNjaGVkdWxlUmV2YWxpZGF0ZSgpO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBESVJUWV9UQUcgPSBNb25vbW9ycGhpY1RhZ0ltcGwuZGlydHlUYWc7XG5leHBvcnQgY29uc3QgVVBEQVRFX1RBRyA9IE1vbm9tb3JwaGljVGFnSW1wbC51cGRhdGVUYWc7XG5cbi8vLy8vLy8vLy9cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVRhZygpOiBEaXJ0eWFibGVUYWcge1xuICByZXR1cm4gbmV3IE1vbm9tb3JwaGljVGFnSW1wbChNb25vbW9ycGhpY1RhZ1R5cGVzLkRpcnR5YWJsZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVVcGRhdGFibGVUYWcoKTogVXBkYXRhYmxlVGFnIHtcbiAgcmV0dXJuIG5ldyBNb25vbW9ycGhpY1RhZ0ltcGwoTW9ub21vcnBoaWNUYWdUeXBlcy5VcGRhdGFibGUpO1xufVxuXG4vLy8vLy8vLy8vXG5cbmV4cG9ydCBjb25zdCBDT05TVEFOVF9UQUc6IENvbnN0YW50VGFnID0gbmV3IE1vbm9tb3JwaGljVGFnSW1wbChNb25vbW9ycGhpY1RhZ1R5cGVzLkNvbnN0YW50KTtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzQ29uc3RUYWcodGFnOiBUYWcpOiB0YWcgaXMgQ29uc3RhbnRUYWcge1xuICByZXR1cm4gdGFnID09PSBDT05TVEFOVF9UQUc7XG59XG5cbi8vLy8vLy8vLy9cblxuZXhwb3J0IGNsYXNzIFZvbGF0aWxlVGFnIGltcGxlbWVudHMgVGFnIHtcbiAgW0NPTVBVVEVdKCk6IFJldmlzaW9uIHtcbiAgICByZXR1cm4gVk9MQVRJTEU7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IFZPTEFUSUxFX1RBRyA9IG5ldyBWb2xhdGlsZVRhZygpO1xuXG4vLy8vLy8vLy8vXG5cbmV4cG9ydCBjbGFzcyBDdXJyZW50VGFnIGltcGxlbWVudHMgQ3VycmVudFRhZyB7XG4gIFtDT01QVVRFXSgpOiBSZXZpc2lvbiB7XG4gICAgcmV0dXJuICRSRVZJU0lPTjtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgQ1VSUkVOVF9UQUcgPSBuZXcgQ3VycmVudFRhZygpO1xuXG4vLy8vLy8vLy8vXG5cbmV4cG9ydCBjb25zdCBjb21iaW5lID0gTW9ub21vcnBoaWNUYWdJbXBsLmNvbWJpbmU7XG5cbi8vIFdhcm1cblxubGV0IHRhZzEgPSBjcmVhdGVVcGRhdGFibGVUYWcoKTtcbmxldCB0YWcyID0gY3JlYXRlVXBkYXRhYmxlVGFnKCk7XG5sZXQgdGFnMyA9IGNyZWF0ZVVwZGF0YWJsZVRhZygpO1xuXG52YWx1ZUZvclRhZyh0YWcxKTtcbkRJUlRZX1RBRyh0YWcxKTtcbnZhbHVlRm9yVGFnKHRhZzEpO1xuVVBEQVRFX1RBRyh0YWcxLCBjb21iaW5lKFt0YWcyLCB0YWczXSkpO1xudmFsdWVGb3JUYWcodGFnMSk7XG5ESVJUWV9UQUcodGFnMik7XG52YWx1ZUZvclRhZyh0YWcxKTtcbkRJUlRZX1RBRyh0YWczKTtcbnZhbHVlRm9yVGFnKHRhZzEpO1xuVVBEQVRFX1RBRyh0YWcxLCB0YWczKTtcbnZhbHVlRm9yVGFnKHRhZzEpO1xuRElSVFlfVEFHKHRhZzMpO1xudmFsdWVGb3JUYWcodGFnMSk7XG4iXSwic291cmNlUm9vdCI6IiJ9