import { DEBUG } from '@glimmer/env';
import { CONSTANT_TAG, validateTag, valueForTag, isConstTag, combine } from './validators';
import { markTagAsConsumed, beginTrackingTransaction, endTrackingTransaction, resetTrackingTransaction } from './debug';
import { symbol, unwrap } from './utils';
/**
 * An object that that tracks @tracked properties that were consumed.
 */

class Tracker {
  constructor() {
    this.tags = new Set();
    this.last = null;
  }

  add(tag) {
    if (tag === CONSTANT_TAG) return;
    this.tags.add(tag);

    if (DEBUG) {
      unwrap(markTagAsConsumed)(tag);
    }

    this.last = tag;
  }

  combine() {
    let {
      tags
    } = this;

    if (tags.size === 0) {
      return CONSTANT_TAG;
    } else if (tags.size === 1) {
      return this.last;
    } else {
      let tagsArr = [];
      tags.forEach(tag => tagsArr.push(tag));
      return combine(tagsArr);
    }
  }

}
/**
 * Whenever a tracked computed property is entered, the current tracker is
 * saved off and a new tracker is replaced.
 *
 * Any tracked properties consumed are added to the current tracker.
 *
 * When a tracked computed property is exited, the tracker's tags are
 * combined and added to the parent tracker.
 *
 * The consequence is that each tracked computed property has a tag
 * that corresponds to the tracked properties consumed inside of
 * itself, including child tracked computed properties.
 */


let CURRENT_TRACKER = null;
const OPEN_TRACK_FRAMES = [];
export function beginTrackFrame(debuggingContext) {
  OPEN_TRACK_FRAMES.push(CURRENT_TRACKER);
  CURRENT_TRACKER = new Tracker();

  if (DEBUG) {
    unwrap(beginTrackingTransaction)(debuggingContext);
  }
}
export function endTrackFrame() {
  let current = CURRENT_TRACKER;

  if (DEBUG) {
    if (OPEN_TRACK_FRAMES.length === 0) {
      throw new Error('attempted to close a tracking frame, but one was not open');
    }

    unwrap(endTrackingTransaction)();
  }

  CURRENT_TRACKER = OPEN_TRACK_FRAMES.pop() || null;
  return unwrap(current).combine();
}
export function beginUntrackFrame() {
  OPEN_TRACK_FRAMES.push(CURRENT_TRACKER);
  CURRENT_TRACKER = null;
}
export function endUntrackFrame() {
  if (DEBUG && OPEN_TRACK_FRAMES.length === 0) {
    throw new Error('attempted to close a tracking frame, but one was not open');
  }

  CURRENT_TRACKER = OPEN_TRACK_FRAMES.pop() || null;
} // This function is only for handling errors and resetting to a valid state

export function resetTracking() {
  while (OPEN_TRACK_FRAMES.length > 0) {
    OPEN_TRACK_FRAMES.pop();
  }

  CURRENT_TRACKER = null;

  if (DEBUG) {
    return unwrap(resetTrackingTransaction)();
  }
}
export function isTracking() {
  return CURRENT_TRACKER !== null;
}
export function consumeTag(tag) {
  if (CURRENT_TRACKER !== null) {
    CURRENT_TRACKER.add(tag);
  }
} //////////

const CACHE_KEY = symbol('CACHE_KEY');
const FN = symbol('FN');
const LAST_VALUE = symbol('LAST_VALUE');
const TAG = symbol('TAG');
const SNAPSHOT = symbol('SNAPSHOT');
const DEBUG_LABEL = symbol('DEBUG_LABEL');
export function createCache(fn, debuggingLabel) {
  if (DEBUG && !(typeof fn === 'function')) {
    throw new Error(`createCache() must be passed a function as its first parameter. Called with: ${String(fn)}`);
  }

  let cache = {
    [FN]: fn,
    [LAST_VALUE]: undefined,
    [TAG]: undefined,
    [SNAPSHOT]: -1
  };

  if (DEBUG) {
    cache[DEBUG_LABEL] = debuggingLabel;
  }

  return cache;
}
export function getValue(cache) {
  assertCache(cache, 'getValue');
  let fn = cache[FN];
  let tag = cache[TAG];
  let snapshot = cache[SNAPSHOT];

  if (tag === undefined || !validateTag(tag, snapshot)) {
    beginTrackFrame();

    try {
      cache[LAST_VALUE] = fn();
    } finally {
      tag = endTrackFrame();
      cache[TAG] = tag;
      cache[SNAPSHOT] = valueForTag(tag);
      consumeTag(tag);
    }
  } else {
    consumeTag(tag);
  }

  return cache[LAST_VALUE];
}
export function isConst(cache) {
  assertCache(cache, 'isConst');
  let tag = cache[TAG];
  assertTag(tag, cache);
  return isConstTag(tag);
}

function assertCache(value, fnName) {
  if (DEBUG && !(typeof value === 'object' && value !== null && FN in value)) {
    throw new Error(`${fnName}() can only be used on an instance of a cache created with createCache(). Called with: ${String(value)}`);
  }
} // replace this with `expect` when we can


function assertTag(tag, cache) {
  if (DEBUG && tag === undefined) {
    throw new Error(`isConst() can only be used on a cache once getValue() has been called at least once. Called with cache function:\n\n${String(cache[FN])}`);
  }
} //////////
// Legacy tracking APIs
// track() shouldn't be necessary at all in the VM once the autotracking
// refactors are merged, and we should generally be moving away from it. It may
// be necessary in Ember for a while longer, but I think we'll be able to drop
// it in favor of cache sooner rather than later.


export function track(callback, debugLabel) {
  beginTrackFrame(debugLabel);
  let tag;

  try {
    callback();
  } finally {
    tag = endTrackFrame();
  }

  return tag;
} // untrack() is currently mainly used to handle places that were previously not
// tracked, and that tracking now would cause backtracking rerender assertions.
// I think once we move everyone forward onto modern APIs, we'll probably be
// able to remove it, but I'm not sure yet.

export function untrack(callback) {
  beginUntrackFrame();

  try {
    return callback();
  } finally {
    endUntrackFrame();
  }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3ZhbGlkYXRvci9saWIvdHJhY2tpbmcudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsU0FBUyxLQUFULFFBQXNCLGNBQXRCO0FBQ0EsU0FFRSxZQUZGLEVBR0UsV0FIRixFQUtFLFdBTEYsRUFNRSxVQU5GLEVBT0UsT0FQRixRQVFPLGNBUlA7QUFVQSxTQUNFLGlCQURGLEVBRUUsd0JBRkYsRUFHRSxzQkFIRixFQUlFLHdCQUpGLFFBS08sU0FMUDtBQU1BLFNBQVMsTUFBVCxFQUFpQixNQUFqQixRQUErQixTQUEvQjtBQUlBOzs7O0FBR0EsTUFBTSxPQUFOLENBQWE7QUFBYixFQUFBLFdBQUEsR0FBQTtBQUNVLFNBQUEsSUFBQSxHQUFPLElBQUksR0FBSixFQUFQO0FBQ0EsU0FBQSxJQUFBLEdBQW9CLElBQXBCO0FBMkJUOztBQXpCQyxFQUFBLEdBQUcsQ0FBQyxHQUFELEVBQVM7QUFDVixRQUFJLEdBQUcsS0FBSyxZQUFaLEVBQTBCO0FBRTFCLFNBQUssSUFBTCxDQUFVLEdBQVYsQ0FBYyxHQUFkOztBQUVBLFFBQUksS0FBSixFQUFXO0FBQ1QsTUFBQSxNQUFNLENBQUMsaUJBQUQsQ0FBTixDQUEwQixHQUExQjtBQUNEOztBQUVELFNBQUssSUFBTCxHQUFZLEdBQVo7QUFDRDs7QUFFRCxFQUFBLE9BQU8sR0FBQTtBQUNMLFFBQUk7QUFBRSxNQUFBO0FBQUYsUUFBVyxJQUFmOztBQUVBLFFBQUksSUFBSSxDQUFDLElBQUwsS0FBYyxDQUFsQixFQUFxQjtBQUNuQixhQUFPLFlBQVA7QUFDRCxLQUZELE1BRU8sSUFBSSxJQUFJLENBQUMsSUFBTCxLQUFjLENBQWxCLEVBQXFCO0FBQzFCLGFBQU8sS0FBSyxJQUFaO0FBQ0QsS0FGTSxNQUVBO0FBQ0wsVUFBSSxPQUFPLEdBQVUsRUFBckI7QUFDQSxNQUFBLElBQUksQ0FBQyxPQUFMLENBQWMsR0FBRCxJQUFTLE9BQU8sQ0FBQyxJQUFSLENBQWEs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ZnJvbSAnQGdsaW1tZXIvZW52JztcbmltcG9ydCB7XG4gIFRhZyxcbiAgQ09OU1RBTlRfVEFHLFxuICB2YWxpZGF0ZVRhZyxcbiAgUmV2aXNpb24sXG4gIHZhbHVlRm9yVGFnLFxuICBpc0NvbnN0VGFnLFxuICBjb21iaW5lLFxufSBmcm9tICcuL3ZhbGlkYXRvcnMnO1xuXG5pbXBvcnQge1xuICBtYXJrVGFnQXNDb25zdW1lZCxcbiAgYmVnaW5UcmFja2luZ1RyYW5zYWN0aW9uLFxuICBlbmRUcmFja2luZ1RyYW5zYWN0aW9uLFxuICByZXNldFRyYWNraW5nVHJhbnNhY3Rpb24sXG59IGZyb20gJy4vZGVidWcnO1xuaW1wb3J0IHsgc3ltYm9sLCB1bndyYXAgfSBmcm9tICcuL3V0aWxzJztcblxudHlwZSBPcHRpb248VD4gPSBUIHwgbnVsbDtcblxuLyoqXG4gKiBBbiBvYmplY3QgdGhhdCB0aGF0IHRyYWNrcyBAdHJhY2tlZCBwcm9wZXJ0aWVzIHRoYXQgd2VyZSBjb25zdW1lZC5cbiAqL1xuY2xhc3MgVHJhY2tlciB7XG4gIHByaXZhdGUgdGFncyA9IG5ldyBTZXQ8VGFnPigpO1xuICBwcml2YXRlIGxhc3Q6IE9wdGlvbjxUYWc+ID0gbnVsbDtcblxuICBhZGQodGFnOiBUYWcpIHtcbiAgICBpZiAodGFnID09PSBDT05TVEFOVF9UQUcpIHJldHVybjtcblxuICAgIHRoaXMudGFncy5hZGQodGFnKTtcblxuICAgIGlmIChERUJVRykge1xuICAgICAgdW53cmFwKG1hcmtUYWdBc0NvbnN1bWVkKSh0YWcpO1xuICAgIH1cblxuICAgIHRoaXMubGFzdCA9IHRhZztcbiAgfVxuXG4gIGNvbWJpbmUoKTogVGFnIHtcbiAgICBsZXQgeyB0YWdzIH0gPSB0aGlzO1xuXG4gICAgaWYgKHRhZ3Muc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIENPTlNUQU5UX1RBRztcbiAgICB9IGVsc2UgaWYgKHRhZ3Muc2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIHRoaXMubGFzdCBhcyBUYWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCB0YWdzQXJyOiBUYWdbXSA9IFtdO1xuICAgICAgdGFncy5mb3JFYWNoKCh0YWcpID0+IHRhZ3NBcnIucHVzaCh0YWcpKTtcbiAgICAgIHJldHVybiBjb21iaW5lKHRhZ3NBcnIpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFdoZW5ldmVyIGEgdHJhY2tlZCBjb21wdXRlZCBwcm9wZXJ0eSBpcyBlbnRlcmVkLCB0aGUgY3VycmVudCB0cmFja2VyIGlzXG4gKiBzYXZlZCBvZmYgYW5kIGEgbmV3IHRyYWNrZXIgaXMgcmVwbGFjZWQuXG4gKlxuICogQW55IHRyYWNrZWQgcHJvcGVydGllcyBjb25zdW1lZCBhcmUgYWRkZWQgdG8gdGhlIGN1cnJlbnQgdHJhY2tlci5cbiAqXG4gKiBXaGVuIGEgdHJhY2tlZCBjb21wdXRlZCBwcm9wZXJ0eSBpcyBleGl0ZWQsIHRoZSB0cmFja2VyJ3MgdGFncyBhcmVcbiAqIGNvbWJpbmVkIGFuZCBhZGRlZCB0byB0aGUgcGFyZW50IHRyYWNrZXIuXG4gKlxuICogVGhlIGNvbnNlcXVlbmNlIGlzIHRoYXQgZWFjaCB0cmFja2VkIGNvbXB1dGVkIHByb3BlcnR5IGhhcyBhIHRhZ1xuICogdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgdHJhY2tlZCBwcm9wZXJ0aWVzIGNvbnN1bWVkIGluc2lkZSBvZlxuICogaXRzZWxmLCBpbmNsdWRpbmcgY2hpbGQgdHJhY2tlZCBjb21wdXRlZCBwcm9wZXJ0aWVzLlxuICovXG5sZXQgQ1VSUkVOVF9UUkFDS0VSOiBPcHRpb248VHJhY2tlcj4gPSBudWxsO1xuXG5jb25zdCBPUEVOX1RSQUNLX0ZSQU1FUzogT3B0aW9uPFRyYWNrZXI+W10gPSBbXTtcblxuZXhwb3J0IGZ1bmN0aW9uIGJlZ2luVHJhY2tGcmFtZShkZWJ1Z2dpbmdDb250ZXh0Pzogc3RyaW5nIHwgZmFsc2UpOiB2b2lkIHtcbiAgT1BFTl9UUkFDS19GUkFNRVMucHVzaChDVVJSRU5UX1RSQUNLRVIpO1xuXG4gIENVUlJFTlRfVFJBQ0tFUiA9IG5ldyBUcmFja2VyKCk7XG5cbiAgaWYgKERFQlVHKSB7XG4gICAgdW53cmFwKGJlZ2luVHJhY2tpbmdUcmFuc2FjdGlvbikoZGVidWdnaW5nQ29udGV4dCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVuZFRyYWNrRnJhbWUoKTogVGFnIHtcbiAgbGV0IGN1cnJlbnQgPSBDVVJSRU5UX1RSQUNLRVI7XG5cbiAgaWYgKERFQlVHKSB7XG4gICAgaWYgKE9QRU5fVFJBQ0tfRlJBTUVTLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdhdHRlbXB0ZWQgdG8gY2xvc2UgYSB0cmFja2luZyBmcmFtZSwgYnV0IG9uZSB3YXMgbm90IG9wZW4nKTtcbiAgICB9XG5cbiAgICB1bndyYXAoZW5kVHJhY2tpbmdUcmFuc2FjdGlvbikoKTtcbiAgfVxuXG4gIENVUlJFTlRfVFJBQ0tFUiA9IE9QRU5fVFJBQ0tfRlJBTUVTLnBvcCgpIHx8IG51bGw7XG5cbiAgcmV0dXJuIHVud3JhcChjdXJyZW50KS5jb21iaW5lKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBiZWdpblVudHJhY2tGcmFtZSgpOiB2b2lkIHtcbiAgT1BFTl9UUkFDS19GUkFNRVMucHVzaChDVVJSRU5UX1RSQUNLRVIpO1xuICBDVVJSRU5UX1RSQUNLRVIgPSBudWxsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZW5kVW50cmFja0ZyYW1lKCk6IHZvaWQge1xuICBpZiAoREVCVUcgJiYgT1BFTl9UUkFDS19GUkFNRVMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdhdHRlbXB0ZWQgdG8gY2xvc2UgYSB0cmFja2luZyBmcmFtZSwgYnV0IG9uZSB3YXMgbm90IG9wZW4nKTtcbiAgfVxuXG4gIENVUlJFTlRfVFJBQ0tFUiA9IE9QRU5fVFJBQ0tfRlJBTUVTLnBvcCgpIHx8IG51bGw7XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgb25seSBmb3IgaGFuZGxpbmcgZXJyb3JzIGFuZCByZXNldHRpbmcgdG8gYSB2YWxpZCBzdGF0ZVxuZXhwb3J0IGZ1bmN0aW9uIHJlc2V0VHJhY2tpbmcoKTogc3RyaW5nIHwgdm9pZCB7XG4gIHdoaWxlIChPUEVOX1RSQUNLX0ZSQU1FUy5sZW5ndGggPiAwKSB7XG4gICAgT1BFTl9UUkFDS19GUkFNRVMucG9wKCk7XG4gIH1cblxuICBDVVJSRU5UX1RSQUNLRVIgPSBudWxsO1xuXG4gIGlmIChERUJVRykge1xuICAgIHJldHVybiB1bndyYXAocmVzZXRUcmFja2luZ1RyYW5zYWN0aW9uKSgpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1RyYWNraW5nKCk6IGJvb2xlYW4ge1xuICByZXR1cm4gQ1VSUkVOVF9UUkFDS0VSICE9PSBudWxsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29uc3VtZVRhZyh0YWc6IFRhZyk6IHZvaWQge1xuICBpZiAoQ1VSUkVOVF9UUkFDS0VSICE9PSBudWxsKSB7XG4gICAgQ1VSUkVOVF9UUkFDS0VSLmFkZCh0YWcpO1xuICB9XG59XG5cbi8vLy8vLy8vLy9cblxuY29uc3QgQ0FDSEVfS0VZOiB1bmlxdWUgc3ltYm9sID0gc3ltYm9sKCdDQUNIRV9LRVknKTtcblxuLy8gcHVibGljIGludGVyZmFjZVxuZXhwb3J0IGludGVyZmFjZSBDYWNoZTxUID0gdW5rbm93bj4ge1xuICBbQ0FDSEVfS0VZXTogVDtcbn1cblxuY29uc3QgRk46IHVuaXF1ZSBzeW1ib2wgPSBzeW1ib2woJ0ZOJyk7XG5jb25zdCBMQVNUX1ZBTFVFOiB1bmlxdWUgc3ltYm9sID0gc3ltYm9sKCdMQVNUX1ZBTFVFJyk7XG5jb25zdCBUQUc6IHVuaXF1ZSBzeW1ib2wgPSBzeW1ib2woJ1RBRycpO1xuY29uc3QgU05BUFNIT1Q6IHVuaXF1ZSBzeW1ib2wgPSBzeW1ib2woJ1NOQVBTSE9UJyk7XG5jb25zdCBERUJVR19MQUJFTDogdW5pcXVlIHN5bWJvbCA9IHN5bWJvbCgnREVCVUdfTEFCRUwnKTtcblxuaW50ZXJmYWNlIEludGVybmFsQ2FjaGU8VCA9IHVua25vd24+IHtcbiAgW0ZOXTogKC4uLmFyZ3M6IHVua25vd25bXSkgPT4gVDtcbiAgW0xBU1RfVkFMVUVdOiBUIHwgdW5kZWZpbmVkO1xuICBbVEFHXTogVGFnIHwgdW5kZWZpbmVkO1xuICBbU05BUFNIT1RdOiBSZXZpc2lvbjtcbiAgW0RFQlVHX0xBQkVMXT86IHN0cmluZyB8IGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ2FjaGU8VD4oZm46ICgpID0+IFQsIGRlYnVnZ2luZ0xhYmVsPzogc3RyaW5nIHwgZmFsc2UpOiBDYWNoZTxUPiB7XG4gIGlmIChERUJVRyAmJiAhKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgY3JlYXRlQ2FjaGUoKSBtdXN0IGJlIHBhc3NlZCBhIGZ1bmN0aW9uIGFzIGl0cyBmaXJzdCBwYXJhbWV0ZXIuIENhbGxlZCB3aXRoOiAke1N0cmluZyhmbil9YFxuICAgICk7XG4gIH1cblxuICBsZXQgY2FjaGU6IEludGVybmFsQ2FjaGU8VD4gPSB7XG4gICAgW0ZOXTogZm4sXG4gICAgW0xBU1RfVkFMVUVdOiB1bmRlZmluZWQsXG4gICAgW1RBR106IHVuZGVmaW5lZCxcbiAgICBbU05BUFNIT1RdOiAtMSxcbiAgfTtcblxuICBpZiAoREVCVUcpIHtcbiAgICBjYWNoZVtERUJVR19MQUJFTF0gPSBkZWJ1Z2dpbmdMYWJlbDtcbiAgfVxuXG4gIHJldHVybiAoY2FjaGUgYXMgdW5rbm93bikgYXMgQ2FjaGU8VD47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRWYWx1ZTxUPihjYWNoZTogQ2FjaGU8VD4pOiBUIHwgdW5kZWZpbmVkIHtcbiAgYXNzZXJ0Q2FjaGUoY2FjaGUsICdnZXRWYWx1ZScpO1xuXG4gIGxldCBmbiA9IGNhY2hlW0ZOXTtcbiAgbGV0IHRhZyA9IGNhY2hlW1RBR107XG4gIGxldCBzbmFwc2hvdCA9IGNhY2hlW1NOQVBTSE9UXTtcblxuICBpZiAodGFnID09PSB1bmRlZmluZWQgfHwgIXZhbGlkYXRlVGFnKHRhZywgc25hcHNob3QpKSB7XG4gICAgYmVnaW5UcmFja0ZyYW1lKCk7XG5cbiAgICB0cnkge1xuICAgICAgY2FjaGVbTEFTVF9WQUxVRV0gPSBmbigpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0YWcgPSBlbmRUcmFja0ZyYW1lKCk7XG4gICAgICBjYWNoZVtUQUddID0gdGFnO1xuICAgICAgY2FjaGVbU05BUFNIT1RdID0gdmFsdWVGb3JUYWcodGFnKTtcbiAgICAgIGNvbnN1bWVUYWcodGFnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3VtZVRhZyh0YWcpO1xuICB9XG5cbiAgcmV0dXJuIGNhY2hlW0xBU1RfVkFMVUVdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNDb25zdChjYWNoZTogQ2FjaGUpOiBib29sZWFuIHtcbiAgYXNzZXJ0Q2FjaGUoY2FjaGUsICdpc0NvbnN0Jyk7XG5cbiAgbGV0IHRhZyA9IGNhY2hlW1RBR107XG5cbiAgYXNzZXJ0VGFnKHRhZywgY2FjaGUpO1xuXG4gIHJldHVybiBpc0NvbnN0VGFnKHRhZyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydENhY2hlPFQ+KFxuICB2YWx1ZTogQ2FjaGU8VD4gfCBJbnRlcm5hbENhY2hlPFQ+LFxuICBmbk5hbWU6IHN0cmluZ1xuKTogYXNzZXJ0cyB2YWx1ZSBpcyBJbnRlcm5hbENhY2hlPFQ+IHtcbiAgaWYgKERFQlVHICYmICEodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiBGTiBpbiB2YWx1ZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgJHtmbk5hbWV9KCkgY2FuIG9ubHkgYmUgdXNlZCBvbiBhbiBpbnN0YW5jZSBvZiBhIGNhY2hlIGNyZWF0ZWQgd2l0aCBjcmVhdGVDYWNoZSgpLiBDYWxsZWQgd2l0aDogJHtTdHJpbmcoXG4gICAgICAgIHZhbHVlXG4gICAgICApfWBcbiAgICApO1xuICB9XG59XG5cbi8vIHJlcGxhY2UgdGhpcyB3aXRoIGBleHBlY3RgIHdoZW4gd2UgY2FuXG5mdW5jdGlvbiBhc3NlcnRUYWcodGFnOiBUYWcgfCB1bmRlZmluZWQsIGNhY2hlOiBJbnRlcm5hbENhY2hlKTogYXNzZXJ0cyB0YWcgaXMgVGFnIHtcbiAgaWYgKERFQlVHICYmIHRhZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYGlzQ29uc3QoKSBjYW4gb25seSBiZSB1c2VkIG9uIGEgY2FjaGUgb25jZSBnZXRWYWx1ZSgpIGhhcyBiZWVuIGNhbGxlZCBhdCBsZWFzdCBvbmNlLiBDYWxsZWQgd2l0aCBjYWNoZSBmdW5jdGlvbjpcXG5cXG4ke1N0cmluZyhcbiAgICAgICAgY2FjaGVbRk5dXG4gICAgICApfWBcbiAgICApO1xuICB9XG59XG5cbi8vLy8vLy8vLy9cblxuLy8gTGVnYWN5IHRyYWNraW5nIEFQSXNcblxuLy8gdHJhY2soKSBzaG91bGRuJ3QgYmUgbmVjZXNzYXJ5IGF0IGFsbCBpbiB0aGUgVk0gb25jZSB0aGUgYXV0b3RyYWNraW5nXG4vLyByZWZhY3RvcnMgYXJlIG1lcmdlZCwgYW5kIHdlIHNob3VsZCBnZW5lcmFsbHkgYmUgbW92aW5nIGF3YXkgZnJvbSBpdC4gSXQgbWF5XG4vLyBiZSBuZWNlc3NhcnkgaW4gRW1iZXIgZm9yIGEgd2hpbGUgbG9uZ2VyLCBidXQgSSB0aGluayB3ZSdsbCBiZSBhYmxlIHRvIGRyb3Bcbi8vIGl0IGluIGZhdm9yIG9mIGNhY2hlIHNvb25lciByYXRoZXIgdGhhbiBsYXRlci5cbmV4cG9ydCBmdW5jdGlvbiB0cmFjayhjYWxsYmFjazogKCkgPT4gdm9pZCwgZGVidWdMYWJlbD86IHN0cmluZyB8IGZhbHNlKTogVGFnIHtcbiAgYmVnaW5UcmFja0ZyYW1lKGRlYnVnTGFiZWwpO1xuXG4gIGxldCB0YWc7XG5cbiAgdHJ5IHtcbiAgICBjYWxsYmFjaygpO1xuICB9IGZpbmFsbHkge1xuICAgIHRhZyA9IGVuZFRyYWNrRnJhbWUoKTtcbiAgfVxuXG4gIHJldHVybiB0YWc7XG59XG5cbi8vIHVudHJhY2soKSBpcyBjdXJyZW50bHkgbWFpbmx5IHVzZWQgdG8gaGFuZGxlIHBsYWNlcyB0aGF0IHdlcmUgcHJldmlvdXNseSBub3Rcbi8vIHRyYWNrZWQsIGFuZCB0aGF0IHRyYWNraW5nIG5vdyB3b3VsZCBjYXVzZSBiYWNrdHJhY2tpbmcgcmVyZW5kZXIgYXNzZXJ0aW9ucy5cbi8vIEkgdGhpbmsgb25jZSB3ZSBtb3ZlIGV2ZXJ5b25lIGZvcndhcmQgb250byBtb2Rlcm4gQVBJcywgd2UnbGwgcHJvYmFibHkgYmVcbi8vIGFibGUgdG8gcmVtb3ZlIGl0LCBidXQgSSdtIG5vdCBzdXJlIHlldC5cbmV4cG9ydCBmdW5jdGlvbiB1bnRyYWNrPFQ+KGNhbGxiYWNrOiAoKSA9PiBUKTogVCB7XG4gIGJlZ2luVW50cmFja0ZyYW1lKCk7XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBlbmRVbnRyYWNrRnJhbWUoKTtcbiAgfVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==