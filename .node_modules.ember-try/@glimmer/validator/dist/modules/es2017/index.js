import { symbolFor, getGlobal } from './lib/utils';
const GLIMMER_VALIDATOR_REGISTRATION = symbolFor('GLIMMER_VALIDATOR_REGISTRATION');
const globalObj = getGlobal();

if (globalObj[GLIMMER_VALIDATOR_REGISTRATION] === true) {
  throw new Error('The `@glimmer/validator` library has been included twice in this application. It could be different versions of the package, or the same version included twice by mistake. `@glimmer/validator` depends on having a single copy of the package in use at any time in an application, even if they are the same version. You must dedupe your build to remove the duplicate packages in order to prevent this error.');
}

globalObj[GLIMMER_VALIDATOR_REGISTRATION] = true;
export { ALLOW_CYCLES, bump, combine, COMPUTE, CONSTANT_TAG, CONSTANT, createTag, createUpdatableTag, CurrentTag, CURRENT_TAG, DIRTY_TAG as dirtyTag, INITIAL, isConstTag, UPDATE_TAG as updateTag, validateTag, valueForTag, VolatileTag, VOLATILE_TAG, VOLATILE } from './lib/validators';
export { dirtyTagFor, tagFor, tagMetaFor } from './lib/meta';
export { beginTrackFrame, endTrackFrame, beginUntrackFrame, endUntrackFrame, resetTracking, consumeTag, isTracking, track, untrack, createCache, isConst, getValue } from './lib/tracking';
export { trackedData } from './lib/tracked-data';
export { logTrackingStack, setTrackingTransactionEnv, runInTrackingTransaction, beginTrackingTransaction, endTrackingTransaction, deprecateMutationsInTrackingTransaction } from './lib/debug';
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3ZhbGlkYXRvci9pbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxTQUFTLFNBQVQsRUFBb0IsU0FBcEIsUUFBcUMsYUFBckM7QUFFQSxNQUFNLDhCQUE4QixHQUFHLFNBQVMsQ0FBQyxnQ0FBRCxDQUFoRDtBQUVBLE1BQU0sU0FBUyxHQUFHLFNBQVMsRUFBM0I7O0FBRUEsSUFBSSxTQUFTLENBQUMsOEJBQUQsQ0FBVCxLQUE4QyxJQUFsRCxFQUF3RDtBQUN0RCxRQUFNLElBQUksS0FBSixDQUNKLHNaQURJLENBQU47QUFHRDs7QUFFRCxTQUFTLENBQUMsOEJBQUQsQ0FBVCxHQUE0QyxJQUE1QztBQUVBLFNBQ0UsWUFERixFQUVFLElBRkYsRUFJRSxPQUpGLEVBS0UsT0FMRixFQU1FLFlBTkYsRUFPRSxRQVBGLEVBU0UsU0FURixFQVVFLGtCQVZGLEVBV0UsVUFYRixFQVlFLFdBWkYsRUFhRSxTQUFTLElBQUksUUFiZixFQWdCRSxPQWhCRixFQWlCRSxVQWpCRixFQXFCRSxVQUFVLElBQUksU0FyQmhCLEVBc0JFLFdBdEJGLEVBdUJFLFdBdkJGLEVBd0JFLFdBeEJGLEVBeUJFLFlBekJGLEVBMEJFLFFBMUJGLFFBMkJPLGtCQTNCUDtBQTZCQSxTQUFTLFdBQVQsRUFBc0IsTUFBdEIsRUFBOEIsVUFBOUIsUUFBeUQsWUFBekQ7QUFFQSxTQUNFLGVBREYsRUFFRSxhQUZGLEVBR0UsaUJBSEYsRUFJRSxlQUpGLEVBS0UsYUFMRixFQU1FLFVBTkYsRUFPRSxVQVBGLEVBUUUsS0FSRixFQVNFLE9BVEYsRUFXRSxXQVhGLEVBWUUsT0FaRixFQWFFLFFBYkYsUUFjTyxnQkFkUDtBQWdCQSxTQUFTLFdBQVQsUUFBNEIsb0JBQTVCO0FBRUEsU0FDRSxnQkFERixFQUVFLHlCQUZGLEVBR0Usd0JBSEYsRUFJRSx3QkFKRixFQUtFLHNCQUxGLEVBTUUsdUNBTkYsUUFPTyxhQVBQIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3ltYm9sRm9yLCBnZXRHbG9iYWwgfSBmcm9tICcuL2xpYi91dGlscyc7XG5cbmNvbnN0IEdMSU1NRVJfVkFMSURBVE9SX1JFR0lTVFJBVElPTiA9IHN5bWJvbEZvcignR0xJTU1FUl9WQUxJREFUT1JfUkVHSVNUUkFUSU9OJyk7XG5cbmNvbnN0IGdsb2JhbE9iaiA9IGdldEdsb2JhbCgpO1xuXG5pZiAoZ2xvYmFsT2JqW0dMSU1NRVJfVkFMSURBVE9SX1JFR0lTVFJBVElPTl0gPT09IHRydWUpIHtcbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICdUaGUgYEBnbGltbWVyL3ZhbGlkYXRvcmAgbGlicmFyeSBoYXMgYmVlbiBpbmNsdWRlZCB0d2ljZSBpbiB0aGlzIGFwcGxpY2F0aW9uLiBJdCBjb3VsZCBiZSBkaWZmZXJlbnQgdmVyc2lvbnMgb2YgdGhlIHBhY2thZ2UsIG9yIHRoZSBzYW1lIHZlcnNpb24gaW5jbHVkZWQgdHdpY2UgYnkgbWlzdGFrZS4gYEBnbGltbWVyL3ZhbGlkYXRvcmAgZGVwZW5kcyBvbiBoYXZpbmcgYSBzaW5nbGUgY29weSBvZiB0aGUgcGFja2FnZSBpbiB1c2UgYXQgYW55IHRpbWUgaW4gYW4gYXBwbGljYXRpb24sIGV2ZW4gaWYgdGhleSBhcmUgdGhlIHNhbWUgdmVyc2lvbi4gWW91IG11c3QgZGVkdXBlIHlvdXIgYnVpbGQgdG8gcmVtb3ZlIHRoZSBkdXBsaWNhdGUgcGFja2FnZXMgaW4gb3JkZXIgdG8gcHJldmVudCB0aGlzIGVycm9yLidcbiAgKTtcbn1cblxuZ2xvYmFsT2JqW0dMSU1NRVJfVkFMSURBVE9SX1JFR0lTVFJBVElPTl0gPSB0cnVlO1xuXG5leHBvcnQge1xuICBBTExPV19DWUNMRVMsXG4gIGJ1bXAsXG4gIENvbWJpbmF0b3JUYWcsXG4gIGNvbWJpbmUsXG4gIENPTVBVVEUsXG4gIENPTlNUQU5UX1RBRyxcbiAgQ09OU1RBTlQsXG4gIENvbnN0YW50VGFnLFxuICBjcmVhdGVUYWcsXG4gIGNyZWF0ZVVwZGF0YWJsZVRhZyxcbiAgQ3VycmVudFRhZyxcbiAgQ1VSUkVOVF9UQUcsXG4gIERJUlRZX1RBRyBhcyBkaXJ0eVRhZyxcbiAgRGlydHlhYmxlVGFnLFxuICBFbnRpdHlUYWcsXG4gIElOSVRJQUwsXG4gIGlzQ29uc3RUYWcsXG4gIFJldmlzaW9uLFxuICBUYWcsXG4gIFVwZGF0YWJsZVRhZyxcbiAgVVBEQVRFX1RBRyBhcyB1cGRhdGVUYWcsXG4gIHZhbGlkYXRlVGFnLFxuICB2YWx1ZUZvclRhZyxcbiAgVm9sYXRpbGVUYWcsXG4gIFZPTEFUSUxFX1RBRyxcbiAgVk9MQVRJTEUsXG59IGZyb20gJy4vbGliL3ZhbGlkYXRvcnMnO1xuXG5leHBvcnQgeyBkaXJ0eVRhZ0ZvciwgdGFnRm9yLCB0YWdNZXRhRm9yLCBUYWdNZXRhIH0gZnJvbSAnLi9saWIvbWV0YSc7XG5cbmV4cG9ydCB7XG4gIGJlZ2luVHJhY2tGcmFtZSxcbiAgZW5kVHJhY2tGcmFtZSxcbiAgYmVnaW5VbnRyYWNrRnJhbWUsXG4gIGVuZFVudHJhY2tGcmFtZSxcbiAgcmVzZXRUcmFja2luZyxcbiAgY29uc3VtZVRhZyxcbiAgaXNUcmFja2luZyxcbiAgdHJhY2ssXG4gIHVudHJhY2ssXG4gIENhY2hlLFxuICBjcmVhdGVDYWNoZSxcbiAgaXNDb25zdCxcbiAgZ2V0VmFsdWUsXG59IGZyb20gJy4vbGliL3RyYWNraW5nJztcblxuZXhwb3J0IHsgdHJhY2tlZERhdGEgfSBmcm9tICcuL2xpYi90cmFja2VkLWRhdGEnO1xuXG5leHBvcnQge1xuICBsb2dUcmFja2luZ1N0YWNrLFxuICBzZXRUcmFja2luZ1RyYW5zYWN0aW9uRW52LFxuICBydW5JblRyYWNraW5nVHJhbnNhY3Rpb24sXG4gIGJlZ2luVHJhY2tpbmdUcmFuc2FjdGlvbixcbiAgZW5kVHJhY2tpbmdUcmFuc2FjdGlvbixcbiAgZGVwcmVjYXRlTXV0YXRpb25zSW5UcmFja2luZ1RyYW5zYWN0aW9uLFxufSBmcm9tICcuL2xpYi9kZWJ1Zyc7XG4iXSwic291cmNlUm9vdCI6IiJ9