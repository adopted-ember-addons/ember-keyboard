"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.bump = bump;
exports.valueForTag = valueForTag;
exports.validateTag = validateTag;
exports.createTag = createTag;
exports.createUpdatableTag = createUpdatableTag;
exports.isConstTag = isConstTag;
exports.combine = exports.CURRENT_TAG = exports.CurrentTag = exports.VOLATILE_TAG = exports.VolatileTag = exports.CONSTANT_TAG = exports.UPDATE_TAG = exports.DIRTY_TAG = exports.ALLOW_CYCLES = exports.COMPUTE = exports.VOLATILE = exports.INITIAL = exports.CONSTANT = void 0;

var _env = require("@glimmer/env");

var _globalContext = require("@glimmer/global-context");

var _utils = require("./utils");

var _debug = require("./debug");

const CONSTANT = 0;
exports.CONSTANT = CONSTANT;
const INITIAL = 1;
exports.INITIAL = INITIAL;
const VOLATILE = NaN;
exports.VOLATILE = VOLATILE;
let $REVISION = INITIAL;

function bump() {
  $REVISION++;
} //////////


const COMPUTE = (0, _utils.symbol)('TAG_COMPUTE'); //////////

/**
 * `value` receives a tag and returns an opaque Revision based on that tag. This
 * snapshot can then later be passed to `validate` with the same tag to
 * determine if the tag has changed at all since the time that `value` was
 * called.
 *
 * @param tag
 */

exports.COMPUTE = COMPUTE;

function valueForTag(tag) {
  return tag[COMPUTE]();
}
/**
 * `validate` receives a tag and a snapshot from a previous call to `value` with
 * the same tag, and determines if the tag is still valid compared to the
 * snapshot. If the tag's state has changed at all since then, `validate` will
 * return false, otherwise it will return true. This is used to determine if a
 * calculation related to the tags should be rerun.
 *
 * @param tag
 * @param snapshot
 */


function validateTag(tag, snapshot) {
  return snapshot >= tag[COMPUTE]();
}

const TYPE = (0, _utils.symbol)('TAG_TYPE'); // this is basically a const
// eslint-disable-next-line @typescript-eslint/naming-convention

let ALLOW_CYCLES;
exports.ALLOW_CYCLES = ALLOW_CYCLES;

if (_env.DEBUG) {
  exports.ALLOW_CYCLES = ALLOW_CYCLES = new WeakMap();
}

function allowsCycles(tag) {
  if (ALLOW_CYCLES === undefined) {
    return true;
  } else {
    return ALLOW_CYCLES.has(tag);
  }
}

class MonomorphicTagImpl {
  constructor(type) {
    this.revision = INITIAL;
    this.lastChecked = INITIAL;
    this.lastValue = INITIAL;
    this.isUpdating = false;
    this.subtag = null;
    this.subtagBufferCache = null;
    this[TYPE] = type;
  }

  static combine(tags) {
    switch (tags.length) {
      case 0:
        return CONSTANT_TAG;

      case 1:
        return tags[0];

      default:
        let tag = new MonomorphicTagImpl(2
        /* Combinator */
        );
        tag.subtag = tags;
        return tag;
    }
  }

  [COMPUTE]() {
    let {
      lastChecked
    } = this;

    if (this.isUpdating === true) {
      if (_env.DEBUG && !allowsCycles(this)) {
        throw new Error('Cycles in tags are not allowed');
      }

      this.lastChecked = ++$REVISION;
    } else if (lastChecked !== $REVISION) {
      this.isUpdating = true;
      this.lastChecked = $REVISION;

      try {
        let {
          subtag,
          revision
        } = this;

        if (subtag !== null) {
          if (Array.isArray(subtag)) {
            for (let i = 0; i < subtag.length; i++) {
              let value = subtag[i][COMPUTE]();
              revision = Math.max(value, revision);
            }
          } else {
            let subtagValue = subtag[COMPUTE]();

            if (subtagValue === this.subtagBufferCache) {
              revision = Math.max(revision, this.lastValue);
            } else {
              // Clear the temporary buffer cache
              this.subtagBufferCache = null;
              revision = Math.max(revision, subtagValue);
            }
          }
        }

        this.lastValue = revision;
      } finally {
        this.isUpdating = false;
      }
    }

    return this.lastValue;
  }

  static updateTag(_tag, _subtag) {
    if (_env.DEBUG && _tag[TYPE] !== 1
    /* Updatable */
    ) {
        throw new Error('Attempted to update a tag that was not updatable');
      } // TODO: TS 3.7 should allow us to do this via assertion


    let tag = _tag;
    let subtag = _subtag;

    if (subtag === CONSTANT_TAG) {
      tag.subtag = null;
    } else {
      // There are two different possibilities when updating a subtag:
      //
      // 1. subtag[COMPUTE]() <= tag[COMPUTE]();
      // 2. subtag[COMPUTE]() > tag[COMPUTE]();
      //
      // The first possibility is completely fine within our caching model, but
      // the second possibility presents a problem. If the parent tag has
      // already been read, then it's value is cached and will not update to
      // reflect the subtag's greater value. Next time the cache is busted, the
      // subtag's value _will_ be read, and it's value will be _greater_ than
      // the saved snapshot of the parent, causing the resulting calculation to
      // be rerun erroneously.
      //
      // In order to prevent this, when we first update to a new subtag we store
      // its computed value, and then check against that computed value on
      // subsequent updates. If its value hasn't changed, then we return the
      // parent's previous value. Once the subtag changes for the first time,
      // we clear the cache and everything is finally in sync with the parent.
      tag.subtagBufferCache = subtag[COMPUTE]();
      tag.subtag = subtag;
    }
  }

  static dirtyTag(tag, disableConsumptionAssertion) {
    if (_env.DEBUG && !(tag[TYPE] === 1
    /* Updatable */
    || tag[TYPE] === 0
    /* Dirtyable */
    )) {
      throw new Error('Attempted to dirty a tag that was not dirtyable');
    }

    if (_env.DEBUG && disableConsumptionAssertion !== true) {
      // Usually by this point, we've already asserted with better error information,
      // but this is our last line of defense.
      (0, _utils.unwrap)(_debug.assertTagNotConsumed)(tag);
    }

    tag.revision = ++$REVISION;
    (0, _globalContext.scheduleRevalidate)();
  }

}

const DIRTY_TAG = MonomorphicTagImpl.dirtyTag;
exports.DIRTY_TAG = DIRTY_TAG;
const UPDATE_TAG = MonomorphicTagImpl.updateTag; //////////

exports.UPDATE_TAG = UPDATE_TAG;

function createTag() {
  return new MonomorphicTagImpl(0
  /* Dirtyable */
  );
}

function createUpdatableTag() {
  return new MonomorphicTagImpl(1
  /* Updatable */
  );
} //////////


const CONSTANT_TAG = new MonomorphicTagImpl(3
/* Constant */
);
exports.CONSTANT_TAG = CONSTANT_TAG;

function isConstTag(tag) {
  return tag === CONSTANT_TAG;
} //////////


class VolatileTag {
  [COMPUTE]() {
    return VOLATILE;
  }

}

exports.VolatileTag = VolatileTag;
const VOLATILE_TAG = new VolatileTag(); //////////

exports.VOLATILE_TAG = VOLATILE_TAG;

class CurrentTag {
  [COMPUTE]() {
    return $REVISION;
  }

}

exports.CurrentTag = CurrentTag;
const CURRENT_TAG = new CurrentTag(); //////////

exports.CURRENT_TAG = CURRENT_TAG;
const combine = MonomorphicTagImpl.combine; // Warm

exports.combine = combine;
let tag1 = createUpdatableTag();
let tag2 = createUpdatableTag();
let tag3 = createUpdatableTag();
valueForTag(tag1);
DIRTY_TAG(tag1);
valueForTag(tag1);
UPDATE_TAG(tag1, combine([tag2, tag3]));
valueForTag(tag1);
DIRTY_TAG(tag2);
valueForTag(tag1);
DIRTY_TAG(tag3);
valueForTag(tag1);
UPDATE_TAG(tag1, tag3);
valueForTag(tag1);
DIRTY_TAG(tag3);
valueForTag(tag1);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3ZhbGlkYXRvci9saWIvdmFsaWRhdG9ycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBTU8sTUFBTSxRQUFRLEdBQWQsQ0FBQTs7QUFDQSxNQUFNLE9BQU8sR0FBYixDQUFBOztBQUNBLE1BQU0sUUFBUSxHQUFkLEdBQUE7O0FBRVAsSUFBSSxTQUFTLEdBQWIsT0FBQTs7QUFFTSxTQUFBLElBQUEsR0FBYztBQUNsQixFQUFBLFNBQVM7RUFHWDs7O0FBRU8sTUFBTSxPQUFPLEdBQWtCLG1CQUEvQixhQUErQixDQUEvQixDLENBUVA7O0FBRUE7Ozs7Ozs7Ozs7O0FBUU0sU0FBQSxXQUFBLENBQUEsR0FBQSxFQUE4QjtBQUNsQyxTQUFPLEdBQUcsQ0FBVixPQUFVLENBQUgsRUFBUDtBQUNEO0FBRUQ7Ozs7Ozs7Ozs7OztBQVVNLFNBQUEsV0FBQSxDQUFBLEdBQUEsRUFBQSxRQUFBLEVBQWtEO0FBQ3RELFNBQU8sUUFBUSxJQUFJLEdBQUcsQ0FBdEIsT0FBc0IsQ0FBSCxFQUFuQjtBQUNEOztBQWlCRCxNQUFNLElBQUksR0FBa0IsbUJBQTVCLFVBQTRCLENBQTVCLEMsQ0FFQTtBQUNBOztBQUNPLElBQUEsWUFBQTs7O0FBRVAsSUFBQSxVQUFBLEVBQVc7QUFDVCx5QkFBQSxZQUFZLEdBQUcsSUFBZixPQUFlLEVBQWY7QUFDRDs7QUFFRCxTQUFBLFlBQUEsQ0FBQSxHQUFBLEVBQThCO0FBQzVCLE1BQUksWUFBWSxLQUFoQixTQUFBLEVBQWdDO0FBQzlCLFdBQUEsSUFBQTtBQURGLEdBQUEsTUFFTztBQUNMLFdBQU8sWUFBWSxDQUFaLEdBQUEsQ0FBUCxHQUFPLENBQVA7QUFDRDtBQUNGOztBQVdELE1BQUEsa0JBQUEsQ0FBd0I7QUF1QnRCLEVBQUEsV0FBQSxDQUFBLElBQUEsRUFBbUI7QUFWWCxTQUFBLFFBQUEsR0FBQSxPQUFBO0FB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O0FBQ0Q7O0FBSHFCOzs7QUFNakIsTUFBTSxZQUFZLEdBQUcsSUFBckIsV0FBcUIsRUFBckIsQyxDQUVQOzs7O0FBRU0sTUFBQSxVQUFBLENBQWlCO0FBQ3JCLEdBQUEsT0FBQSxJQUFTO0FBQ1AsV0FBQSxTQUFBO0FBQ0Q7O0FBSG9COzs7QUFNaEIsTUFBTSxXQUFXLEdBQUcsSUFBcEIsVUFBb0IsRUFBcEIsQyxDQUVQOzs7QUFFTyxNQUFNLE9BQU8sR0FBRyxrQkFBa0IsQ0FBbEMsT0FBQSxDLENBRVA7OztBQUVBLElBQUksSUFBSSxHQUFHLGtCQUFYLEVBQUE7QUFDQSxJQUFJLElBQUksR0FBRyxrQkFBWCxFQUFBO0FBQ0EsSUFBSSxJQUFJLEdBQUcsa0JBQVgsRUFBQTtBQUVBLFdBQVcsQ0FBWCxJQUFXLENBQVg7QUFDQSxTQUFTLENBQVQsSUFBUyxDQUFUO0FBQ0EsV0FBVyxDQUFYLElBQVcsQ0FBWDtBQUNBLFVBQVUsQ0FBQSxJQUFBLEVBQU8sT0FBTyxDQUFDLENBQUEsSUFBQSxFQUF6QixJQUF5QixDQUFELENBQWQsQ0FBVjtBQUNBLFdBQVcsQ0FBWCxJQUFXLENBQVg7QUFDQSxTQUFTLENBQVQsSUFBUyxDQUFUO0FBQ0EsV0FBVyxDQUFYLElBQVcsQ0FBWDtBQUNBLFNBQVMsQ0FBVCxJQUFTLENBQVQ7QUFDQSxXQUFXLENBQVgsSUFBVyxDQUFYO0FBQ0EsVUFBVSxDQUFBLElBQUEsRUFBVixJQUFVLENBQVY7QUFDQSxXQUFXLENBQVgsSUFBVyxDQUFYO0FBQ0EsU0FBUyxDQUFULElBQVMsQ0FBVDtBQUNBLFdBQVcsQ0FBWCxJQUFXLENBQVgiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBERUJVRyB9IGZyb20gJ0BnbGltbWVyL2Vudic7XG5pbXBvcnQgeyBzY2hlZHVsZVJldmFsaWRhdGUgfSBmcm9tICdAZ2xpbW1lci9nbG9iYWwtY29udGV4dCc7XG5pbXBvcnQgeyBzeW1ib2wsIHVud3JhcCB9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHsgYXNzZXJ0VGFnTm90Q29uc3VtZWQgfSBmcm9tICcuL2RlYnVnJztcblxuLy8vLy8vLy8vL1xuXG5leHBvcnQgdHlwZSBSZXZpc2lvbiA9IG51bWJlcjtcblxuZXhwb3J0IGNvbnN0IENPTlNUQU5UOiBSZXZpc2lvbiA9IDA7XG5leHBvcnQgY29uc3QgSU5JVElBTDogUmV2aXNpb24gPSAxO1xuZXhwb3J0IGNvbnN0IFZPTEFUSUxFOiBSZXZpc2lvbiA9IE5hTjtcblxubGV0ICRSRVZJU0lPTiA9IElOSVRJQUw7XG5cbmV4cG9ydCBmdW5jdGlvbiBidW1wKCk6IHZvaWQge1xuICAkUkVWSVNJT04rKztcbn1cblxuLy8vLy8vLy8vL1xuXG5leHBvcnQgY29uc3QgQ09NUFVURTogdW5pcXVlIHN5bWJvbCA9IHN5bWJvbCgnVEFHX0NPTVBVVEUnKTtcblxuZXhwb3J0IGludGVyZmFjZSBFbnRpdHlUYWc8VD4ge1xuICBbQ09NUFVURV0oKTogVDtcbn1cblxuZXhwb3J0IHR5cGUgVGFnID0gRW50aXR5VGFnPFJldmlzaW9uPjtcblxuLy8vLy8vLy8vL1xuXG4vKipcbiAqIGB2YWx1ZWAgcmVjZWl2ZXMgYSB0YWcgYW5kIHJldHVybnMgYW4gb3BhcXVlIFJldmlzaW9uIGJhc2VkIG9uIHRoYXQgdGFnLiBUaGlzXG4gKiBzbmFwc2hvdCBjYW4gdGhlbiBsYXRlciBiZSBwYXNzZWQgdG8gYHZhbGlkYXRlYCB3aXRoIHRoZSBzYW1lIHRhZyB0b1xuICogZGV0ZXJtaW5lIGlmIHRoZSB0YWcgaGFzIGNoYW5nZWQgYXQgYWxsIHNpbmNlIHRoZSB0aW1lIHRoYXQgYHZhbHVlYCB3YXNcbiAqIGNhbGxlZC5cbiAqXG4gKiBAcGFyYW0gdGFnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWx1ZUZvclRhZyh0YWc6IFRhZyk6IFJldmlzaW9uIHtcbiAgcmV0dXJuIHRhZ1tDT01QVVRFXSgpO1xufVxuXG4vKipcbiAqIGB2YWxpZGF0ZWAgcmVjZWl2ZXMgYSB0YWcgYW5kIGEgc25hcHNob3QgZnJvbSBhIHByZXZpb3VzIGNhbGwgdG8gYHZhbHVlYCB3aXRoXG4gKiB0aGUgc2FtZSB0YWcsIGFuZCBkZXRlcm1pbmVzIGlmIHRoZSB0YWcgaXMgc3RpbGwgdmFsaWQgY29tcGFyZWQgdG8gdGhlXG4gKiBzbmFwc2hvdC4gSWYgdGhlIHRhZydzIHN0YXRlIGhhcyBjaGFuZ2VkIGF0IGFsbCBzaW5jZSB0aGVuLCBgdmFsaWRhdGVgIHdpbGxcbiAqIHJldHVybiBmYWxzZSwgb3RoZXJ3aXNlIGl0IHdpbGwgcmV0dXJuIHRydWUuIFRoaXMgaXMgdXNlZCB0byBkZXRlcm1pbmUgaWYgYVxuICogY2FsY3VsYXRpb24gcmVsYXRlZCB0byB0aGUgdGFncyBzaG91bGQgYmUgcmVydW4uXG4gKlxuICogQHBhcmFtIHRhZ1xuICogQHBhcmFtIHNuYXBzaG90XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVRhZyh0YWc6IFRhZywgc25hcHNob3Q6IFJldmlzaW9uKTogYm9vbGVhbiB7XG4gIHJldHVybiBzbmFwc2hvdCA+PSB0YWdbQ09NUFVURV0oKTtcbn1cblxuLy8vLy8vLy8vL1xuXG4vKipcbiAqIFRoaXMgZW51bSByZXByZXNlbnRzIGFsbCBvZiB0aGUgcG9zc2libGUgdGFnIHR5cGVzIGZvciB0aGUgbW9ub21vcnBoaWMgdGFnIGNsYXNzLlxuICogT3RoZXIgY3VzdG9tIHRhZyBjbGFzc2VzIGNhbiBleGlzdCwgc3VjaCBhcyBDdXJyZW50VGFnIGFuZCBWb2xhdGlsZVRhZywgYnV0IGZvclxuICogcGVyZm9ybWFuY2UgcmVhc29ucywgYW55IHR5cGUgb2YgdGFnIHRoYXQgaXMgbWVhbnQgdG8gYmUgdXNlZCBmcmVxdWVudGx5IHNob3VsZFxuICogYmUgYWRkZWQgdG8gdGhlIG1vbm9tb3JwaGljIHRhZy5cbiAqL1xuY29uc3QgZW51bSBNb25vbW9ycGhpY1RhZ1R5cGVzIHtcbiAgRGlydHlhYmxlLFxuICBVcGRhdGFibGUsXG4gIENvbWJpbmF0b3IsXG4gIENvbnN0YW50LFxufVxuXG5jb25zdCBUWVBFOiB1bmlxdWUgc3ltYm9sID0gc3ltYm9sKCdUQUdfVFlQRScpO1xuXG4vLyB0aGlzIGlzIGJhc2ljYWxseSBhIGNvbnN0XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5leHBvcnQgbGV0IEFMTE9XX0NZQ0xFUzogV2Vha01hcDxUYWcsIGJvb2xlYW4+IHwgdW5kZWZpbmVkO1xuXG5pZiAoREVCVUcpIHtcbiAgQUxMT1dfQ1lDTEVTID0gbmV3IFdlYWtNYXAoKTtcbn1cblxuZnVuY3Rpb24gYWxsb3dzQ3ljbGVzKHRhZzogVGFnKTogYm9vbGVhbiB7XG4gIGlmIChBTExPV19DWUNMRVMgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBBTExPV19DWUNMRVMuaGFzKHRhZyk7XG4gIH1cbn1cblxuaW50ZXJmYWNlIE1vbm9tb3JwaGljVGFnQmFzZTxUIGV4dGVuZHMgTW9ub21vcnBoaWNUYWdUeXBlcz4gZXh0ZW5kcyBUYWcge1xuICBbVFlQRV06IFQ7XG59XG5cbmV4cG9ydCB0eXBlIERpcnR5YWJsZVRhZyA9IE1vbm9tb3JwaGljVGFnQmFzZTxNb25vbW9ycGhpY1RhZ1R5cGVzLkRpcnR5YWJsZT47XG5leHBvcnQgdHlwZSBVcGRhdGFibGVUYWcgPSBNb25vbW9ycGhpY1RhZ0Jhc2U8TW9ub21vcnBoaWNUYWdUeXBlcy5VcGRhdGFibGU+O1xuZXhwb3J0IHR5cGUgQ29tYmluYXRvclRhZyA9IE1vbm9tb3JwaGljVGFnQmFzZTxNb25vbW9ycGhpY1RhZ1R5cGVzLkNvbWJpbmF0b3I+O1xuZXhwb3J0IHR5cGUgQ29uc3RhbnRUYWcgPSBNb25vbW9ycGhpY1RhZ0Jhc2U8TW9ub21vcnBoaWNUYWdUeXBlcy5Db25zdGFudD47XG5cbmNsYXNzIE1vbm9tb3JwaGljVGFnSW1wbDxUIGV4dGVuZHMgTW9ub21vcnBoaWNUYWdUeXBlcyA9IE1vbm9tb3JwaGljVGFnVHlwZXM+IHtcbiAgc3RhdGljIGNvbWJpbmUodGFnczogVGFnW10pOiBUYWcge1xuICAgIHN3aXRjaCAodGFncy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuIENPTlNUQU5UX1RBRztcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIHRhZ3NbMF07XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBsZXQgdGFnOiBNb25vbW9ycGhpY1RhZ0ltcGwgPSBuZXcgTW9ub21vcnBoaWNUYWdJbXBsKE1vbm9tb3JwaGljVGFnVHlwZXMuQ29tYmluYXRvcik7XG4gICAgICAgIHRhZy5zdWJ0YWcgPSB0YWdzO1xuICAgICAgICByZXR1cm4gdGFnO1xuICAgIH1cbiAgfVxuICBwcml2YXRlIHJldmlzaW9uID0gSU5JVElBTDtcbiAgcHJpdmF0ZSBsYXN0Q2hlY2tlZCA9IElOSVRJQUw7XG4gIHByaXZhdGUgbGFzdFZhbHVlID0gSU5JVElBTDtcblxuICBwcml2YXRlIGlzVXBkYXRpbmcgPSBmYWxzZTtcbiAgcHJpdmF0ZSBzdWJ0YWc6IFRhZyB8IFRhZ1tdIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgc3VidGFnQnVmZmVyQ2FjaGU6IFJldmlzaW9uIHwgbnVsbCA9IG51bGw7XG5cbiAgW1RZUEVdOiBUO1xuXG4gIGNvbnN0cnVjdG9yKHR5cGU6IFQpIHtcbiAgICB0aGlzW1RZUEVdID0gdHlwZTtcbiAgfVxuXG4gIFtDT01QVVRFXSgpOiBSZXZpc2lvbiB7XG4gICAgbGV0IHsgbGFzdENoZWNrZWQgfSA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy5pc1VwZGF0aW5nID09PSB0cnVlKSB7XG4gICAgICBpZiAoREVCVUcgJiYgIWFsbG93c0N5Y2xlcyh0aGlzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0N5Y2xlcyBpbiB0YWdzIGFyZSBub3QgYWxsb3dlZCcpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxhc3RDaGVja2VkID0gKyskUkVWSVNJT047XG4gICAgfSBlbHNlIGlmIChsYXN0Q2hlY2tlZCAhPT0gJFJFVklTSU9OKSB7XG4gICAgICB0aGlzLmlzVXBkYXRpbmcgPSB0cnVlO1xuICAgICAgdGhpcy5sYXN0Q2hlY2tlZCA9ICRSRVZJU0lPTjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IHsgc3VidGFnLCByZXZpc2lvbiB9ID0gdGhpcztcblxuICAgICAgICBpZiAoc3VidGFnICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc3VidGFnKSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdWJ0YWcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgbGV0IHZhbHVlID0gc3VidGFnW2ldW0NPTVBVVEVdKCk7XG4gICAgICAgICAgICAgIHJldmlzaW9uID0gTWF0aC5tYXgodmFsdWUsIHJldmlzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IHN1YnRhZ1ZhbHVlID0gc3VidGFnW0NPTVBVVEVdKCk7XG5cbiAgICAgICAgICAgIGlmIChzdWJ0YWdWYWx1ZSA9PT0gdGhpcy5zdWJ0YWdCdWZmZXJDYWNoZSkge1xuICAgICAgICAgICAgICByZXZpc2lvbiA9IE1hdGgubWF4KHJldmlzaW9uLCB0aGlzLmxhc3RWYWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBDbGVhciB0aGUgdGVtcG9yYXJ5IGJ1ZmZlciBjYWNoZVxuICAgICAgICAgICAgICB0aGlzLnN1YnRhZ0J1ZmZlckNhY2hlID0gbnVsbDtcbiAgICAgICAgICAgICAgcmV2aXNpb24gPSBNYXRoLm1heChyZXZpc2lvbiwgc3VidGFnVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubGFzdFZhbHVlID0gcmV2aXNpb247XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aGlzLmlzVXBkYXRpbmcgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5sYXN0VmFsdWU7XG4gIH1cblxuICBzdGF0aWMgdXBkYXRlVGFnKF90YWc6IFVwZGF0YWJsZVRhZywgX3N1YnRhZzogVGFnKSB7XG4gICAgaWYgKERFQlVHICYmIF90YWdbVFlQRV0gIT09IE1vbm9tb3JwaGljVGFnVHlwZXMuVXBkYXRhYmxlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dGVtcHRlZCB0byB1cGRhdGUgYSB0YWcgdGhhdCB3YXMgbm90IHVwZGF0YWJsZScpO1xuICAgIH1cblxuICAgIC8vIFRPRE86IFRTIDMuNyBzaG91bGQgYWxsb3cgdXMgdG8gZG8gdGhpcyB2aWEgYXNzZXJ0aW9uXG4gICAgbGV0IHRhZyA9IF90YWcgYXMgTW9ub21vcnBoaWNUYWdJbXBsO1xuICAgIGxldCBzdWJ0YWcgPSBfc3VidGFnIGFzIE1vbm9tb3JwaGljVGFnSW1wbDtcblxuICAgIGlmIChzdWJ0YWcgPT09IENPTlNUQU5UX1RBRykge1xuICAgICAgdGFnLnN1YnRhZyA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZXJlIGFyZSB0d28gZGlmZmVyZW50IHBvc3NpYmlsaXRpZXMgd2hlbiB1cGRhdGluZyBhIHN1YnRhZzpcbiAgICAgIC8vXG4gICAgICAvLyAxLiBzdWJ0YWdbQ09NUFVURV0oKSA8PSB0YWdbQ09NUFVURV0oKTtcbiAgICAgIC8vIDIuIHN1YnRhZ1tDT01QVVRFXSgpID4gdGFnW0NPTVBVVEVdKCk7XG4gICAgICAvL1xuICAgICAgLy8gVGhlIGZpcnN0IHBvc3NpYmlsaXR5IGlzIGNvbXBsZXRlbHkgZmluZSB3aXRoaW4gb3VyIGNhY2hpbmcgbW9kZWwsIGJ1dFxuICAgICAgLy8gdGhlIHNlY29uZCBwb3NzaWJpbGl0eSBwcmVzZW50cyBhIHByb2JsZW0uIElmIHRoZSBwYXJlbnQgdGFnIGhhc1xuICAgICAgLy8gYWxyZWFkeSBiZWVuIHJlYWQsIHRoZW4gaXQncyB2YWx1ZSBpcyBjYWNoZWQgYW5kIHdpbGwgbm90IHVwZGF0ZSB0b1xuICAgICAgLy8gcmVmbGVjdCB0aGUgc3VidGFnJ3MgZ3JlYXRlciB2YWx1ZS4gTmV4dCB0aW1lIHRoZSBjYWNoZSBpcyBidXN0ZWQsIHRoZVxuICAgICAgLy8gc3VidGFnJ3MgdmFsdWUgX3dpbGxfIGJlIHJlYWQsIGFuZCBpdCdzIHZhbHVlIHdpbGwgYmUgX2dyZWF0ZXJfIHRoYW5cbiAgICAgIC8vIHRoZSBzYXZlZCBzbmFwc2hvdCBvZiB0aGUgcGFyZW50LCBjYXVzaW5nIHRoZSByZXN1bHRpbmcgY2FsY3VsYXRpb24gdG9cbiAgICAgIC8vIGJlIHJlcnVuIGVycm9uZW91c2x5LlxuICAgICAgLy9cbiAgICAgIC8vIEluIG9yZGVyIHRvIHByZXZlbnQgdGhpcywgd2hlbiB3ZSBmaXJzdCB1cGRhdGUgdG8gYSBuZXcgc3VidGFnIHdlIHN0b3JlXG4gICAgICAvLyBpdHMgY29tcHV0ZWQgdmFsdWUsIGFuZCB0aGVuIGNoZWNrIGFnYWluc3QgdGhhdCBjb21wdXRlZCB2YWx1ZSBvblxuICAgICAgLy8gc3Vic2VxdWVudCB1cGRhdGVzLiBJZiBpdHMgdmFsdWUgaGFzbid0IGNoYW5nZWQsIHRoZW4gd2UgcmV0dXJuIHRoZVxuICAgICAgLy8gcGFyZW50J3MgcHJldmlvdXMgdmFsdWUuIE9uY2UgdGhlIHN1YnRhZyBjaGFuZ2VzIGZvciB0aGUgZmlyc3QgdGltZSxcbiAgICAgIC8vIHdlIGNsZWFyIHRoZSBjYWNoZSBhbmQgZXZlcnl0aGluZyBpcyBmaW5hbGx5IGluIHN5bmMgd2l0aCB0aGUgcGFyZW50LlxuICAgICAgdGFnLnN1YnRhZ0J1ZmZlckNhY2hlID0gc3VidGFnW0NPTVBVVEVdKCk7XG4gICAgICB0YWcuc3VidGFnID0gc3VidGFnO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBkaXJ0eVRhZyh0YWc6IERpcnR5YWJsZVRhZyB8IFVwZGF0YWJsZVRhZywgZGlzYWJsZUNvbnN1bXB0aW9uQXNzZXJ0aW9uPzogYm9vbGVhbikge1xuICAgIGlmIChcbiAgICAgIERFQlVHICYmXG4gICAgICAhKHRhZ1tUWVBFXSA9PT0gTW9ub21vcnBoaWNUYWdUeXBlcy5VcGRhdGFibGUgfHwgdGFnW1RZUEVdID09PSBNb25vbW9ycGhpY1RhZ1R5cGVzLkRpcnR5YWJsZSlcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGVkIHRvIGRpcnR5IGEgdGFnIHRoYXQgd2FzIG5vdCBkaXJ0eWFibGUnKTtcbiAgICB9XG5cbiAgICBpZiAoREVCVUcgJiYgZGlzYWJsZUNvbnN1bXB0aW9uQXNzZXJ0aW9uICE9PSB0cnVlKSB7XG4gICAgICAvLyBVc3VhbGx5IGJ5IHRoaXMgcG9pbnQsIHdlJ3ZlIGFscmVhZHkgYXNzZXJ0ZWQgd2l0aCBiZXR0ZXIgZXJyb3IgaW5mb3JtYXRpb24sXG4gICAgICAvLyBidXQgdGhpcyBpcyBvdXIgbGFzdCBsaW5lIG9mIGRlZmVuc2UuXG4gICAgICB1bndyYXAoYXNzZXJ0VGFnTm90Q29uc3VtZWQpKHRhZyk7XG4gICAgfVxuXG4gICAgKHRhZyBhcyBNb25vbW9ycGhpY1RhZ0ltcGwpLnJldmlzaW9uID0gKyskUkVWSVNJT047XG5cbiAgICBzY2hlZHVsZVJldmFsaWRhdGUoKTtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgRElSVFlfVEFHID0gTW9ub21vcnBoaWNUYWdJbXBsLmRpcnR5VGFnO1xuZXhwb3J0IGNvbnN0IFVQREFURV9UQUcgPSBNb25vbW9ycGhpY1RhZ0ltcGwudXBkYXRlVGFnO1xuXG4vLy8vLy8vLy8vXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVUYWcoKTogRGlydHlhYmxlVGFnIHtcbiAgcmV0dXJuIG5ldyBNb25vbW9ycGhpY1RhZ0ltcGwoTW9ub21vcnBoaWNUYWdUeXBlcy5EaXJ0eWFibGUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVXBkYXRhYmxlVGFnKCk6IFVwZGF0YWJsZVRhZyB7XG4gIHJldHVybiBuZXcgTW9ub21vcnBoaWNUYWdJbXBsKE1vbm9tb3JwaGljVGFnVHlwZXMuVXBkYXRhYmxlKTtcbn1cblxuLy8vLy8vLy8vL1xuXG5leHBvcnQgY29uc3QgQ09OU1RBTlRfVEFHOiBDb25zdGFudFRhZyA9IG5ldyBNb25vbW9ycGhpY1RhZ0ltcGwoTW9ub21vcnBoaWNUYWdUeXBlcy5Db25zdGFudCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0NvbnN0VGFnKHRhZzogVGFnKTogdGFnIGlzIENvbnN0YW50VGFnIHtcbiAgcmV0dXJuIHRhZyA9PT0gQ09OU1RBTlRfVEFHO1xufVxuXG4vLy8vLy8vLy8vXG5cbmV4cG9ydCBjbGFzcyBWb2xhdGlsZVRhZyBpbXBsZW1lbnRzIFRhZyB7XG4gIFtDT01QVVRFXSgpOiBSZXZpc2lvbiB7XG4gICAgcmV0dXJuIFZPTEFUSUxFO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBWT0xBVElMRV9UQUcgPSBuZXcgVm9sYXRpbGVUYWcoKTtcblxuLy8vLy8vLy8vL1xuXG5leHBvcnQgY2xhc3MgQ3VycmVudFRhZyBpbXBsZW1lbnRzIEN1cnJlbnRUYWcge1xuICBbQ09NUFVURV0oKTogUmV2aXNpb24ge1xuICAgIHJldHVybiAkUkVWSVNJT047XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IENVUlJFTlRfVEFHID0gbmV3IEN1cnJlbnRUYWcoKTtcblxuLy8vLy8vLy8vL1xuXG5leHBvcnQgY29uc3QgY29tYmluZSA9IE1vbm9tb3JwaGljVGFnSW1wbC5jb21iaW5lO1xuXG4vLyBXYXJtXG5cbmxldCB0YWcxID0gY3JlYXRlVXBkYXRhYmxlVGFnKCk7XG5sZXQgdGFnMiA9IGNyZWF0ZVVwZGF0YWJsZVRhZygpO1xubGV0IHRhZzMgPSBjcmVhdGVVcGRhdGFibGVUYWcoKTtcblxudmFsdWVGb3JUYWcodGFnMSk7XG5ESVJUWV9UQUcodGFnMSk7XG52YWx1ZUZvclRhZyh0YWcxKTtcblVQREFURV9UQUcodGFnMSwgY29tYmluZShbdGFnMiwgdGFnM10pKTtcbnZhbHVlRm9yVGFnKHRhZzEpO1xuRElSVFlfVEFHKHRhZzIpO1xudmFsdWVGb3JUYWcodGFnMSk7XG5ESVJUWV9UQUcodGFnMyk7XG52YWx1ZUZvclRhZyh0YWcxKTtcblVQREFURV9UQUcodGFnMSwgdGFnMyk7XG52YWx1ZUZvclRhZyh0YWcxKTtcbkRJUlRZX1RBRyh0YWczKTtcbnZhbHVlRm9yVGFnKHRhZzEpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==