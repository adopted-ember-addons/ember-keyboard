"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.indexable = indexable;
exports.getGlobal = getGlobal;
exports.unwrap = unwrap;
exports.symbolFor = exports.symbol = void 0;

// eslint-disable-next-line @typescript-eslint/ban-types
function indexable(input) {
  return input;
} // This is a duplicate utility from @glimmer/util because `@glimmer/validator`
// should not depend on any other @glimmer packages, in order to avoid pulling
// in types and prevent regressions in `@glimmer/tracking` (which has public types).


var symbol = typeof Symbol !== 'undefined' ? Symbol : // eslint-disable-next-line @typescript-eslint/no-explicit-any
function (key) {
  return "__" + key + Math.floor(Math.random() * Date.now()) + "__";
}; // eslint-disable-next-line @typescript-eslint/no-explicit-any

exports.symbol = symbol;
var symbolFor = typeof Symbol !== 'undefined' ? Symbol["for"] : function (key) {
  return "__GLIMMER_VALIDATOR_SYMBOL_FOR_" + key;
};
exports.symbolFor = symbolFor;

function getGlobal() {
  // eslint-disable-next-line node/no-unsupported-features/es-builtins
  if (typeof globalThis !== 'undefined') return indexable(globalThis);
  if (typeof self !== 'undefined') return indexable(self);
  if (typeof window !== 'undefined') return indexable(window);
  if (typeof global !== 'undefined') return indexable(global);
  throw new Error('unable to locate global object');
}

function unwrap(val) {
  if (val === null || val === undefined) throw new Error("Expected value to be present");
  return val;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3ZhbGlkYXRvci9saWIvdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQVVBO0FBQ00sU0FBQSxTQUFBLENBQUEsS0FBQSxFQUE4QztBQUNsRCxTQUFBLEtBQUE7RUFHRjtBQUNBO0FBQ0E7OztBQUNPLElBQU0sTUFBTSxHQUNqQixPQUFBLE1BQUEsS0FBQSxXQUFBLEdBQUEsTUFBQSxHQUVJO0FBQ0MsVUFBRCxHQUFDLEVBQUQ7QUFBQSxTQUFBLE9BQUEsR0FBQSxHQUE0QixJQUFJLENBQUosS0FBQSxDQUFXLElBQUksQ0FBSixNQUFBLEtBQWdCLElBQUksQ0FKMUQsR0FJc0QsRUFBM0IsQ0FBNUIsR0FBQSxJQUFBO0FBSkMsQ0FBQSxDLENBTVA7OztBQUNPLElBQU0sU0FBUyxHQUNwQixPQUFBLE1BQUEsS0FBQSxXQUFBLEdBQ0ksTUFESixDQUFBLEtBQUEsQ0FBQSxHQUVLLFVBQUQsR0FBQyxFQUFEO0FBQUEsU0FBQSxvQ0FIQyxHQUdEO0FBSEMsQ0FBQTs7O0FBS0QsU0FBQSxTQUFBLEdBQW1CO0FBQ3ZCO0FBQ0EsTUFBSSxPQUFBLFVBQUEsS0FBSixXQUFBLEVBQXVDLE9BQU8sU0FBUyxDQUFoQixVQUFnQixDQUFoQjtBQUN2QyxNQUFJLE9BQUEsSUFBQSxLQUFKLFdBQUEsRUFBaUMsT0FBTyxTQUFTLENBQWhCLElBQWdCLENBQWhCO0FBQ2pDLE1BQUksT0FBQSxNQUFBLEtBQUosV0FBQSxFQUFtQyxPQUFPLFNBQVMsQ0FBaEIsTUFBZ0IsQ0FBaEI7QUFDbkMsTUFBSSxPQUFBLE1BQUEsS0FBSixXQUFBLEVBQW1DLE9BQU8sU0FBUyxDQUFoQixNQUFnQixDQUFoQjtBQUVuQyxRQUFNLElBQUEsS0FBQSxDQUFOLGdDQUFNLENBQU47QUFDRDs7QUFFSyxTQUFBLE1BQUEsQ0FBQSxHQUFBLEVBQTZDO0FBQ2pELE1BQUksR0FBRyxLQUFILElBQUEsSUFBZ0IsR0FBRyxLQUF2QixTQUFBLEVBQXVDLE1BQU0sSUFBTixLQUFNLENBQU4sOEJBQU0sQ0FBTjtBQUN2QyxTQUFBLEdBQUE7QUFDRCIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB0eXBlIFVuaW9uVG9JbnRlcnNlY3Rpb248VT4gPSAoVSBleHRlbmRzIHVua25vd24gPyAoazogVSkgPT4gdm9pZCA6IG5ldmVyKSBleHRlbmRzIChcbiAgazogaW5mZXIgSVxuKSA9PiB2b2lkXG4gID8gSVxuICA6IG5ldmVyO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZXhwb3J0IHR5cGUgQW55S2V5ID0ga2V5b2YgYW55O1xuZXhwb3J0IHR5cGUgSW5kZXhhYmxlID0gUmVjb3JkPEFueUtleSwgdW5rbm93bj47XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzXG5leHBvcnQgZnVuY3Rpb24gaW5kZXhhYmxlPFQgZXh0ZW5kcyBvYmplY3Q+KGlucHV0OiBUKTogVCAmIEluZGV4YWJsZSB7XG4gIHJldHVybiBpbnB1dCBhcyBUICYgSW5kZXhhYmxlO1xufVxuXG4vLyBUaGlzIGlzIGEgZHVwbGljYXRlIHV0aWxpdHkgZnJvbSBAZ2xpbW1lci91dGlsIGJlY2F1c2UgYEBnbGltbWVyL3ZhbGlkYXRvcmBcbi8vIHNob3VsZCBub3QgZGVwZW5kIG9uIGFueSBvdGhlciBAZ2xpbW1lciBwYWNrYWdlcywgaW4gb3JkZXIgdG8gYXZvaWQgcHVsbGluZ1xuLy8gaW4gdHlwZXMgYW5kIHByZXZlbnQgcmVncmVzc2lvbnMgaW4gYEBnbGltbWVyL3RyYWNraW5nYCAod2hpY2ggaGFzIHB1YmxpYyB0eXBlcykuXG5leHBvcnQgY29uc3Qgc3ltYm9sID1cbiAgdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCdcbiAgICA/IFN5bWJvbFxuICAgIDogLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgIChrZXk6IHN0cmluZykgPT4gYF9fJHtrZXl9JHtNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBEYXRlLm5vdygpKX1fX2AgYXMgYW55O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZXhwb3J0IGNvbnN0IHN5bWJvbEZvcjogKGtleTogc3RyaW5nKSA9PiBhbnkgPVxuICB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJ1xuICAgID8gU3ltYm9sLmZvclxuICAgIDogKGtleTogc3RyaW5nKSA9PiBgX19HTElNTUVSX1ZBTElEQVRPUl9TWU1CT0xfRk9SXyR7a2V5fWA7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRHbG9iYWwoKTogSW5kZXhhYmxlIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vZGUvbm8tdW5zdXBwb3J0ZWQtZmVhdHVyZXMvZXMtYnVpbHRpbnNcbiAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJykgcmV0dXJuIGluZGV4YWJsZShnbG9iYWxUaGlzKTtcbiAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykgcmV0dXJuIGluZGV4YWJsZShzZWxmKTtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSByZXR1cm4gaW5kZXhhYmxlKHdpbmRvdyk7XG4gIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykgcmV0dXJuIGluZGV4YWJsZShnbG9iYWwpO1xuXG4gIHRocm93IG5ldyBFcnJvcigndW5hYmxlIHRvIGxvY2F0ZSBnbG9iYWwgb2JqZWN0Jyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1bndyYXA8VD4odmFsOiBUIHwgbnVsbCB8IHVuZGVmaW5lZCk6IFQge1xuICBpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIHZhbHVlIHRvIGJlIHByZXNlbnRgKTtcbiAgcmV0dXJuIHZhbCBhcyBUO1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==