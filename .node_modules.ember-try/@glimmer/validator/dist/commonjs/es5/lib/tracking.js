"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.beginTrackFrame = beginTrackFrame;
exports.endTrackFrame = endTrackFrame;
exports.beginUntrackFrame = beginUntrackFrame;
exports.endUntrackFrame = endUntrackFrame;
exports.resetTracking = resetTracking;
exports.isTracking = isTracking;
exports.consumeTag = consumeTag;
exports.createCache = createCache;
exports.getValue = getValue;
exports.isConst = isConst;
exports.track = track;
exports.untrack = untrack;

var _env = require("@glimmer/env");

var _validators = require("./validators");

var _debug = require("./debug");

var _utils = require("./utils");

/**
 * An object that that tracks @tracked properties that were consumed.
 */
var Tracker = /*#__PURE__*/function () {
  function Tracker() {
    this.tags = new Set();
    this.last = null;
  }

  var _proto = Tracker.prototype;

  _proto.add = function add(tag) {
    if (tag === _validators.CONSTANT_TAG) return;
    this.tags.add(tag);

    if (_env.DEBUG) {
      (0, _utils.unwrap)(_debug.markTagAsConsumed)(tag);
    }

    this.last = tag;
  };

  _proto.combine = function combine() {
    var tags = this.tags;

    if (tags.size === 0) {
      return _validators.CONSTANT_TAG;
    } else if (tags.size === 1) {
      return this.last;
    } else {
      var tagsArr = [];
      tags.forEach(function (tag) {
        return tagsArr.push(tag);
      });
      return (0, _validators.combine)(tagsArr);
    }
  };

  return Tracker;
}();
/**
 * Whenever a tracked computed property is entered, the current tracker is
 * saved off and a new tracker is replaced.
 *
 * Any tracked properties consumed are added to the current tracker.
 *
 * When a tracked computed property is exited, the tracker's tags are
 * combined and added to the parent tracker.
 *
 * The consequence is that each tracked computed property has a tag
 * that corresponds to the tracked properties consumed inside of
 * itself, including child tracked computed properties.
 */


var CURRENT_TRACKER = null;
var OPEN_TRACK_FRAMES = [];

function beginTrackFrame(debuggingContext) {
  OPEN_TRACK_FRAMES.push(CURRENT_TRACKER);
  CURRENT_TRACKER = new Tracker();

  if (_env.DEBUG) {
    (0, _utils.unwrap)(_debug.beginTrackingTransaction)(debuggingContext);
  }
}

function endTrackFrame() {
  var current = CURRENT_TRACKER;

  if (_env.DEBUG) {
    if (OPEN_TRACK_FRAMES.length === 0) {
      throw new Error('attempted to close a tracking frame, but one was not open');
    }

    (0, _utils.unwrap)(_debug.endTrackingTransaction)();
  }

  CURRENT_TRACKER = OPEN_TRACK_FRAMES.pop() || null;
  return (0, _utils.unwrap)(current).combine();
}

function beginUntrackFrame() {
  OPEN_TRACK_FRAMES.push(CURRENT_TRACKER);
  CURRENT_TRACKER = null;
}

function endUntrackFrame() {
  if (_env.DEBUG && OPEN_TRACK_FRAMES.length === 0) {
    throw new Error('attempted to close a tracking frame, but one was not open');
  }

  CURRENT_TRACKER = OPEN_TRACK_FRAMES.pop() || null;
} // This function is only for handling errors and resetting to a valid state


function resetTracking() {
  while (OPEN_TRACK_FRAMES.length > 0) {
    OPEN_TRACK_FRAMES.pop();
  }

  CURRENT_TRACKER = null;

  if (_env.DEBUG) {
    return (0, _utils.unwrap)(_debug.resetTrackingTransaction)();
  }
}

function isTracking() {
  return CURRENT_TRACKER !== null;
}

function consumeTag(tag) {
  if (CURRENT_TRACKER !== null) {
    CURRENT_TRACKER.add(tag);
  }
} //////////


var CACHE_KEY = (0, _utils.symbol)('CACHE_KEY');
var FN = (0, _utils.symbol)('FN');
var LAST_VALUE = (0, _utils.symbol)('LAST_VALUE');
var TAG = (0, _utils.symbol)('TAG');
var SNAPSHOT = (0, _utils.symbol)('SNAPSHOT');
var DEBUG_LABEL = (0, _utils.symbol)('DEBUG_LABEL');

function createCache(fn, debuggingLabel) {
  var _cache;

  if (_env.DEBUG && !(typeof fn === 'function')) {
    throw new Error("createCache() must be passed a function as its first parameter. Called with: " + String(fn));
  }

  var cache = (_cache = {}, _cache[FN] = fn, _cache[LAST_VALUE] = undefined, _cache[TAG] = undefined, _cache[SNAPSHOT] = -1, _cache);

  if (_env.DEBUG) {
    cache[DEBUG_LABEL] = debuggingLabel;
  }

  return cache;
}

function getValue(cache) {
  assertCache(cache, 'getValue');
  var fn = cache[FN];
  var tag = cache[TAG];
  var snapshot = cache[SNAPSHOT];

  if (tag === undefined || !(0, _validators.validateTag)(tag, snapshot)) {
    beginTrackFrame();

    try {
      cache[LAST_VALUE] = fn();
    } finally {
      tag = endTrackFrame();
      cache[TAG] = tag;
      cache[SNAPSHOT] = (0, _validators.valueForTag)(tag);
      consumeTag(tag);
    }
  } else {
    consumeTag(tag);
  }

  return cache[LAST_VALUE];
}

function isConst(cache) {
  assertCache(cache, 'isConst');
  var tag = cache[TAG];
  assertTag(tag, cache);
  return (0, _validators.isConstTag)(tag);
}

function assertCache(value, fnName) {
  if (_env.DEBUG && !(typeof value === 'object' && value !== null && FN in value)) {
    throw new Error(fnName + "() can only be used on an instance of a cache created with createCache(). Called with: " + String(value));
  }
} // replace this with `expect` when we can


function assertTag(tag, cache) {
  if (_env.DEBUG && tag === undefined) {
    throw new Error("isConst() can only be used on a cache once getValue() has been called at least once. Called with cache function:\n\n" + String(cache[FN]));
  }
} //////////
// Legacy tracking APIs
// track() shouldn't be necessary at all in the VM once the autotracking
// refactors are merged, and we should generally be moving away from it. It may
// be necessary in Ember for a while longer, but I think we'll be able to drop
// it in favor of cache sooner rather than later.


function track(callback, debugLabel) {
  beginTrackFrame(debugLabel);
  var tag;

  try {
    callback();
  } finally {
    tag = endTrackFrame();
  }

  return tag;
} // untrack() is currently mainly used to handle places that were previously not
// tracked, and that tracking now would cause backtracking rerender assertions.
// I think once we move everyone forward onto modern APIs, we'll probably be
// able to remove it, but I'm not sure yet.


function untrack(callback) {
  beginUntrackFrame();

  try {
    return callback();
  } finally {
    endUntrackFrame();
  }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3ZhbGlkYXRvci9saWIvdHJhY2tpbmcudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0FBQ0E7O0FBVUE7O0FBTUE7O0FBSUE7OztJQUdBLE87QUFBQSxXQUFBLE9BQUEsR0FBQTtBQUNVLFNBQUEsSUFBQSxHQUFPLElBQVAsR0FBTyxFQUFQO0FBQ0EsU0FBQSxJQUFBLEdBQUEsSUFBQTtBQTJCVDs7OztTQXpCQyxHLEdBQUEsU0FBQSxHQUFBLENBQUEsR0FBQSxFQUFZO0FBQ1YsUUFBSSxHQUFHLEtBQVAsd0JBQUEsRUFBMEI7QUFFMUIsU0FBQSxJQUFBLENBQUEsR0FBQSxDQUFBLEdBQUE7O0FBRUEsUUFBQSxVQUFBLEVBQVc7QUFDVCx5QkFBQSx3QkFBQSxFQUFBLEdBQUE7QUFDRDs7QUFFRCxTQUFBLElBQUEsR0FBQSxHQUFBOzs7U0FHRixPLEdBQUEsU0FBQSxPQUFBLEdBQU87QUFBQSxRQUNDLElBREQsR0FBQSxLQUFBLElBQUE7O0FBR0wsUUFBSSxJQUFJLENBQUosSUFBQSxLQUFKLENBQUEsRUFBcUI7QUFDbkIsYUFBQSx3QkFBQTtBQURGLEtBQUEsTUFFTyxJQUFJLElBQUksQ0FBSixJQUFBLEtBQUosQ0FBQSxFQUFxQjtBQUMxQixhQUFPLEtBQVAsSUFBQTtBQURLLEtBQUEsTUFFQTtBQUNMLFVBQUksT0FBTyxHQUFYLEVBQUE7QUFDQSxNQUFBLElBQUksQ0FBSixPQUFBLENBQWMsVUFBRCxHQUFDLEVBQUQ7QUFBQSxlQUFTLE9BQU8sQ0FBUCxJQUFBLENBQXRCLEdBQXNCLENBQVQ7QUFBYixPQUFBO0FBQ0EsYUFBTyx5QkFBUCxPQUFPLENBQVA7QUFDRDs7Ozs7QUFJTDs7Ozs7Ozs7Ozs7Ozs7O0FBYUEsSUFBSSxlQUFlLEdBQW5CLElBQUE7QUFFQSxJQUFNLGlCQUFpQixHQUF2QixFQUFBOztBQUVNLFNBQUEsZUFBQSxDQUFBLGdCQUFBLEVB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QUQzRyxLQUMyRyxDQURyRyxDQUFOO0FBS0Q7RUFHSDs7O0FBQ0EsU0FBQSxTQUFBLENBQUEsR0FBQSxFQUFBLEtBQUEsRUFBNkQ7QUFDM0QsTUFBSSxjQUFTLEdBQUcsS0FBaEIsU0FBQSxFQUFnQztBQUM5QixVQUFNLElBQUEsS0FBQSxDQUFBLHlIQUNtSCxNQUFNLENBQzNILEtBQUssQ0FGVCxFQUVTLENBRHNILENBRHpILENBQU47QUFLRDtFQUdIO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ00sU0FBQSxLQUFBLENBQUEsUUFBQSxFQUFBLFVBQUEsRUFBaUU7QUFDckUsRUFBQSxlQUFlLENBQWYsVUFBZSxDQUFmO0FBRUEsTUFBQSxHQUFBOztBQUVBLE1BQUk7QUFDRixJQUFBLFFBQVE7QUFEVixHQUFBLFNBRVU7QUFDUixJQUFBLEdBQUcsR0FBRyxhQUFOLEVBQUE7QUFDRDs7QUFFRCxTQUFBLEdBQUE7RUFHRjtBQUNBO0FBQ0E7QUFDQTs7O0FBQ00sU0FBQSxPQUFBLENBQUEsUUFBQSxFQUFzQztBQUMxQyxFQUFBLGlCQUFpQjs7QUFFakIsTUFBSTtBQUNGLFdBQU8sUUFBUCxFQUFBO0FBREYsR0FBQSxTQUVVO0FBQ1IsSUFBQSxlQUFlO0FBQ2hCO0FBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBERUJVRyB9IGZyb20gJ0BnbGltbWVyL2Vudic7XG5pbXBvcnQge1xuICBUYWcsXG4gIENPTlNUQU5UX1RBRyxcbiAgdmFsaWRhdGVUYWcsXG4gIFJldmlzaW9uLFxuICB2YWx1ZUZvclRhZyxcbiAgaXNDb25zdFRhZyxcbiAgY29tYmluZSxcbn0gZnJvbSAnLi92YWxpZGF0b3JzJztcblxuaW1wb3J0IHtcbiAgbWFya1RhZ0FzQ29uc3VtZWQsXG4gIGJlZ2luVHJhY2tpbmdUcmFuc2FjdGlvbixcbiAgZW5kVHJhY2tpbmdUcmFuc2FjdGlvbixcbiAgcmVzZXRUcmFja2luZ1RyYW5zYWN0aW9uLFxufSBmcm9tICcuL2RlYnVnJztcbmltcG9ydCB7IHN5bWJvbCwgdW53cmFwIH0gZnJvbSAnLi91dGlscyc7XG5cbnR5cGUgT3B0aW9uPFQ+ID0gVCB8IG51bGw7XG5cbi8qKlxuICogQW4gb2JqZWN0IHRoYXQgdGhhdCB0cmFja3MgQHRyYWNrZWQgcHJvcGVydGllcyB0aGF0IHdlcmUgY29uc3VtZWQuXG4gKi9cbmNsYXNzIFRyYWNrZXIge1xuICBwcml2YXRlIHRhZ3MgPSBuZXcgU2V0PFRhZz4oKTtcbiAgcHJpdmF0ZSBsYXN0OiBPcHRpb248VGFnPiA9IG51bGw7XG5cbiAgYWRkKHRhZzogVGFnKSB7XG4gICAgaWYgKHRhZyA9PT0gQ09OU1RBTlRfVEFHKSByZXR1cm47XG5cbiAgICB0aGlzLnRhZ3MuYWRkKHRhZyk7XG5cbiAgICBpZiAoREVCVUcpIHtcbiAgICAgIHVud3JhcChtYXJrVGFnQXNDb25zdW1lZCkodGFnKTtcbiAgICB9XG5cbiAgICB0aGlzLmxhc3QgPSB0YWc7XG4gIH1cblxuICBjb21iaW5lKCk6IFRhZyB7XG4gICAgbGV0IHsgdGFncyB9ID0gdGhpcztcblxuICAgIGlmICh0YWdzLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiBDT05TVEFOVF9UQUc7XG4gICAgfSBlbHNlIGlmICh0YWdzLnNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiB0aGlzLmxhc3QgYXMgVGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgdGFnc0FycjogVGFnW10gPSBbXTtcbiAgICAgIHRhZ3MuZm9yRWFjaCgodGFnKSA9PiB0YWdzQXJyLnB1c2godGFnKSk7XG4gICAgICByZXR1cm4gY29tYmluZSh0YWdzQXJyKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBXaGVuZXZlciBhIHRyYWNrZWQgY29tcHV0ZWQgcHJvcGVydHkgaXMgZW50ZXJlZCwgdGhlIGN1cnJlbnQgdHJhY2tlciBpc1xuICogc2F2ZWQgb2ZmIGFuZCBhIG5ldyB0cmFja2VyIGlzIHJlcGxhY2VkLlxuICpcbiAqIEFueSB0cmFja2VkIHByb3BlcnRpZXMgY29uc3VtZWQgYXJlIGFkZGVkIHRvIHRoZSBjdXJyZW50IHRyYWNrZXIuXG4gKlxuICogV2hlbiBhIHRyYWNrZWQgY29tcHV0ZWQgcHJvcGVydHkgaXMgZXhpdGVkLCB0aGUgdHJhY2tlcidzIHRhZ3MgYXJlXG4gKiBjb21iaW5lZCBhbmQgYWRkZWQgdG8gdGhlIHBhcmVudCB0cmFja2VyLlxuICpcbiAqIFRoZSBjb25zZXF1ZW5jZSBpcyB0aGF0IGVhY2ggdHJhY2tlZCBjb21wdXRlZCBwcm9wZXJ0eSBoYXMgYSB0YWdcbiAqIHRoYXQgY29ycmVzcG9uZHMgdG8gdGhlIHRyYWNrZWQgcHJvcGVydGllcyBjb25zdW1lZCBpbnNpZGUgb2ZcbiAqIGl0c2VsZiwgaW5jbHVkaW5nIGNoaWxkIHRyYWNrZWQgY29tcHV0ZWQgcHJvcGVydGllcy5cbiAqL1xubGV0IENVUlJFTlRfVFJBQ0tFUjogT3B0aW9uPFRyYWNrZXI+ID0gbnVsbDtcblxuY29uc3QgT1BFTl9UUkFDS19GUkFNRVM6IE9wdGlvbjxUcmFja2VyPltdID0gW107XG5cbmV4cG9ydCBmdW5jdGlvbiBiZWdpblRyYWNrRnJhbWUoZGVidWdnaW5nQ29udGV4dD86IHN0cmluZyB8IGZhbHNlKTogdm9pZCB7XG4gIE9QRU5fVFJBQ0tfRlJBTUVTLnB1c2goQ1VSUkVOVF9UUkFDS0VSKTtcblxuICBDVVJSRU5UX1RSQUNLRVIgPSBuZXcgVHJhY2tlcigpO1xuXG4gIGlmIChERUJVRykge1xuICAgIHVud3JhcChiZWdpblRyYWNraW5nVHJhbnNhY3Rpb24pKGRlYnVnZ2luZ0NvbnRleHQpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlbmRUcmFja0ZyYW1lKCk6IFRhZyB7XG4gIGxldCBjdXJyZW50ID0gQ1VSUkVOVF9UUkFDS0VSO1xuXG4gIGlmIChERUJVRykge1xuICAgIGlmIChPUEVOX1RSQUNLX0ZSQU1FUy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYXR0ZW1wdGVkIHRvIGNsb3NlIGEgdHJhY2tpbmcgZnJhbWUsIGJ1dCBvbmUgd2FzIG5vdCBvcGVuJyk7XG4gICAgfVxuXG4gICAgdW53cmFwKGVuZFRyYWNraW5nVHJhbnNhY3Rpb24pKCk7XG4gIH1cblxuICBDVVJSRU5UX1RSQUNLRVIgPSBPUEVOX1RSQUNLX0ZSQU1FUy5wb3AoKSB8fCBudWxsO1xuXG4gIHJldHVybiB1bndyYXAoY3VycmVudCkuY29tYmluZSgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYmVnaW5VbnRyYWNrRnJhbWUoKTogdm9pZCB7XG4gIE9QRU5fVFJBQ0tfRlJBTUVTLnB1c2goQ1VSUkVOVF9UUkFDS0VSKTtcbiAgQ1VSUkVOVF9UUkFDS0VSID0gbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVuZFVudHJhY2tGcmFtZSgpOiB2b2lkIHtcbiAgaWYgKERFQlVHICYmIE9QRU5fVFJBQ0tfRlJBTUVTLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignYXR0ZW1wdGVkIHRvIGNsb3NlIGEgdHJhY2tpbmcgZnJhbWUsIGJ1dCBvbmUgd2FzIG5vdCBvcGVuJyk7XG4gIH1cblxuICBDVVJSRU5UX1RSQUNLRVIgPSBPUEVOX1RSQUNLX0ZSQU1FUy5wb3AoKSB8fCBudWxsO1xufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIG9ubHkgZm9yIGhhbmRsaW5nIGVycm9ycyBhbmQgcmVzZXR0aW5nIHRvIGEgdmFsaWQgc3RhdGVcbmV4cG9ydCBmdW5jdGlvbiByZXNldFRyYWNraW5nKCk6IHN0cmluZyB8IHZvaWQge1xuICB3aGlsZSAoT1BFTl9UUkFDS19GUkFNRVMubGVuZ3RoID4gMCkge1xuICAgIE9QRU5fVFJBQ0tfRlJBTUVTLnBvcCgpO1xuICB9XG5cbiAgQ1VSUkVOVF9UUkFDS0VSID0gbnVsbDtcblxuICBpZiAoREVCVUcpIHtcbiAgICByZXR1cm4gdW53cmFwKHJlc2V0VHJhY2tpbmdUcmFuc2FjdGlvbikoKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNUcmFja2luZygpOiBib29sZWFuIHtcbiAgcmV0dXJuIENVUlJFTlRfVFJBQ0tFUiAhPT0gbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbnN1bWVUYWcodGFnOiBUYWcpOiB2b2lkIHtcbiAgaWYgKENVUlJFTlRfVFJBQ0tFUiAhPT0gbnVsbCkge1xuICAgIENVUlJFTlRfVFJBQ0tFUi5hZGQodGFnKTtcbiAgfVxufVxuXG4vLy8vLy8vLy8vXG5cbmNvbnN0IENBQ0hFX0tFWTogdW5pcXVlIHN5bWJvbCA9IHN5bWJvbCgnQ0FDSEVfS0VZJyk7XG5cbi8vIHB1YmxpYyBpbnRlcmZhY2VcbmV4cG9ydCBpbnRlcmZhY2UgQ2FjaGU8VCA9IHVua25vd24+IHtcbiAgW0NBQ0hFX0tFWV06IFQ7XG59XG5cbmNvbnN0IEZOOiB1bmlxdWUgc3ltYm9sID0gc3ltYm9sKCdGTicpO1xuY29uc3QgTEFTVF9WQUxVRTogdW5pcXVlIHN5bWJvbCA9IHN5bWJvbCgnTEFTVF9WQUxVRScpO1xuY29uc3QgVEFHOiB1bmlxdWUgc3ltYm9sID0gc3ltYm9sKCdUQUcnKTtcbmNvbnN0IFNOQVBTSE9UOiB1bmlxdWUgc3ltYm9sID0gc3ltYm9sKCdTTkFQU0hPVCcpO1xuY29uc3QgREVCVUdfTEFCRUw6IHVuaXF1ZSBzeW1ib2wgPSBzeW1ib2woJ0RFQlVHX0xBQkVMJyk7XG5cbmludGVyZmFjZSBJbnRlcm5hbENhY2hlPFQgPSB1bmtub3duPiB7XG4gIFtGTl06ICguLi5hcmdzOiB1bmtub3duW10pID0+IFQ7XG4gIFtMQVNUX1ZBTFVFXTogVCB8IHVuZGVmaW5lZDtcbiAgW1RBR106IFRhZyB8IHVuZGVmaW5lZDtcbiAgW1NOQVBTSE9UXTogUmV2aXNpb247XG4gIFtERUJVR19MQUJFTF0/OiBzdHJpbmcgfCBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNhY2hlPFQ+KGZuOiAoKSA9PiBULCBkZWJ1Z2dpbmdMYWJlbD86IHN0cmluZyB8IGZhbHNlKTogQ2FjaGU8VD4ge1xuICBpZiAoREVCVUcgJiYgISh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYGNyZWF0ZUNhY2hlKCkgbXVzdCBiZSBwYXNzZWQgYSBmdW5jdGlvbiBhcyBpdHMgZmlyc3QgcGFyYW1ldGVyLiBDYWxsZWQgd2l0aDogJHtTdHJpbmcoZm4pfWBcbiAgICApO1xuICB9XG5cbiAgbGV0IGNhY2hlOiBJbnRlcm5hbENhY2hlPFQ+ID0ge1xuICAgIFtGTl06IGZuLFxuICAgIFtMQVNUX1ZBTFVFXTogdW5kZWZpbmVkLFxuICAgIFtUQUddOiB1bmRlZmluZWQsXG4gICAgW1NOQVBTSE9UXTogLTEsXG4gIH07XG5cbiAgaWYgKERFQlVHKSB7XG4gICAgY2FjaGVbREVCVUdfTEFCRUxdID0gZGVidWdnaW5nTGFiZWw7XG4gIH1cblxuICByZXR1cm4gKGNhY2hlIGFzIHVua25vd24pIGFzIENhY2hlPFQ+O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VmFsdWU8VD4oY2FjaGU6IENhY2hlPFQ+KTogVCB8IHVuZGVmaW5lZCB7XG4gIGFzc2VydENhY2hlKGNhY2hlLCAnZ2V0VmFsdWUnKTtcblxuICBsZXQgZm4gPSBjYWNoZVtGTl07XG4gIGxldCB0YWcgPSBjYWNoZVtUQUddO1xuICBsZXQgc25hcHNob3QgPSBjYWNoZVtTTkFQU0hPVF07XG5cbiAgaWYgKHRhZyA9PT0gdW5kZWZpbmVkIHx8ICF2YWxpZGF0ZVRhZyh0YWcsIHNuYXBzaG90KSkge1xuICAgIGJlZ2luVHJhY2tGcmFtZSgpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNhY2hlW0xBU1RfVkFMVUVdID0gZm4oKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGFnID0gZW5kVHJhY2tGcmFtZSgpO1xuICAgICAgY2FjaGVbVEFHXSA9IHRhZztcbiAgICAgIGNhY2hlW1NOQVBTSE9UXSA9IHZhbHVlRm9yVGFnKHRhZyk7XG4gICAgICBjb25zdW1lVGFnKHRhZyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN1bWVUYWcodGFnKTtcbiAgfVxuXG4gIHJldHVybiBjYWNoZVtMQVNUX1ZBTFVFXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQ29uc3QoY2FjaGU6IENhY2hlKTogYm9vbGVhbiB7XG4gIGFzc2VydENhY2hlKGNhY2hlLCAnaXNDb25zdCcpO1xuXG4gIGxldCB0YWcgPSBjYWNoZVtUQUddO1xuXG4gIGFzc2VydFRhZyh0YWcsIGNhY2hlKTtcblxuICByZXR1cm4gaXNDb25zdFRhZyh0YWcpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRDYWNoZTxUPihcbiAgdmFsdWU6IENhY2hlPFQ+IHwgSW50ZXJuYWxDYWNoZTxUPixcbiAgZm5OYW1lOiBzdHJpbmdcbik6IGFzc2VydHMgdmFsdWUgaXMgSW50ZXJuYWxDYWNoZTxUPiB7XG4gIGlmIChERUJVRyAmJiAhKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwgJiYgRk4gaW4gdmFsdWUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYCR7Zm5OYW1lfSgpIGNhbiBvbmx5IGJlIHVzZWQgb24gYW4gaW5zdGFuY2Ugb2YgYSBjYWNoZSBjcmVhdGVkIHdpdGggY3JlYXRlQ2FjaGUoKS4gQ2FsbGVkIHdpdGg6ICR7U3RyaW5nKFxuICAgICAgICB2YWx1ZVxuICAgICAgKX1gXG4gICAgKTtcbiAgfVxufVxuXG4vLyByZXBsYWNlIHRoaXMgd2l0aCBgZXhwZWN0YCB3aGVuIHdlIGNhblxuZnVuY3Rpb24gYXNzZXJ0VGFnKHRhZzogVGFnIHwgdW5kZWZpbmVkLCBjYWNoZTogSW50ZXJuYWxDYWNoZSk6IGFzc2VydHMgdGFnIGlzIFRhZyB7XG4gIGlmIChERUJVRyAmJiB0YWcgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBpc0NvbnN0KCkgY2FuIG9ubHkgYmUgdXNlZCBvbiBhIGNhY2hlIG9uY2UgZ2V0VmFsdWUoKSBoYXMgYmVlbiBjYWxsZWQgYXQgbGVhc3Qgb25jZS4gQ2FsbGVkIHdpdGggY2FjaGUgZnVuY3Rpb246XFxuXFxuJHtTdHJpbmcoXG4gICAgICAgIGNhY2hlW0ZOXVxuICAgICAgKX1gXG4gICAgKTtcbiAgfVxufVxuXG4vLy8vLy8vLy8vXG5cbi8vIExlZ2FjeSB0cmFja2luZyBBUElzXG5cbi8vIHRyYWNrKCkgc2hvdWxkbid0IGJlIG5lY2Vzc2FyeSBhdCBhbGwgaW4gdGhlIFZNIG9uY2UgdGhlIGF1dG90cmFja2luZ1xuLy8gcmVmYWN0b3JzIGFyZSBtZXJnZWQsIGFuZCB3ZSBzaG91bGQgZ2VuZXJhbGx5IGJlIG1vdmluZyBhd2F5IGZyb20gaXQuIEl0IG1heVxuLy8gYmUgbmVjZXNzYXJ5IGluIEVtYmVyIGZvciBhIHdoaWxlIGxvbmdlciwgYnV0IEkgdGhpbmsgd2UnbGwgYmUgYWJsZSB0byBkcm9wXG4vLyBpdCBpbiBmYXZvciBvZiBjYWNoZSBzb29uZXIgcmF0aGVyIHRoYW4gbGF0ZXIuXG5leHBvcnQgZnVuY3Rpb24gdHJhY2soY2FsbGJhY2s6ICgpID0+IHZvaWQsIGRlYnVnTGFiZWw/OiBzdHJpbmcgfCBmYWxzZSk6IFRhZyB7XG4gIGJlZ2luVHJhY2tGcmFtZShkZWJ1Z0xhYmVsKTtcblxuICBsZXQgdGFnO1xuXG4gIHRyeSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfSBmaW5hbGx5IHtcbiAgICB0YWcgPSBlbmRUcmFja0ZyYW1lKCk7XG4gIH1cblxuICByZXR1cm4gdGFnO1xufVxuXG4vLyB1bnRyYWNrKCkgaXMgY3VycmVudGx5IG1haW5seSB1c2VkIHRvIGhhbmRsZSBwbGFjZXMgdGhhdCB3ZXJlIHByZXZpb3VzbHkgbm90XG4vLyB0cmFja2VkLCBhbmQgdGhhdCB0cmFja2luZyBub3cgd291bGQgY2F1c2UgYmFja3RyYWNraW5nIHJlcmVuZGVyIGFzc2VydGlvbnMuXG4vLyBJIHRoaW5rIG9uY2Ugd2UgbW92ZSBldmVyeW9uZSBmb3J3YXJkIG9udG8gbW9kZXJuIEFQSXMsIHdlJ2xsIHByb2JhYmx5IGJlXG4vLyBhYmxlIHRvIHJlbW92ZSBpdCwgYnV0IEknbSBub3Qgc3VyZSB5ZXQuXG5leHBvcnQgZnVuY3Rpb24gdW50cmFjazxUPihjYWxsYmFjazogKCkgPT4gVCk6IFQge1xuICBiZWdpblVudHJhY2tGcmFtZSgpO1xuXG4gIHRyeSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gIH0gZmluYWxseSB7XG4gICAgZW5kVW50cmFja0ZyYW1lKCk7XG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=